// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `playlist_permission.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.Permission)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Permission {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Permission.revision)
    pub revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Permission.permission_level)
    pub permission_level: ::std::option::Option<::protobuf::EnumOrUnknown<PermissionLevel>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.Permission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Permission {
    fn default() -> &'a Permission {
        <Permission as ::protobuf::Message>::default_instance()
    }
}

impl Permission {
    pub fn new() -> Permission {
        ::std::default::Default::default()
    }

    // optional bytes revision = 1;

    pub fn revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .spotify.playlist_permission.proto.PermissionLevel permission_level = 2;

    pub fn permission_level(&self) -> PermissionLevel {
        match self.permission_level {
            Some(e) => e.enum_value_or(PermissionLevel::UNKNOWN),
            None => PermissionLevel::UNKNOWN,
        }
    }

    pub fn clear_permission_level(&mut self) {
        self.permission_level = ::std::option::Option::None;
    }

    pub fn has_permission_level(&self) -> bool {
        self.permission_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_level(&mut self, v: PermissionLevel) {
        self.permission_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &Permission| { &m.revision },
            |m: &mut Permission| { &mut m.revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permission_level",
            |m: &Permission| { &m.permission_level },
            |m: &mut Permission| { &mut m.permission_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Permission>(
            "Permission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Permission {
    const NAME: &'static str = "Permission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.permission_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.permission_level {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.permission_level {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Permission {
        Permission::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.permission_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Permission {
        static instance: Permission = Permission {
            revision: ::std::option::Option::None,
            permission_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Permission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Permission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Permission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.GrantableLevels)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GrantableLevels {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.GrantableLevels.base)
    pub base: ::std::vec::Vec<::protobuf::EnumOrUnknown<PermissionLevel>>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.GrantableLevels.member)
    pub member: ::std::vec::Vec<::protobuf::EnumOrUnknown<PermissionLevel>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.GrantableLevels.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GrantableLevels {
    fn default() -> &'a GrantableLevels {
        <GrantableLevels as ::protobuf::Message>::default_instance()
    }
}

impl GrantableLevels {
    pub fn new() -> GrantableLevels {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "base",
            |m: &GrantableLevels| { &m.base },
            |m: &mut GrantableLevels| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "member",
            |m: &GrantableLevels| { &m.member },
            |m: &mut GrantableLevels| { &mut m.member },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GrantableLevels>(
            "GrantableLevels",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GrantableLevels {
    const NAME: &'static str = "GrantableLevels";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.base.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.base)?
                },
                16 => {
                    self.member.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.member)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.base {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        for value in &self.member {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.base {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.member {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GrantableLevels {
        GrantableLevels::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.member.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GrantableLevels {
        static instance: GrantableLevels = GrantableLevels {
            base: ::std::vec::Vec::new(),
            member: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GrantableLevels {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GrantableLevels").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GrantableLevels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GrantableLevels {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.AttributeCapabilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AttributeCapabilities {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.AttributeCapabilities.can_edit)
    pub can_edit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.AttributeCapabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AttributeCapabilities {
    fn default() -> &'a AttributeCapabilities {
        <AttributeCapabilities as ::protobuf::Message>::default_instance()
    }
}

impl AttributeCapabilities {
    pub fn new() -> AttributeCapabilities {
        ::std::default::Default::default()
    }

    // optional bool can_edit = 1;

    pub fn can_edit(&self) -> bool {
        self.can_edit.unwrap_or(false)
    }

    pub fn clear_can_edit(&mut self) {
        self.can_edit = ::std::option::Option::None;
    }

    pub fn has_can_edit(&self) -> bool {
        self.can_edit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_edit(&mut self, v: bool) {
        self.can_edit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_edit",
            |m: &AttributeCapabilities| { &m.can_edit },
            |m: &mut AttributeCapabilities| { &mut m.can_edit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttributeCapabilities>(
            "AttributeCapabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AttributeCapabilities {
    const NAME: &'static str = "AttributeCapabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.can_edit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.can_edit {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.can_edit {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AttributeCapabilities {
        AttributeCapabilities::new()
    }

    fn clear(&mut self) {
        self.can_edit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AttributeCapabilities {
        static instance: AttributeCapabilities = AttributeCapabilities {
            can_edit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AttributeCapabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AttributeCapabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AttributeCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeCapabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.ListAttributeCapabilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAttributeCapabilities {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ListAttributeCapabilities.name)
    pub name: ::protobuf::MessageField<AttributeCapabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ListAttributeCapabilities.description)
    pub description: ::protobuf::MessageField<AttributeCapabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ListAttributeCapabilities.picture)
    pub picture: ::protobuf::MessageField<AttributeCapabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ListAttributeCapabilities.collaborative)
    pub collaborative: ::protobuf::MessageField<AttributeCapabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ListAttributeCapabilities.deleted_by_owner)
    pub deleted_by_owner: ::protobuf::MessageField<AttributeCapabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ListAttributeCapabilities.ai_curation_reference_id)
    pub ai_curation_reference_id: ::protobuf::MessageField<AttributeCapabilities>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.ListAttributeCapabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAttributeCapabilities {
    fn default() -> &'a ListAttributeCapabilities {
        <ListAttributeCapabilities as ::protobuf::Message>::default_instance()
    }
}

impl ListAttributeCapabilities {
    pub fn new() -> ListAttributeCapabilities {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttributeCapabilities>(
            "name",
            |m: &ListAttributeCapabilities| { &m.name },
            |m: &mut ListAttributeCapabilities| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttributeCapabilities>(
            "description",
            |m: &ListAttributeCapabilities| { &m.description },
            |m: &mut ListAttributeCapabilities| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttributeCapabilities>(
            "picture",
            |m: &ListAttributeCapabilities| { &m.picture },
            |m: &mut ListAttributeCapabilities| { &mut m.picture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttributeCapabilities>(
            "collaborative",
            |m: &ListAttributeCapabilities| { &m.collaborative },
            |m: &mut ListAttributeCapabilities| { &mut m.collaborative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttributeCapabilities>(
            "deleted_by_owner",
            |m: &ListAttributeCapabilities| { &m.deleted_by_owner },
            |m: &mut ListAttributeCapabilities| { &mut m.deleted_by_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttributeCapabilities>(
            "ai_curation_reference_id",
            |m: &ListAttributeCapabilities| { &m.ai_curation_reference_id },
            |m: &mut ListAttributeCapabilities| { &mut m.ai_curation_reference_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAttributeCapabilities>(
            "ListAttributeCapabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAttributeCapabilities {
    const NAME: &'static str = "ListAttributeCapabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.name)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.description)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.picture)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.collaborative)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deleted_by_owner)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ai_curation_reference_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.picture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.collaborative.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deleted_by_owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ai_curation_reference_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.description.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.picture.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.collaborative.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.deleted_by_owner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.ai_curation_reference_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAttributeCapabilities {
        ListAttributeCapabilities::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.picture.clear();
        self.collaborative.clear();
        self.deleted_by_owner.clear();
        self.ai_curation_reference_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAttributeCapabilities {
        static instance: ListAttributeCapabilities = ListAttributeCapabilities {
            name: ::protobuf::MessageField::none(),
            description: ::protobuf::MessageField::none(),
            picture: ::protobuf::MessageField::none(),
            collaborative: ::protobuf::MessageField::none(),
            deleted_by_owner: ::protobuf::MessageField::none(),
            ai_curation_reference_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAttributeCapabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAttributeCapabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAttributeCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAttributeCapabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.Capabilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Capabilities {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.can_view)
    pub can_view: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.can_administrate_permissions)
    pub can_administrate_permissions: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.grantable_level)
    pub grantable_level: ::std::vec::Vec<::protobuf::EnumOrUnknown<PermissionLevel>>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.can_edit_metadata)
    pub can_edit_metadata: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.can_edit_items)
    pub can_edit_items: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.can_cancel_membership)
    pub can_cancel_membership: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.grantable_levels)
    pub grantable_levels: ::protobuf::MessageField<GrantableLevels>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Capabilities.list_attribute_capabilities)
    pub list_attribute_capabilities: ::protobuf::MessageField<ListAttributeCapabilities>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.Capabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Capabilities {
    fn default() -> &'a Capabilities {
        <Capabilities as ::protobuf::Message>::default_instance()
    }
}

impl Capabilities {
    pub fn new() -> Capabilities {
        ::std::default::Default::default()
    }

    // optional bool can_view = 1;

    pub fn can_view(&self) -> bool {
        self.can_view.unwrap_or(false)
    }

    pub fn clear_can_view(&mut self) {
        self.can_view = ::std::option::Option::None;
    }

    pub fn has_can_view(&self) -> bool {
        self.can_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_view(&mut self, v: bool) {
        self.can_view = ::std::option::Option::Some(v);
    }

    // optional bool can_administrate_permissions = 2;

    pub fn can_administrate_permissions(&self) -> bool {
        self.can_administrate_permissions.unwrap_or(false)
    }

    pub fn clear_can_administrate_permissions(&mut self) {
        self.can_administrate_permissions = ::std::option::Option::None;
    }

    pub fn has_can_administrate_permissions(&self) -> bool {
        self.can_administrate_permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_administrate_permissions(&mut self, v: bool) {
        self.can_administrate_permissions = ::std::option::Option::Some(v);
    }

    // optional bool can_edit_metadata = 4;

    pub fn can_edit_metadata(&self) -> bool {
        self.can_edit_metadata.unwrap_or(false)
    }

    pub fn clear_can_edit_metadata(&mut self) {
        self.can_edit_metadata = ::std::option::Option::None;
    }

    pub fn has_can_edit_metadata(&self) -> bool {
        self.can_edit_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_edit_metadata(&mut self, v: bool) {
        self.can_edit_metadata = ::std::option::Option::Some(v);
    }

    // optional bool can_edit_items = 5;

    pub fn can_edit_items(&self) -> bool {
        self.can_edit_items.unwrap_or(false)
    }

    pub fn clear_can_edit_items(&mut self) {
        self.can_edit_items = ::std::option::Option::None;
    }

    pub fn has_can_edit_items(&self) -> bool {
        self.can_edit_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_edit_items(&mut self, v: bool) {
        self.can_edit_items = ::std::option::Option::Some(v);
    }

    // optional bool can_cancel_membership = 6;

    pub fn can_cancel_membership(&self) -> bool {
        self.can_cancel_membership.unwrap_or(false)
    }

    pub fn clear_can_cancel_membership(&mut self) {
        self.can_cancel_membership = ::std::option::Option::None;
    }

    pub fn has_can_cancel_membership(&self) -> bool {
        self.can_cancel_membership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_cancel_membership(&mut self, v: bool) {
        self.can_cancel_membership = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_view",
            |m: &Capabilities| { &m.can_view },
            |m: &mut Capabilities| { &mut m.can_view },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_administrate_permissions",
            |m: &Capabilities| { &m.can_administrate_permissions },
            |m: &mut Capabilities| { &mut m.can_administrate_permissions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "grantable_level",
            |m: &Capabilities| { &m.grantable_level },
            |m: &mut Capabilities| { &mut m.grantable_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_edit_metadata",
            |m: &Capabilities| { &m.can_edit_metadata },
            |m: &mut Capabilities| { &mut m.can_edit_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_edit_items",
            |m: &Capabilities| { &m.can_edit_items },
            |m: &mut Capabilities| { &mut m.can_edit_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_cancel_membership",
            |m: &Capabilities| { &m.can_cancel_membership },
            |m: &mut Capabilities| { &mut m.can_cancel_membership },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GrantableLevels>(
            "grantable_levels",
            |m: &Capabilities| { &m.grantable_levels },
            |m: &mut Capabilities| { &mut m.grantable_levels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListAttributeCapabilities>(
            "list_attribute_capabilities",
            |m: &Capabilities| { &m.list_attribute_capabilities },
            |m: &mut Capabilities| { &mut m.list_attribute_capabilities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Capabilities>(
            "Capabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Capabilities {
    const NAME: &'static str = "Capabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.can_view = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.can_administrate_permissions = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.grantable_level.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.grantable_level)?
                },
                32 => {
                    self.can_edit_metadata = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.can_edit_items = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.can_cancel_membership = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.grantable_levels)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.list_attribute_capabilities)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.can_view {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_administrate_permissions {
            my_size += 1 + 1;
        }
        for value in &self.grantable_level {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        if let Some(v) = self.can_edit_metadata {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_edit_items {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_cancel_membership {
            my_size += 1 + 1;
        }
        if let Some(v) = self.grantable_levels.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.list_attribute_capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.can_view {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.can_administrate_permissions {
            os.write_bool(2, v)?;
        }
        for v in &self.grantable_level {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.can_edit_metadata {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_edit_items {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.can_cancel_membership {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.grantable_levels.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.list_attribute_capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Capabilities {
        Capabilities::new()
    }

    fn clear(&mut self) {
        self.can_view = ::std::option::Option::None;
        self.can_administrate_permissions = ::std::option::Option::None;
        self.grantable_level.clear();
        self.can_edit_metadata = ::std::option::Option::None;
        self.can_edit_items = ::std::option::Option::None;
        self.can_cancel_membership = ::std::option::Option::None;
        self.grantable_levels.clear();
        self.list_attribute_capabilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Capabilities {
        static instance: Capabilities = Capabilities {
            can_view: ::std::option::Option::None,
            can_administrate_permissions: ::std::option::Option::None,
            grantable_level: ::std::vec::Vec::new(),
            can_edit_metadata: ::std::option::Option::None,
            can_edit_items: ::std::option::Option::None,
            can_cancel_membership: ::std::option::Option::None,
            grantable_levels: ::protobuf::MessageField::none(),
            list_attribute_capabilities: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Capabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Capabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Capabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.CapabilitiesMultiRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CapabilitiesMultiRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesMultiRequest.request)
    pub request: ::std::vec::Vec<CapabilitiesRequest>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesMultiRequest.fallback_username)
    pub fallback_username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesMultiRequest.fallback_user_id)
    pub fallback_user_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesMultiRequest.fallback_uri)
    pub fallback_uri: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.CapabilitiesMultiRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CapabilitiesMultiRequest {
    fn default() -> &'a CapabilitiesMultiRequest {
        <CapabilitiesMultiRequest as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitiesMultiRequest {
    pub fn new() -> CapabilitiesMultiRequest {
        ::std::default::Default::default()
    }

    // optional string fallback_username = 2;

    pub fn fallback_username(&self) -> &str {
        match self.fallback_username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fallback_username(&mut self) {
        self.fallback_username = ::std::option::Option::None;
    }

    pub fn has_fallback_username(&self) -> bool {
        self.fallback_username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallback_username(&mut self, v: ::std::string::String) {
        self.fallback_username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_username(&mut self) -> &mut ::std::string::String {
        if self.fallback_username.is_none() {
            self.fallback_username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fallback_username.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallback_username(&mut self) -> ::std::string::String {
        self.fallback_username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fallback_user_id = 3;

    pub fn fallback_user_id(&self) -> &str {
        match self.fallback_user_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fallback_user_id(&mut self) {
        self.fallback_user_id = ::std::option::Option::None;
    }

    pub fn has_fallback_user_id(&self) -> bool {
        self.fallback_user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallback_user_id(&mut self, v: ::std::string::String) {
        self.fallback_user_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_user_id(&mut self) -> &mut ::std::string::String {
        if self.fallback_user_id.is_none() {
            self.fallback_user_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fallback_user_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallback_user_id(&mut self) -> ::std::string::String {
        self.fallback_user_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fallback_uri = 4;

    pub fn fallback_uri(&self) -> &str {
        match self.fallback_uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fallback_uri(&mut self) {
        self.fallback_uri = ::std::option::Option::None;
    }

    pub fn has_fallback_uri(&self) -> bool {
        self.fallback_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallback_uri(&mut self, v: ::std::string::String) {
        self.fallback_uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_uri(&mut self) -> &mut ::std::string::String {
        if self.fallback_uri.is_none() {
            self.fallback_uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fallback_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallback_uri(&mut self) -> ::std::string::String {
        self.fallback_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "request",
            |m: &CapabilitiesMultiRequest| { &m.request },
            |m: &mut CapabilitiesMultiRequest| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fallback_username",
            |m: &CapabilitiesMultiRequest| { &m.fallback_username },
            |m: &mut CapabilitiesMultiRequest| { &mut m.fallback_username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fallback_user_id",
            |m: &CapabilitiesMultiRequest| { &m.fallback_user_id },
            |m: &mut CapabilitiesMultiRequest| { &mut m.fallback_user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fallback_uri",
            |m: &CapabilitiesMultiRequest| { &m.fallback_uri },
            |m: &mut CapabilitiesMultiRequest| { &mut m.fallback_uri },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CapabilitiesMultiRequest>(
            "CapabilitiesMultiRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CapabilitiesMultiRequest {
    const NAME: &'static str = "CapabilitiesMultiRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request.push(is.read_message()?);
                },
                18 => {
                    self.fallback_username = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fallback_user_id = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fallback_uri = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.request {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fallback_username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fallback_user_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fallback_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.request {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.fallback_username.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fallback_user_id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fallback_uri.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CapabilitiesMultiRequest {
        CapabilitiesMultiRequest::new()
    }

    fn clear(&mut self) {
        self.request.clear();
        self.fallback_username = ::std::option::Option::None;
        self.fallback_user_id = ::std::option::Option::None;
        self.fallback_uri = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CapabilitiesMultiRequest {
        static instance: CapabilitiesMultiRequest = CapabilitiesMultiRequest {
            request: ::std::vec::Vec::new(),
            fallback_username: ::std::option::Option::None,
            fallback_user_id: ::std::option::Option::None,
            fallback_uri: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CapabilitiesMultiRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CapabilitiesMultiRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CapabilitiesMultiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitiesMultiRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.CapabilitiesRequestOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CapabilitiesRequestOptions {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesRequestOptions.can_view_only)
    pub can_view_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.CapabilitiesRequestOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CapabilitiesRequestOptions {
    fn default() -> &'a CapabilitiesRequestOptions {
        <CapabilitiesRequestOptions as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitiesRequestOptions {
    pub fn new() -> CapabilitiesRequestOptions {
        ::std::default::Default::default()
    }

    // optional bool can_view_only = 1;

    pub fn can_view_only(&self) -> bool {
        self.can_view_only.unwrap_or(false)
    }

    pub fn clear_can_view_only(&mut self) {
        self.can_view_only = ::std::option::Option::None;
    }

    pub fn has_can_view_only(&self) -> bool {
        self.can_view_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_view_only(&mut self, v: bool) {
        self.can_view_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_view_only",
            |m: &CapabilitiesRequestOptions| { &m.can_view_only },
            |m: &mut CapabilitiesRequestOptions| { &mut m.can_view_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CapabilitiesRequestOptions>(
            "CapabilitiesRequestOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CapabilitiesRequestOptions {
    const NAME: &'static str = "CapabilitiesRequestOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.can_view_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.can_view_only {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.can_view_only {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CapabilitiesRequestOptions {
        CapabilitiesRequestOptions::new()
    }

    fn clear(&mut self) {
        self.can_view_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CapabilitiesRequestOptions {
        static instance: CapabilitiesRequestOptions = CapabilitiesRequestOptions {
            can_view_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CapabilitiesRequestOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CapabilitiesRequestOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CapabilitiesRequestOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitiesRequestOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.CapabilitiesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CapabilitiesRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesRequest.username)
    pub username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesRequest.user_id)
    pub user_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesRequest.uri)
    pub uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesRequest.user_is_owner)
    pub user_is_owner: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesRequest.permission_grant_token)
    pub permission_grant_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesRequest.request_options)
    pub request_options: ::protobuf::MessageField<CapabilitiesRequestOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.CapabilitiesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CapabilitiesRequest {
    fn default() -> &'a CapabilitiesRequest {
        <CapabilitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitiesRequest {
    pub fn new() -> CapabilitiesRequest {
        ::std::default::Default::default()
    }

    // optional string username = 1;

    pub fn username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user_id = 2;

    pub fn user_id(&self) -> &str {
        match self.user_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        if self.user_id.is_none() {
            self.user_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        self.user_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uri = 3;

    pub fn uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        self.uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool user_is_owner = 4;

    pub fn user_is_owner(&self) -> bool {
        self.user_is_owner.unwrap_or(false)
    }

    pub fn clear_user_is_owner(&mut self) {
        self.user_is_owner = ::std::option::Option::None;
    }

    pub fn has_user_is_owner(&self) -> bool {
        self.user_is_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_is_owner(&mut self, v: bool) {
        self.user_is_owner = ::std::option::Option::Some(v);
    }

    // optional string permission_grant_token = 5;

    pub fn permission_grant_token(&self) -> &str {
        match self.permission_grant_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_permission_grant_token(&mut self) {
        self.permission_grant_token = ::std::option::Option::None;
    }

    pub fn has_permission_grant_token(&self) -> bool {
        self.permission_grant_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_grant_token(&mut self, v: ::std::string::String) {
        self.permission_grant_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission_grant_token(&mut self) -> &mut ::std::string::String {
        if self.permission_grant_token.is_none() {
            self.permission_grant_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.permission_grant_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission_grant_token(&mut self) -> ::std::string::String {
        self.permission_grant_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &CapabilitiesRequest| { &m.username },
            |m: &mut CapabilitiesRequest| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_id",
            |m: &CapabilitiesRequest| { &m.user_id },
            |m: &mut CapabilitiesRequest| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &CapabilitiesRequest| { &m.uri },
            |m: &mut CapabilitiesRequest| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_is_owner",
            |m: &CapabilitiesRequest| { &m.user_is_owner },
            |m: &mut CapabilitiesRequest| { &mut m.user_is_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permission_grant_token",
            |m: &CapabilitiesRequest| { &m.permission_grant_token },
            |m: &mut CapabilitiesRequest| { &mut m.permission_grant_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CapabilitiesRequestOptions>(
            "request_options",
            |m: &CapabilitiesRequest| { &m.request_options },
            |m: &mut CapabilitiesRequest| { &mut m.request_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CapabilitiesRequest>(
            "CapabilitiesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CapabilitiesRequest {
    const NAME: &'static str = "CapabilitiesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.user_id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.uri = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.user_is_owner = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.permission_grant_token = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.request_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.user_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.user_is_owner {
            my_size += 1 + 1;
        }
        if let Some(v) = self.permission_grant_token.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.request_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.username.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.user_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.uri.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.user_is_owner {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.permission_grant_token.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.request_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CapabilitiesRequest {
        CapabilitiesRequest::new()
    }

    fn clear(&mut self) {
        self.username = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.uri = ::std::option::Option::None;
        self.user_is_owner = ::std::option::Option::None;
        self.permission_grant_token = ::std::option::Option::None;
        self.request_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CapabilitiesRequest {
        static instance: CapabilitiesRequest = CapabilitiesRequest {
            username: ::std::option::Option::None,
            user_id: ::std::option::Option::None,
            uri: ::std::option::Option::None,
            user_is_owner: ::std::option::Option::None,
            permission_grant_token: ::std::option::Option::None,
            request_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CapabilitiesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CapabilitiesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CapabilitiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitiesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.CapabilitiesMultiResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CapabilitiesMultiResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesMultiResponse.response)
    pub response: ::std::vec::Vec<CapabilitiesResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.CapabilitiesMultiResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CapabilitiesMultiResponse {
    fn default() -> &'a CapabilitiesMultiResponse {
        <CapabilitiesMultiResponse as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitiesMultiResponse {
    pub fn new() -> CapabilitiesMultiResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "response",
            |m: &CapabilitiesMultiResponse| { &m.response },
            |m: &mut CapabilitiesMultiResponse| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CapabilitiesMultiResponse>(
            "CapabilitiesMultiResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CapabilitiesMultiResponse {
    const NAME: &'static str = "CapabilitiesMultiResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.response {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.response {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CapabilitiesMultiResponse {
        CapabilitiesMultiResponse::new()
    }

    fn clear(&mut self) {
        self.response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CapabilitiesMultiResponse {
        static instance: CapabilitiesMultiResponse = CapabilitiesMultiResponse {
            response: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CapabilitiesMultiResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CapabilitiesMultiResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CapabilitiesMultiResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitiesMultiResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.CapabilitiesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CapabilitiesResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesResponse.status)
    pub status: ::protobuf::MessageField<ResponseStatus>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CapabilitiesResponse.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.CapabilitiesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CapabilitiesResponse {
    fn default() -> &'a CapabilitiesResponse {
        <CapabilitiesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitiesResponse {
    pub fn new() -> CapabilitiesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResponseStatus>(
            "status",
            |m: &CapabilitiesResponse| { &m.status },
            |m: &mut CapabilitiesResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &CapabilitiesResponse| { &m.capabilities },
            |m: &mut CapabilitiesResponse| { &mut m.capabilities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CapabilitiesResponse>(
            "CapabilitiesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CapabilitiesResponse {
    const NAME: &'static str = "CapabilitiesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CapabilitiesResponse {
        CapabilitiesResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.capabilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CapabilitiesResponse {
        static instance: CapabilitiesResponse = CapabilitiesResponse {
            status: ::protobuf::MessageField::none(),
            capabilities: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CapabilitiesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CapabilitiesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CapabilitiesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitiesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.SetPermissionLevelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetPermissionLevelRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.SetPermissionLevelRequest.permission_level)
    pub permission_level: ::std::option::Option<::protobuf::EnumOrUnknown<PermissionLevel>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.SetPermissionLevelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPermissionLevelRequest {
    fn default() -> &'a SetPermissionLevelRequest {
        <SetPermissionLevelRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPermissionLevelRequest {
    pub fn new() -> SetPermissionLevelRequest {
        ::std::default::Default::default()
    }

    // optional .spotify.playlist_permission.proto.PermissionLevel permission_level = 1;

    pub fn permission_level(&self) -> PermissionLevel {
        match self.permission_level {
            Some(e) => e.enum_value_or(PermissionLevel::UNKNOWN),
            None => PermissionLevel::UNKNOWN,
        }
    }

    pub fn clear_permission_level(&mut self) {
        self.permission_level = ::std::option::Option::None;
    }

    pub fn has_permission_level(&self) -> bool {
        self.permission_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_level(&mut self, v: PermissionLevel) {
        self.permission_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permission_level",
            |m: &SetPermissionLevelRequest| { &m.permission_level },
            |m: &mut SetPermissionLevelRequest| { &mut m.permission_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPermissionLevelRequest>(
            "SetPermissionLevelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPermissionLevelRequest {
    const NAME: &'static str = "SetPermissionLevelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission_level {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission_level {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPermissionLevelRequest {
        SetPermissionLevelRequest::new()
    }

    fn clear(&mut self) {
        self.permission_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPermissionLevelRequest {
        static instance: SetPermissionLevelRequest = SetPermissionLevelRequest {
            permission_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPermissionLevelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPermissionLevelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPermissionLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionLevelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.SetPermissionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetPermissionResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.SetPermissionResponse.resulting_permission)
    pub resulting_permission: ::protobuf::MessageField<Permission>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.SetPermissionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPermissionResponse {
    fn default() -> &'a SetPermissionResponse {
        <SetPermissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetPermissionResponse {
    pub fn new() -> SetPermissionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permission>(
            "resulting_permission",
            |m: &SetPermissionResponse| { &m.resulting_permission },
            |m: &mut SetPermissionResponse| { &mut m.resulting_permission },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPermissionResponse>(
            "SetPermissionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPermissionResponse {
    const NAME: &'static str = "SetPermissionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resulting_permission)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resulting_permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resulting_permission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPermissionResponse {
        SetPermissionResponse::new()
    }

    fn clear(&mut self) {
        self.resulting_permission.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPermissionResponse {
        static instance: SetPermissionResponse = SetPermissionResponse {
            resulting_permission: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPermissionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPermissionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.GetMemberPermissionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMemberPermissionsResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.GetMemberPermissionsResponse.member_permissions)
    pub member_permissions: ::std::collections::HashMap<::std::string::String, Permission>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.GetMemberPermissionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMemberPermissionsResponse {
    fn default() -> &'a GetMemberPermissionsResponse {
        <GetMemberPermissionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMemberPermissionsResponse {
    pub fn new() -> GetMemberPermissionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "member_permissions",
            |m: &GetMemberPermissionsResponse| { &m.member_permissions },
            |m: &mut GetMemberPermissionsResponse| { &mut m.member_permissions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetMemberPermissionsResponse>(
            "GetMemberPermissionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetMemberPermissionsResponse {
    const NAME: &'static str = "GetMemberPermissionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.member_permissions.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.member_permissions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.member_permissions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMemberPermissionsResponse {
        GetMemberPermissionsResponse::new()
    }

    fn clear(&mut self) {
        self.member_permissions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMemberPermissionsResponse {
        static instance: ::protobuf::rt::Lazy<GetMemberPermissionsResponse> = ::protobuf::rt::Lazy::new();
        instance.get(GetMemberPermissionsResponse::new)
    }
}

impl ::protobuf::MessageFull for GetMemberPermissionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetMemberPermissionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetMemberPermissionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMemberPermissionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.Permissions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Permissions {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.Permissions.base_permission)
    pub base_permission: ::protobuf::MessageField<Permission>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.Permissions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Permissions {
    fn default() -> &'a Permissions {
        <Permissions as ::protobuf::Message>::default_instance()
    }
}

impl Permissions {
    pub fn new() -> Permissions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permission>(
            "base_permission",
            |m: &Permissions| { &m.base_permission },
            |m: &mut Permissions| { &mut m.base_permission },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Permissions>(
            "Permissions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Permissions {
    const NAME: &'static str = "Permissions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_permission)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_permission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Permissions {
        Permissions::new()
    }

    fn clear(&mut self) {
        self.base_permission.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Permissions {
        static instance: Permissions = Permissions {
            base_permission: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Permissions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Permissions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Permissions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permissions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionState {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionState.permissions)
    pub permissions: ::protobuf::MessageField<Permissions>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionState.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionState.is_private)
    pub is_private: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionState.is_collaborative)
    pub is_collaborative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionState {
    fn default() -> &'a PermissionState {
        <PermissionState as ::protobuf::Message>::default_instance()
    }
}

impl PermissionState {
    pub fn new() -> PermissionState {
        ::std::default::Default::default()
    }

    // optional bool is_private = 3;

    pub fn is_private(&self) -> bool {
        self.is_private.unwrap_or(false)
    }

    pub fn clear_is_private(&mut self) {
        self.is_private = ::std::option::Option::None;
    }

    pub fn has_is_private(&self) -> bool {
        self.is_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_private(&mut self, v: bool) {
        self.is_private = ::std::option::Option::Some(v);
    }

    // optional bool is_collaborative = 4;

    pub fn is_collaborative(&self) -> bool {
        self.is_collaborative.unwrap_or(false)
    }

    pub fn clear_is_collaborative(&mut self) {
        self.is_collaborative = ::std::option::Option::None;
    }

    pub fn has_is_collaborative(&self) -> bool {
        self.is_collaborative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_collaborative(&mut self, v: bool) {
        self.is_collaborative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permissions>(
            "permissions",
            |m: &PermissionState| { &m.permissions },
            |m: &mut PermissionState| { &mut m.permissions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &PermissionState| { &m.capabilities },
            |m: &mut PermissionState| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_private",
            |m: &PermissionState| { &m.is_private },
            |m: &mut PermissionState| { &mut m.is_private },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_collaborative",
            |m: &PermissionState| { &m.is_collaborative },
            |m: &mut PermissionState| { &mut m.is_collaborative },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionState>(
            "PermissionState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionState {
    const NAME: &'static str = "PermissionState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permissions)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                24 => {
                    self.is_private = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_collaborative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permissions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.is_private {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_collaborative {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permissions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.is_private {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_collaborative {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionState {
        PermissionState::new()
    }

    fn clear(&mut self) {
        self.permissions.clear();
        self.capabilities.clear();
        self.is_private = ::std::option::Option::None;
        self.is_collaborative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionState {
        static instance: PermissionState = PermissionState {
            permissions: ::protobuf::MessageField::none(),
            capabilities: ::protobuf::MessageField::none(),
            is_private: ::std::option::Option::None,
            is_collaborative: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionStatePub)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionStatePub {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionStatePub.permission_state)
    pub permission_state: ::protobuf::MessageField<PermissionState>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionStatePub.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionStatePub {
    fn default() -> &'a PermissionStatePub {
        <PermissionStatePub as ::protobuf::Message>::default_instance()
    }
}

impl PermissionStatePub {
    pub fn new() -> PermissionStatePub {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PermissionState>(
            "permission_state",
            |m: &PermissionStatePub| { &m.permission_state },
            |m: &mut PermissionStatePub| { &mut m.permission_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionStatePub>(
            "PermissionStatePub",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionStatePub {
    const NAME: &'static str = "PermissionStatePub";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permission_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionStatePub {
        PermissionStatePub::new()
    }

    fn clear(&mut self) {
        self.permission_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionStatePub {
        static instance: PermissionStatePub = PermissionStatePub {
            permission_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionStatePub {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionStatePub").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionStatePub {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionStatePub {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionGrantOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionGrantOptions {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantOptions.permission)
    pub permission: ::protobuf::MessageField<Permission>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantOptions.ttl_ms)
    pub ttl_ms: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionGrantOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionGrantOptions {
    fn default() -> &'a PermissionGrantOptions {
        <PermissionGrantOptions as ::protobuf::Message>::default_instance()
    }
}

impl PermissionGrantOptions {
    pub fn new() -> PermissionGrantOptions {
        ::std::default::Default::default()
    }

    // optional int64 ttl_ms = 2;

    pub fn ttl_ms(&self) -> i64 {
        self.ttl_ms.unwrap_or(0)
    }

    pub fn clear_ttl_ms(&mut self) {
        self.ttl_ms = ::std::option::Option::None;
    }

    pub fn has_ttl_ms(&self) -> bool {
        self.ttl_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttl_ms(&mut self, v: i64) {
        self.ttl_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permission>(
            "permission",
            |m: &PermissionGrantOptions| { &m.permission },
            |m: &mut PermissionGrantOptions| { &mut m.permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ttl_ms",
            |m: &PermissionGrantOptions| { &m.ttl_ms },
            |m: &mut PermissionGrantOptions| { &mut m.ttl_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionGrantOptions>(
            "PermissionGrantOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionGrantOptions {
    const NAME: &'static str = "PermissionGrantOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permission)?;
                },
                16 => {
                    self.ttl_ms = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ttl_ms {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.ttl_ms {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionGrantOptions {
        PermissionGrantOptions::new()
    }

    fn clear(&mut self) {
        self.permission.clear();
        self.ttl_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionGrantOptions {
        static instance: PermissionGrantOptions = PermissionGrantOptions {
            permission: ::protobuf::MessageField::none(),
            ttl_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionGrantOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionGrantOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionGrantOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionGrantOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionGrant)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionGrant {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrant.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrant.permission_grant_options)
    pub permission_grant_options: ::protobuf::MessageField<PermissionGrantOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionGrant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionGrant {
    fn default() -> &'a PermissionGrant {
        <PermissionGrant as ::protobuf::Message>::default_instance()
    }
}

impl PermissionGrant {
    pub fn new() -> PermissionGrant {
        ::std::default::Default::default()
    }

    // optional string token = 1;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &PermissionGrant| { &m.token },
            |m: &mut PermissionGrant| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PermissionGrantOptions>(
            "permission_grant_options",
            |m: &PermissionGrant| { &m.permission_grant_options },
            |m: &mut PermissionGrant| { &mut m.permission_grant_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionGrant>(
            "PermissionGrant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionGrant {
    const NAME: &'static str = "PermissionGrant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permission_grant_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.permission_grant_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.permission_grant_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionGrant {
        PermissionGrant::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.permission_grant_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionGrant {
        static instance: PermissionGrant = PermissionGrant {
            token: ::std::option::Option::None,
            permission_grant_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionGrant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionGrant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionGrant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionGrant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionGrantDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionGrantDetails {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantDetails.permission_level_downgraded)
    pub permission_level_downgraded: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionGrantDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionGrantDetails {
    fn default() -> &'a PermissionGrantDetails {
        <PermissionGrantDetails as ::protobuf::Message>::default_instance()
    }
}

impl PermissionGrantDetails {
    pub fn new() -> PermissionGrantDetails {
        ::std::default::Default::default()
    }

    // optional bool permission_level_downgraded = 1;

    pub fn permission_level_downgraded(&self) -> bool {
        self.permission_level_downgraded.unwrap_or(false)
    }

    pub fn clear_permission_level_downgraded(&mut self) {
        self.permission_level_downgraded = ::std::option::Option::None;
    }

    pub fn has_permission_level_downgraded(&self) -> bool {
        self.permission_level_downgraded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_level_downgraded(&mut self, v: bool) {
        self.permission_level_downgraded = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permission_level_downgraded",
            |m: &PermissionGrantDetails| { &m.permission_level_downgraded },
            |m: &mut PermissionGrantDetails| { &mut m.permission_level_downgraded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionGrantDetails>(
            "PermissionGrantDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionGrantDetails {
    const NAME: &'static str = "PermissionGrantDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission_level_downgraded = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission_level_downgraded {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission_level_downgraded {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionGrantDetails {
        PermissionGrantDetails::new()
    }

    fn clear(&mut self) {
        self.permission_level_downgraded = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionGrantDetails {
        static instance: PermissionGrantDetails = PermissionGrantDetails {
            permission_level_downgraded: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionGrantDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionGrantDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionGrantDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionGrantDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionGrantDescription)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionGrantDescription {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantDescription.permission_grant_options)
    pub permission_grant_options: ::protobuf::MessageField<PermissionGrantOptions>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantDescription.claim_fail_reason)
    pub claim_fail_reason: ::std::option::Option<::protobuf::EnumOrUnknown<permission_grant_description::ClaimFailReason>>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantDescription.is_effective)
    pub is_effective: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantDescription.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionGrantDescription.details)
    pub details: ::std::vec::Vec<PermissionGrantDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionGrantDescription.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionGrantDescription {
    fn default() -> &'a PermissionGrantDescription {
        <PermissionGrantDescription as ::protobuf::Message>::default_instance()
    }
}

impl PermissionGrantDescription {
    pub fn new() -> PermissionGrantDescription {
        ::std::default::Default::default()
    }

    // optional .spotify.playlist_permission.proto.PermissionGrantDescription.ClaimFailReason claim_fail_reason = 2;

    pub fn claim_fail_reason(&self) -> permission_grant_description::ClaimFailReason {
        match self.claim_fail_reason {
            Some(e) => e.enum_value_or(permission_grant_description::ClaimFailReason::CLAIM_FAIL_REASON_UNSPECIFIED),
            None => permission_grant_description::ClaimFailReason::CLAIM_FAIL_REASON_UNSPECIFIED,
        }
    }

    pub fn clear_claim_fail_reason(&mut self) {
        self.claim_fail_reason = ::std::option::Option::None;
    }

    pub fn has_claim_fail_reason(&self) -> bool {
        self.claim_fail_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_fail_reason(&mut self, v: permission_grant_description::ClaimFailReason) {
        self.claim_fail_reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_effective = 3;

    pub fn is_effective(&self) -> bool {
        self.is_effective.unwrap_or(false)
    }

    pub fn clear_is_effective(&mut self) {
        self.is_effective = ::std::option::Option::None;
    }

    pub fn has_is_effective(&self) -> bool {
        self.is_effective.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_effective(&mut self, v: bool) {
        self.is_effective = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PermissionGrantOptions>(
            "permission_grant_options",
            |m: &PermissionGrantDescription| { &m.permission_grant_options },
            |m: &mut PermissionGrantDescription| { &mut m.permission_grant_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "claim_fail_reason",
            |m: &PermissionGrantDescription| { &m.claim_fail_reason },
            |m: &mut PermissionGrantDescription| { &mut m.claim_fail_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_effective",
            |m: &PermissionGrantDescription| { &m.is_effective },
            |m: &mut PermissionGrantDescription| { &mut m.is_effective },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &PermissionGrantDescription| { &m.capabilities },
            |m: &mut PermissionGrantDescription| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "details",
            |m: &PermissionGrantDescription| { &m.details },
            |m: &mut PermissionGrantDescription| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionGrantDescription>(
            "PermissionGrantDescription",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionGrantDescription {
    const NAME: &'static str = "PermissionGrantDescription";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permission_grant_options)?;
                },
                16 => {
                    self.claim_fail_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.is_effective = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                42 => {
                    self.details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission_grant_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.claim_fail_reason {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.is_effective {
            my_size += 1 + 1;
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission_grant_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.claim_fail_reason {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_effective {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.details {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionGrantDescription {
        PermissionGrantDescription::new()
    }

    fn clear(&mut self) {
        self.permission_grant_options.clear();
        self.claim_fail_reason = ::std::option::Option::None;
        self.is_effective = ::std::option::Option::None;
        self.capabilities.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionGrantDescription {
        static instance: PermissionGrantDescription = PermissionGrantDescription {
            permission_grant_options: ::protobuf::MessageField::none(),
            claim_fail_reason: ::std::option::Option::None,
            is_effective: ::std::option::Option::None,
            capabilities: ::protobuf::MessageField::none(),
            details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionGrantDescription {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionGrantDescription").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionGrantDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionGrantDescription {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PermissionGrantDescription`
pub mod permission_grant_description {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.playlist_permission.proto.PermissionGrantDescription.ClaimFailReason)
    pub enum ClaimFailReason {
        // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionGrantDescription.ClaimFailReason.CLAIM_FAIL_REASON_UNSPECIFIED)
        CLAIM_FAIL_REASON_UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionGrantDescription.ClaimFailReason.CLAIM_FAIL_REASON_ANONYMOUS)
        CLAIM_FAIL_REASON_ANONYMOUS = 1,
        // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionGrantDescription.ClaimFailReason.CLAIM_FAIL_REASON_NO_GRANT_FOUND)
        CLAIM_FAIL_REASON_NO_GRANT_FOUND = 2,
        // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionGrantDescription.ClaimFailReason.CLAIM_FAIL_REASON_GRANT_EXPIRED)
        CLAIM_FAIL_REASON_GRANT_EXPIRED = 3,
    }

    impl ::protobuf::Enum for ClaimFailReason {
        const NAME: &'static str = "ClaimFailReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ClaimFailReason> {
            match value {
                0 => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_UNSPECIFIED),
                1 => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_ANONYMOUS),
                2 => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_NO_GRANT_FOUND),
                3 => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_GRANT_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ClaimFailReason> {
            match str {
                "CLAIM_FAIL_REASON_UNSPECIFIED" => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_UNSPECIFIED),
                "CLAIM_FAIL_REASON_ANONYMOUS" => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_ANONYMOUS),
                "CLAIM_FAIL_REASON_NO_GRANT_FOUND" => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_NO_GRANT_FOUND),
                "CLAIM_FAIL_REASON_GRANT_EXPIRED" => ::std::option::Option::Some(ClaimFailReason::CLAIM_FAIL_REASON_GRANT_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ClaimFailReason] = &[
            ClaimFailReason::CLAIM_FAIL_REASON_UNSPECIFIED,
            ClaimFailReason::CLAIM_FAIL_REASON_ANONYMOUS,
            ClaimFailReason::CLAIM_FAIL_REASON_NO_GRANT_FOUND,
            ClaimFailReason::CLAIM_FAIL_REASON_GRANT_EXPIRED,
        ];
    }

    impl ::protobuf::EnumFull for ClaimFailReason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PermissionGrantDescription.ClaimFailReason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ClaimFailReason {
        fn default() -> Self {
            ClaimFailReason::CLAIM_FAIL_REASON_UNSPECIFIED
        }
    }

    impl ClaimFailReason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClaimFailReason>("PermissionGrantDescription.ClaimFailReason")
        }
    }
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.ClaimPermissionGrantResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClaimPermissionGrantResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ClaimPermissionGrantResponse.user_permission)
    pub user_permission: ::protobuf::MessageField<Permission>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ClaimPermissionGrantResponse.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ClaimPermissionGrantResponse.details)
    pub details: ::std::vec::Vec<PermissionGrantDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.ClaimPermissionGrantResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClaimPermissionGrantResponse {
    fn default() -> &'a ClaimPermissionGrantResponse {
        <ClaimPermissionGrantResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClaimPermissionGrantResponse {
    pub fn new() -> ClaimPermissionGrantResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permission>(
            "user_permission",
            |m: &ClaimPermissionGrantResponse| { &m.user_permission },
            |m: &mut ClaimPermissionGrantResponse| { &mut m.user_permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &ClaimPermissionGrantResponse| { &m.capabilities },
            |m: &mut ClaimPermissionGrantResponse| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "details",
            |m: &ClaimPermissionGrantResponse| { &m.details },
            |m: &mut ClaimPermissionGrantResponse| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClaimPermissionGrantResponse>(
            "ClaimPermissionGrantResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClaimPermissionGrantResponse {
    const NAME: &'static str = "ClaimPermissionGrantResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_permission)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                26 => {
                    self.details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_permission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.details {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClaimPermissionGrantResponse {
        ClaimPermissionGrantResponse::new()
    }

    fn clear(&mut self) {
        self.user_permission.clear();
        self.capabilities.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClaimPermissionGrantResponse {
        static instance: ClaimPermissionGrantResponse = ClaimPermissionGrantResponse {
            user_permission: ::protobuf::MessageField::none(),
            capabilities: ::protobuf::MessageField::none(),
            details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClaimPermissionGrantResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClaimPermissionGrantResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClaimPermissionGrantResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClaimPermissionGrantResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.ResponseStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseStatus {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ResponseStatus.status_code)
    pub status_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.ResponseStatus.status_message)
    pub status_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.ResponseStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseStatus {
    fn default() -> &'a ResponseStatus {
        <ResponseStatus as ::protobuf::Message>::default_instance()
    }
}

impl ResponseStatus {
    pub fn new() -> ResponseStatus {
        ::std::default::Default::default()
    }

    // optional int32 status_code = 1;

    pub fn status_code(&self) -> i32 {
        self.status_code.unwrap_or(0)
    }

    pub fn clear_status_code(&mut self) {
        self.status_code = ::std::option::Option::None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = ::std::option::Option::Some(v);
    }

    // optional string status_message = 2;

    pub fn status_message(&self) -> &str {
        match self.status_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_message(&mut self) {
        self.status_message = ::std::option::Option::None;
    }

    pub fn has_status_message(&self) -> bool {
        self.status_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_message(&mut self, v: ::std::string::String) {
        self.status_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_message(&mut self) -> &mut ::std::string::String {
        if self.status_message.is_none() {
            self.status_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_message(&mut self) -> ::std::string::String {
        self.status_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_code",
            |m: &ResponseStatus| { &m.status_code },
            |m: &mut ResponseStatus| { &mut m.status_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_message",
            |m: &ResponseStatus| { &m.status_message },
            |m: &mut ResponseStatus| { &mut m.status_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseStatus>(
            "ResponseStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseStatus {
    const NAME: &'static str = "ResponseStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status_code = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.status_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status_code {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.status_message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status_code {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.status_message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseStatus {
        ResponseStatus::new()
    }

    fn clear(&mut self) {
        self.status_code = ::std::option::Option::None;
        self.status_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseStatus {
        static instance: ResponseStatus = ResponseStatus {
            status_code: ::std::option::Option::None,
            status_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionIdentifier)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionIdentifier {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionIdentifier.kind)
    pub kind: ::std::option::Option<::protobuf::EnumOrUnknown<PermissionIdentifierKind>>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionIdentifier.user_id)
    pub user_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionIdentifier.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionIdentifier {
    fn default() -> &'a PermissionIdentifier {
        <PermissionIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl PermissionIdentifier {
    pub fn new() -> PermissionIdentifier {
        ::std::default::Default::default()
    }

    // required .spotify.playlist_permission.proto.PermissionIdentifierKind kind = 1;

    pub fn kind(&self) -> PermissionIdentifierKind {
        match self.kind {
            Some(e) => e.enum_value_or(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_UNSPECIFIED),
            None => PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_UNSPECIFIED,
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: PermissionIdentifierKind) {
        self.kind = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string user_id = 2;

    pub fn user_id(&self) -> &str {
        match self.user_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        if self.user_id.is_none() {
            self.user_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        self.user_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &PermissionIdentifier| { &m.kind },
            |m: &mut PermissionIdentifier| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_id",
            |m: &PermissionIdentifier| { &m.user_id },
            |m: &mut PermissionIdentifier| { &mut m.user_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionIdentifier>(
            "PermissionIdentifier",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionIdentifier {
    const NAME: &'static str = "PermissionIdentifier";

    fn is_initialized(&self) -> bool {
        if self.kind.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kind = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.user_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.user_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.user_id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionIdentifier {
        PermissionIdentifier::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionIdentifier {
        static instance: PermissionIdentifier = PermissionIdentifier {
            kind: ::std::option::Option::None,
            user_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionIdentifier {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionIdentifier").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionIdentifier {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.PermissionEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionEntry {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionEntry.identifier)
    pub identifier: ::protobuf::MessageField<PermissionIdentifier>,
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.PermissionEntry.permission)
    pub permission: ::protobuf::MessageField<Permission>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.PermissionEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionEntry {
    fn default() -> &'a PermissionEntry {
        <PermissionEntry as ::protobuf::Message>::default_instance()
    }
}

impl PermissionEntry {
    pub fn new() -> PermissionEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PermissionIdentifier>(
            "identifier",
            |m: &PermissionEntry| { &m.identifier },
            |m: &mut PermissionEntry| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permission>(
            "permission",
            |m: &PermissionEntry| { &m.permission },
            |m: &mut PermissionEntry| { &mut m.permission },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionEntry>(
            "PermissionEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionEntry {
    const NAME: &'static str = "PermissionEntry";

    fn is_initialized(&self) -> bool {
        for v in &self.identifier {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.identifier)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permission)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identifier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.permission.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionEntry {
        PermissionEntry::new()
    }

    fn clear(&mut self) {
        self.identifier.clear();
        self.permission.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionEntry {
        static instance: PermissionEntry = PermissionEntry {
            identifier: ::protobuf::MessageField::none(),
            permission: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.CreateInitialPermissions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateInitialPermissions {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CreateInitialPermissions.permission_entry)
    pub permission_entry: ::std::vec::Vec<PermissionEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.CreateInitialPermissions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateInitialPermissions {
    fn default() -> &'a CreateInitialPermissions {
        <CreateInitialPermissions as ::protobuf::Message>::default_instance()
    }
}

impl CreateInitialPermissions {
    pub fn new() -> CreateInitialPermissions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "permission_entry",
            |m: &CreateInitialPermissions| { &m.permission_entry },
            |m: &mut CreateInitialPermissions| { &mut m.permission_entry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateInitialPermissions>(
            "CreateInitialPermissions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateInitialPermissions {
    const NAME: &'static str = "CreateInitialPermissions";

    fn is_initialized(&self) -> bool {
        for v in &self.permission_entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.permission_entry.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.permission_entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.permission_entry {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateInitialPermissions {
        CreateInitialPermissions::new()
    }

    fn clear(&mut self) {
        self.permission_entry.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateInitialPermissions {
        static instance: CreateInitialPermissions = CreateInitialPermissions {
            permission_entry: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateInitialPermissions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateInitialPermissions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateInitialPermissions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateInitialPermissions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.CreateInitialPermissionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateInitialPermissionsResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.CreateInitialPermissionsResponse.permission_entry)
    pub permission_entry: ::std::vec::Vec<PermissionEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.CreateInitialPermissionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateInitialPermissionsResponse {
    fn default() -> &'a CreateInitialPermissionsResponse {
        <CreateInitialPermissionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateInitialPermissionsResponse {
    pub fn new() -> CreateInitialPermissionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "permission_entry",
            |m: &CreateInitialPermissionsResponse| { &m.permission_entry },
            |m: &mut CreateInitialPermissionsResponse| { &mut m.permission_entry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateInitialPermissionsResponse>(
            "CreateInitialPermissionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateInitialPermissionsResponse {
    const NAME: &'static str = "CreateInitialPermissionsResponse";

    fn is_initialized(&self) -> bool {
        for v in &self.permission_entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.permission_entry.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.permission_entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.permission_entry {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateInitialPermissionsResponse {
        CreateInitialPermissionsResponse::new()
    }

    fn clear(&mut self) {
        self.permission_entry.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateInitialPermissionsResponse {
        static instance: CreateInitialPermissionsResponse = CreateInitialPermissionsResponse {
            permission_entry: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateInitialPermissionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateInitialPermissionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateInitialPermissionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateInitialPermissionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist_permission.proto.DefaultOwnerCapabilitiesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DefaultOwnerCapabilitiesResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist_permission.proto.DefaultOwnerCapabilitiesResponse.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist_permission.proto.DefaultOwnerCapabilitiesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DefaultOwnerCapabilitiesResponse {
    fn default() -> &'a DefaultOwnerCapabilitiesResponse {
        <DefaultOwnerCapabilitiesResponse as ::protobuf::Message>::default_instance()
    }
}

impl DefaultOwnerCapabilitiesResponse {
    pub fn new() -> DefaultOwnerCapabilitiesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &DefaultOwnerCapabilitiesResponse| { &m.capabilities },
            |m: &mut DefaultOwnerCapabilitiesResponse| { &mut m.capabilities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DefaultOwnerCapabilitiesResponse>(
            "DefaultOwnerCapabilitiesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DefaultOwnerCapabilitiesResponse {
    const NAME: &'static str = "DefaultOwnerCapabilitiesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DefaultOwnerCapabilitiesResponse {
        DefaultOwnerCapabilitiesResponse::new()
    }

    fn clear(&mut self) {
        self.capabilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DefaultOwnerCapabilitiesResponse {
        static instance: DefaultOwnerCapabilitiesResponse = DefaultOwnerCapabilitiesResponse {
            capabilities: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DefaultOwnerCapabilitiesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DefaultOwnerCapabilitiesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DefaultOwnerCapabilitiesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefaultOwnerCapabilitiesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.playlist_permission.proto.PermissionLevel)
pub enum PermissionLevel {
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionLevel.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionLevel.BLOCKED)
    BLOCKED = 1,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionLevel.VIEWER)
    VIEWER = 2,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionLevel.CONTRIBUTOR)
    CONTRIBUTOR = 3,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionLevel.MADE_FOR)
    MADE_FOR = 4,
}

impl ::protobuf::Enum for PermissionLevel {
    const NAME: &'static str = "PermissionLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PermissionLevel> {
        match value {
            0 => ::std::option::Option::Some(PermissionLevel::UNKNOWN),
            1 => ::std::option::Option::Some(PermissionLevel::BLOCKED),
            2 => ::std::option::Option::Some(PermissionLevel::VIEWER),
            3 => ::std::option::Option::Some(PermissionLevel::CONTRIBUTOR),
            4 => ::std::option::Option::Some(PermissionLevel::MADE_FOR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PermissionLevel> {
        match str {
            "UNKNOWN" => ::std::option::Option::Some(PermissionLevel::UNKNOWN),
            "BLOCKED" => ::std::option::Option::Some(PermissionLevel::BLOCKED),
            "VIEWER" => ::std::option::Option::Some(PermissionLevel::VIEWER),
            "CONTRIBUTOR" => ::std::option::Option::Some(PermissionLevel::CONTRIBUTOR),
            "MADE_FOR" => ::std::option::Option::Some(PermissionLevel::MADE_FOR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PermissionLevel] = &[
        PermissionLevel::UNKNOWN,
        PermissionLevel::BLOCKED,
        PermissionLevel::VIEWER,
        PermissionLevel::CONTRIBUTOR,
        PermissionLevel::MADE_FOR,
    ];
}

impl ::protobuf::EnumFull for PermissionLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PermissionLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PermissionLevel {
    fn default() -> Self {
        PermissionLevel::UNKNOWN
    }
}

impl PermissionLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PermissionLevel>("PermissionLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.playlist_permission.proto.PermissionIdentifierKind)
pub enum PermissionIdentifierKind {
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionIdentifierKind.PERMISSION_IDENTIFIER_KIND_UNSPECIFIED)
    PERMISSION_IDENTIFIER_KIND_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionIdentifierKind.PERMISSION_IDENTIFIER_KIND_BASE)
    PERMISSION_IDENTIFIER_KIND_BASE = 1,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionIdentifierKind.PERMISSION_IDENTIFIER_KIND_MEMBER)
    PERMISSION_IDENTIFIER_KIND_MEMBER = 2,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionIdentifierKind.PERMISSION_IDENTIFIER_KIND_ABUSE)
    PERMISSION_IDENTIFIER_KIND_ABUSE = 3,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionIdentifierKind.PERMISSION_IDENTIFIER_KIND_PROFILE)
    PERMISSION_IDENTIFIER_KIND_PROFILE = 4,
    // @@protoc_insertion_point(enum_value:spotify.playlist_permission.proto.PermissionIdentifierKind.PERMISSION_IDENTIFIER_KIND_AUTHORIZED)
    PERMISSION_IDENTIFIER_KIND_AUTHORIZED = 5,
}

impl ::protobuf::Enum for PermissionIdentifierKind {
    const NAME: &'static str = "PermissionIdentifierKind";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PermissionIdentifierKind> {
        match value {
            0 => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_UNSPECIFIED),
            1 => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_BASE),
            2 => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_MEMBER),
            3 => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_ABUSE),
            4 => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_PROFILE),
            5 => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_AUTHORIZED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PermissionIdentifierKind> {
        match str {
            "PERMISSION_IDENTIFIER_KIND_UNSPECIFIED" => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_UNSPECIFIED),
            "PERMISSION_IDENTIFIER_KIND_BASE" => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_BASE),
            "PERMISSION_IDENTIFIER_KIND_MEMBER" => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_MEMBER),
            "PERMISSION_IDENTIFIER_KIND_ABUSE" => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_ABUSE),
            "PERMISSION_IDENTIFIER_KIND_PROFILE" => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_PROFILE),
            "PERMISSION_IDENTIFIER_KIND_AUTHORIZED" => ::std::option::Option::Some(PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_AUTHORIZED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PermissionIdentifierKind] = &[
        PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_UNSPECIFIED,
        PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_BASE,
        PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_MEMBER,
        PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_ABUSE,
        PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_PROFILE,
        PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_AUTHORIZED,
    ];
}

impl ::protobuf::EnumFull for PermissionIdentifierKind {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PermissionIdentifierKind").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PermissionIdentifierKind {
    fn default() -> Self {
        PermissionIdentifierKind::PERMISSION_IDENTIFIER_KIND_UNSPECIFIED
    }
}

impl PermissionIdentifierKind {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PermissionIdentifierKind>("PermissionIdentifierKind")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19playlist_permission.proto\x12!spotify.playlist_permission.proto\"\
    \x87\x01\n\nPermission\x12\x1a\n\x08revision\x18\x01\x20\x01(\x0cR\x08re\
    vision\x12]\n\x10permission_level\x18\x02\x20\x01(\x0e22.spotify.playlis\
    t_permission.proto.PermissionLevelR\x0fpermissionLevel\"\xa5\x01\n\x0fGr\
    antableLevels\x12F\n\x04base\x18\x01\x20\x03(\x0e22.spotify.playlist_per\
    mission.proto.PermissionLevelR\x04base\x12J\n\x06member\x18\x02\x20\x03(\
    \x0e22.spotify.playlist_permission.proto.PermissionLevelR\x06member\"2\n\
    \x15AttributeCapabilities\x12\x19\n\x08can_edit\x18\x01\x20\x01(\x08R\
    \x07canEdit\"\xd0\x04\n\x19ListAttributeCapabilities\x12L\n\x04name\x18\
    \x01\x20\x01(\x0b28.spotify.playlist_permission.proto.AttributeCapabilit\
    iesR\x04name\x12Z\n\x0bdescription\x18\x02\x20\x01(\x0b28.spotify.playli\
    st_permission.proto.AttributeCapabilitiesR\x0bdescription\x12R\n\x07pict\
    ure\x18\x03\x20\x01(\x0b28.spotify.playlist_permission.proto.AttributeCa\
    pabilitiesR\x07picture\x12^\n\rcollaborative\x18\x04\x20\x01(\x0b28.spot\
    ify.playlist_permission.proto.AttributeCapabilitiesR\rcollaborative\x12b\
    \n\x10deleted_by_owner\x18\x06\x20\x01(\x0b28.spotify.playlist_permissio\
    n.proto.AttributeCapabilitiesR\x0edeletedByOwner\x12q\n\x18ai_curation_r\
    eference_id\x18\x0f\x20\x01(\x0b28.spotify.playlist_permission.proto.Att\
    ributeCapabilitiesR\x15aiCurationReferenceId\"\xab\x04\n\x0cCapabilities\
    \x12\x19\n\x08can_view\x18\x01\x20\x01(\x08R\x07canView\x12@\n\x1ccan_ad\
    ministrate_permissions\x18\x02\x20\x01(\x08R\x1acanAdministratePermissio\
    ns\x12[\n\x0fgrantable_level\x18\x03\x20\x03(\x0e22.spotify.playlist_per\
    mission.proto.PermissionLevelR\x0egrantableLevel\x12*\n\x11can_edit_meta\
    data\x18\x04\x20\x01(\x08R\x0fcanEditMetadata\x12$\n\x0ecan_edit_items\
    \x18\x05\x20\x01(\x08R\x0ccanEditItems\x122\n\x15can_cancel_membership\
    \x18\x06\x20\x01(\x08R\x13canCancelMembership\x12]\n\x10grantable_levels\
    \x18\x07\x20\x01(\x0b22.spotify.playlist_permission.proto.GrantableLevel\
    sR\x0fgrantableLevels\x12|\n\x1blist_attribute_capabilities\x18\x08\x20\
    \x01(\x0b2<.spotify.playlist_permission.proto.ListAttributeCapabilitiesR\
    \x19listAttributeCapabilities\"\xe6\x01\n\x18CapabilitiesMultiRequest\
    \x12P\n\x07request\x18\x01\x20\x03(\x0b26.spotify.playlist_permission.pr\
    oto.CapabilitiesRequestR\x07request\x12+\n\x11fallback_username\x18\x02\
    \x20\x01(\tR\x10fallbackUsername\x12(\n\x10fallback_user_id\x18\x03\x20\
    \x01(\tR\x0efallbackUserId\x12!\n\x0cfallback_uri\x18\x04\x20\x01(\tR\
    \x0bfallbackUri\"@\n\x1aCapabilitiesRequestOptions\x12\"\n\rcan_view_onl\
    y\x18\x01\x20\x01(\x08R\x0bcanViewOnly\"\x9e\x02\n\x13CapabilitiesReques\
    t\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\x12\x17\n\x07use\
    r_id\x18\x02\x20\x01(\tR\x06userId\x12\x10\n\x03uri\x18\x03\x20\x01(\tR\
    \x03uri\x12\"\n\ruser_is_owner\x18\x04\x20\x01(\x08R\x0buserIsOwner\x124\
    \n\x16permission_grant_token\x18\x05\x20\x01(\tR\x14permissionGrantToken\
    \x12f\n\x0frequest_options\x18\x06\x20\x01(\x0b2=.spotify.playlist_permi\
    ssion.proto.CapabilitiesRequestOptionsR\x0erequestOptions\"p\n\x19Capabi\
    litiesMultiResponse\x12S\n\x08response\x18\x01\x20\x03(\x0b27.spotify.pl\
    aylist_permission.proto.CapabilitiesResponseR\x08response\"\xb6\x01\n\
    \x14CapabilitiesResponse\x12I\n\x06status\x18\x01\x20\x01(\x0b21.spotify\
    .playlist_permission.proto.ResponseStatusR\x06status\x12S\n\x0ccapabilit\
    ies\x18\x02\x20\x01(\x0b2/.spotify.playlist_permission.proto.Capabilitie\
    sR\x0ccapabilities\"z\n\x19SetPermissionLevelRequest\x12]\n\x10permissio\
    n_level\x18\x01\x20\x01(\x0e22.spotify.playlist_permission.proto.Permiss\
    ionLevelR\x0fpermissionLevel\"y\n\x15SetPermissionResponse\x12`\n\x14res\
    ulting_permission\x18\x01\x20\x01(\x0b2-.spotify.playlist_permission.pro\
    to.PermissionR\x13resultingPermission\"\x9b\x02\n\x1cGetMemberPermission\
    sResponse\x12\x85\x01\n\x12member_permissions\x18\x01\x20\x03(\x0b2V.spo\
    tify.playlist_permission.proto.GetMemberPermissionsResponse.MemberPermis\
    sionsEntryR\x11memberPermissions\x1as\n\x16MemberPermissionsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12C\n\x05value\x18\x02\x20\x01\
    (\x0b2-.spotify.playlist_permission.proto.PermissionR\x05value:\x028\x01\
    \"e\n\x0bPermissions\x12V\n\x0fbase_permission\x18\x01\x20\x01(\x0b2-.sp\
    otify.playlist_permission.proto.PermissionR\x0ebasePermission\"\x82\x02\
    \n\x0fPermissionState\x12P\n\x0bpermissions\x18\x01\x20\x01(\x0b2..spoti\
    fy.playlist_permission.proto.PermissionsR\x0bpermissions\x12S\n\x0ccapab\
    ilities\x18\x02\x20\x01(\x0b2/.spotify.playlist_permission.proto.Capabil\
    itiesR\x0ccapabilities\x12\x1d\n\nis_private\x18\x03\x20\x01(\x08R\tisPr\
    ivate\x12)\n\x10is_collaborative\x18\x04\x20\x01(\x08R\x0fisCollaborativ\
    e\"s\n\x12PermissionStatePub\x12]\n\x10permission_state\x18\x01\x20\x01(\
    \x0b22.spotify.playlist_permission.proto.PermissionStateR\x0fpermissionS\
    tate\"~\n\x16PermissionGrantOptions\x12M\n\npermission\x18\x01\x20\x01(\
    \x0b2-.spotify.playlist_permission.proto.PermissionR\npermission\x12\x15\
    \n\x06ttl_ms\x18\x02\x20\x01(\x03R\x05ttlMs\"\x9c\x01\n\x0fPermissionGra\
    nt\x12\x14\n\x05token\x18\x01\x20\x01(\tR\x05token\x12s\n\x18permission_\
    grant_options\x18\x02\x20\x01(\x0b29.spotify.playlist_permission.proto.P\
    ermissionGrantOptionsR\x16permissionGrantOptions\"X\n\x16PermissionGrant\
    Details\x12>\n\x1bpermission_level_downgraded\x18\x01\x20\x01(\x08R\x19p\
    ermissionLevelDowngraded\"\xfc\x04\n\x1aPermissionGrantDescription\x12s\
    \n\x18permission_grant_options\x18\x01\x20\x01(\x0b29.spotify.playlist_p\
    ermission.proto.PermissionGrantOptionsR\x16permissionGrantOptions\x12y\n\
    \x11claim_fail_reason\x18\x02\x20\x01(\x0e2M.spotify.playlist_permission\
    .proto.PermissionGrantDescription.ClaimFailReasonR\x0fclaimFailReason\
    \x12!\n\x0cis_effective\x18\x03\x20\x01(\x08R\x0bisEffective\x12S\n\x0cc\
    apabilities\x18\x04\x20\x01(\x0b2/.spotify.playlist_permission.proto.Cap\
    abilitiesR\x0ccapabilities\x12S\n\x07details\x18\x05\x20\x03(\x0b29.spot\
    ify.playlist_permission.proto.PermissionGrantDetailsR\x07details\"\xa0\
    \x01\n\x0fClaimFailReason\x12!\n\x1dCLAIM_FAIL_REASON_UNSPECIFIED\x10\0\
    \x12\x1f\n\x1bCLAIM_FAIL_REASON_ANONYMOUS\x10\x01\x12$\n\x20CLAIM_FAIL_R\
    EASON_NO_GRANT_FOUND\x10\x02\x12#\n\x1fCLAIM_FAIL_REASON_GRANT_EXPIRED\
    \x10\x03\"\xa0\x02\n\x1cClaimPermissionGrantResponse\x12V\n\x0fuser_perm\
    ission\x18\x01\x20\x01(\x0b2-.spotify.playlist_permission.proto.Permissi\
    onR\x0euserPermission\x12S\n\x0ccapabilities\x18\x02\x20\x01(\x0b2/.spot\
    ify.playlist_permission.proto.CapabilitiesR\x0ccapabilities\x12S\n\x07de\
    tails\x18\x03\x20\x03(\x0b29.spotify.playlist_permission.proto.Permissio\
    nGrantDetailsR\x07details\"X\n\x0eResponseStatus\x12\x1f\n\x0bstatus_cod\
    e\x18\x01\x20\x01(\x05R\nstatusCode\x12%\n\x0estatus_message\x18\x02\x20\
    \x01(\tR\rstatusMessage\"\x80\x01\n\x14PermissionIdentifier\x12O\n\x04ki\
    nd\x18\x01\x20\x02(\x0e2;.spotify.playlist_permission.proto.PermissionId\
    entifierKindR\x04kind\x12\x17\n\x07user_id\x18\x02\x20\x01(\tR\x06userId\
    \"\xb9\x01\n\x0fPermissionEntry\x12W\n\nidentifier\x18\x01\x20\x01(\x0b2\
    7.spotify.playlist_permission.proto.PermissionIdentifierR\nidentifier\
    \x12M\n\npermission\x18\x02\x20\x01(\x0b2-.spotify.playlist_permission.p\
    roto.PermissionR\npermission\"y\n\x18CreateInitialPermissions\x12]\n\x10\
    permission_entry\x18\x01\x20\x03(\x0b22.spotify.playlist_permission.prot\
    o.PermissionEntryR\x0fpermissionEntry\"\x81\x01\n\x20CreateInitialPermis\
    sionsResponse\x12]\n\x10permission_entry\x18\x01\x20\x03(\x0b22.spotify.\
    playlist_permission.proto.PermissionEntryR\x0fpermissionEntry\"w\n\x20De\
    faultOwnerCapabilitiesResponse\x12S\n\x0ccapabilities\x18\x01\x20\x01(\
    \x0b2/.spotify.playlist_permission.proto.CapabilitiesR\x0ccapabilities*V\
    \n\x0fPermissionLevel\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07BLOCKED\
    \x10\x01\x12\n\n\x06VIEWER\x10\x02\x12\x0f\n\x0bCONTRIBUTOR\x10\x03\x12\
    \x0c\n\x08MADE_FOR\x10\x04*\x8b\x02\n\x18PermissionIdentifierKind\x12*\n\
    &PERMISSION_IDENTIFIER_KIND_UNSPECIFIED\x10\0\x12#\n\x1fPERMISSION_IDENT\
    IFIER_KIND_BASE\x10\x01\x12%\n!PERMISSION_IDENTIFIER_KIND_MEMBER\x10\x02\
    \x12$\n\x20PERMISSION_IDENTIFIER_KIND_ABUSE\x10\x03\x12&\n\"PERMISSION_I\
    DENTIFIER_KIND_PROFILE\x10\x04\x12)\n%PERMISSION_IDENTIFIER_KIND_AUTHORI\
    ZED\x10\x05B\x20\n\x1acom.spotify.playlist.protoP\x01H\x02b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(Permission::generated_message_descriptor_data());
            messages.push(GrantableLevels::generated_message_descriptor_data());
            messages.push(AttributeCapabilities::generated_message_descriptor_data());
            messages.push(ListAttributeCapabilities::generated_message_descriptor_data());
            messages.push(Capabilities::generated_message_descriptor_data());
            messages.push(CapabilitiesMultiRequest::generated_message_descriptor_data());
            messages.push(CapabilitiesRequestOptions::generated_message_descriptor_data());
            messages.push(CapabilitiesRequest::generated_message_descriptor_data());
            messages.push(CapabilitiesMultiResponse::generated_message_descriptor_data());
            messages.push(CapabilitiesResponse::generated_message_descriptor_data());
            messages.push(SetPermissionLevelRequest::generated_message_descriptor_data());
            messages.push(SetPermissionResponse::generated_message_descriptor_data());
            messages.push(GetMemberPermissionsResponse::generated_message_descriptor_data());
            messages.push(Permissions::generated_message_descriptor_data());
            messages.push(PermissionState::generated_message_descriptor_data());
            messages.push(PermissionStatePub::generated_message_descriptor_data());
            messages.push(PermissionGrantOptions::generated_message_descriptor_data());
            messages.push(PermissionGrant::generated_message_descriptor_data());
            messages.push(PermissionGrantDetails::generated_message_descriptor_data());
            messages.push(PermissionGrantDescription::generated_message_descriptor_data());
            messages.push(ClaimPermissionGrantResponse::generated_message_descriptor_data());
            messages.push(ResponseStatus::generated_message_descriptor_data());
            messages.push(PermissionIdentifier::generated_message_descriptor_data());
            messages.push(PermissionEntry::generated_message_descriptor_data());
            messages.push(CreateInitialPermissions::generated_message_descriptor_data());
            messages.push(CreateInitialPermissionsResponse::generated_message_descriptor_data());
            messages.push(DefaultOwnerCapabilitiesResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(PermissionLevel::generated_enum_descriptor_data());
            enums.push(PermissionIdentifierKind::generated_enum_descriptor_data());
            enums.push(permission_grant_description::ClaimFailReason::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
