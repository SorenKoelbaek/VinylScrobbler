// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `metadata.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.metadata.Artist)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Artist {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Artist.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.popularity)
    pub popularity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.top_track)
    pub top_track: ::std::vec::Vec<TopTracks>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.album_group)
    pub album_group: ::std::vec::Vec<AlbumGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.single_group)
    pub single_group: ::std::vec::Vec<AlbumGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.compilation_group)
    pub compilation_group: ::std::vec::Vec<AlbumGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.appears_on_group)
    pub appears_on_group: ::std::vec::Vec<AlbumGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.external_id)
    pub external_id: ::std::vec::Vec<ExternalId>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.portrait)
    pub portrait: ::std::vec::Vec<Image>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.biography)
    pub biography: ::std::vec::Vec<Biography>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.activity_period)
    pub activity_period: ::std::vec::Vec<ActivityPeriod>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.restriction)
    pub restriction: ::std::vec::Vec<Restriction>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.related)
    pub related: ::std::vec::Vec<Artist>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.is_portrait_album_cover)
    pub is_portrait_album_cover: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.portrait_group)
    pub portrait_group: ::protobuf::MessageField<ImageGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.sale_period)
    pub sale_period: ::std::vec::Vec<SalePeriod>,
    // @@protoc_insertion_point(field:spotify.metadata.Artist.availability)
    pub availability: ::std::vec::Vec<Availability>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Artist.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Artist {
    fn default() -> &'a Artist {
        <Artist as ::protobuf::Message>::default_instance()
    }
}

impl Artist {
    pub fn new() -> Artist {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 popularity = 3;

    pub fn popularity(&self) -> i32 {
        self.popularity.unwrap_or(0)
    }

    pub fn clear_popularity(&mut self) {
        self.popularity = ::std::option::Option::None;
    }

    pub fn has_popularity(&self) -> bool {
        self.popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popularity(&mut self, v: i32) {
        self.popularity = ::std::option::Option::Some(v);
    }

    // optional bool is_portrait_album_cover = 16;

    pub fn is_portrait_album_cover(&self) -> bool {
        self.is_portrait_album_cover.unwrap_or(false)
    }

    pub fn clear_is_portrait_album_cover(&mut self) {
        self.is_portrait_album_cover = ::std::option::Option::None;
    }

    pub fn has_is_portrait_album_cover(&self) -> bool {
        self.is_portrait_album_cover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_portrait_album_cover(&mut self, v: bool) {
        self.is_portrait_album_cover = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &Artist| { &m.gid },
            |m: &mut Artist| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Artist| { &m.name },
            |m: &mut Artist| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "popularity",
            |m: &Artist| { &m.popularity },
            |m: &mut Artist| { &mut m.popularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_track",
            |m: &Artist| { &m.top_track },
            |m: &mut Artist| { &mut m.top_track },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "album_group",
            |m: &Artist| { &m.album_group },
            |m: &mut Artist| { &mut m.album_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "single_group",
            |m: &Artist| { &m.single_group },
            |m: &mut Artist| { &mut m.single_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "compilation_group",
            |m: &Artist| { &m.compilation_group },
            |m: &mut Artist| { &mut m.compilation_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appears_on_group",
            |m: &Artist| { &m.appears_on_group },
            |m: &mut Artist| { &mut m.appears_on_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "external_id",
            |m: &Artist| { &m.external_id },
            |m: &mut Artist| { &mut m.external_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "portrait",
            |m: &Artist| { &m.portrait },
            |m: &mut Artist| { &mut m.portrait },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "biography",
            |m: &Artist| { &m.biography },
            |m: &mut Artist| { &mut m.biography },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "activity_period",
            |m: &Artist| { &m.activity_period },
            |m: &mut Artist| { &mut m.activity_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "restriction",
            |m: &Artist| { &m.restriction },
            |m: &mut Artist| { &mut m.restriction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "related",
            |m: &Artist| { &m.related },
            |m: &mut Artist| { &mut m.related },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_portrait_album_cover",
            |m: &Artist| { &m.is_portrait_album_cover },
            |m: &mut Artist| { &mut m.is_portrait_album_cover },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageGroup>(
            "portrait_group",
            |m: &Artist| { &m.portrait_group },
            |m: &mut Artist| { &mut m.portrait_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sale_period",
            |m: &Artist| { &m.sale_period },
            |m: &mut Artist| { &mut m.sale_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "availability",
            |m: &Artist| { &m.availability },
            |m: &mut Artist| { &mut m.availability },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Artist>(
            "Artist",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Artist {
    const NAME: &'static str = "Artist";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.popularity = ::std::option::Option::Some(is.read_sint32()?);
                },
                34 => {
                    self.top_track.push(is.read_message()?);
                },
                42 => {
                    self.album_group.push(is.read_message()?);
                },
                50 => {
                    self.single_group.push(is.read_message()?);
                },
                58 => {
                    self.compilation_group.push(is.read_message()?);
                },
                66 => {
                    self.appears_on_group.push(is.read_message()?);
                },
                82 => {
                    self.external_id.push(is.read_message()?);
                },
                90 => {
                    self.portrait.push(is.read_message()?);
                },
                98 => {
                    self.biography.push(is.read_message()?);
                },
                106 => {
                    self.activity_period.push(is.read_message()?);
                },
                114 => {
                    self.restriction.push(is.read_message()?);
                },
                122 => {
                    self.related.push(is.read_message()?);
                },
                128 => {
                    self.is_portrait_album_cover = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.portrait_group)?;
                },
                146 => {
                    self.sale_period.push(is.read_message()?);
                },
                162 => {
                    self.availability.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.popularity {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        for value in &self.top_track {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.album_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.single_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.compilation_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.appears_on_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.external_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.portrait {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.biography {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.activity_period {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.related {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_portrait_album_cover {
            my_size += 2 + 1;
        }
        if let Some(v) = self.portrait_group.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.sale_period {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.availability {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.popularity {
            os.write_sint32(3, v)?;
        }
        for v in &self.top_track {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.album_group {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.single_group {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.compilation_group {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.appears_on_group {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.external_id {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.portrait {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.biography {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.activity_period {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.restriction {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.related {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.is_portrait_album_cover {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.portrait_group.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        for v in &self.sale_period {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.availability {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Artist {
        Artist::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.popularity = ::std::option::Option::None;
        self.top_track.clear();
        self.album_group.clear();
        self.single_group.clear();
        self.compilation_group.clear();
        self.appears_on_group.clear();
        self.external_id.clear();
        self.portrait.clear();
        self.biography.clear();
        self.activity_period.clear();
        self.restriction.clear();
        self.related.clear();
        self.is_portrait_album_cover = ::std::option::Option::None;
        self.portrait_group.clear();
        self.sale_period.clear();
        self.availability.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Artist {
        static instance: Artist = Artist {
            gid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            popularity: ::std::option::Option::None,
            top_track: ::std::vec::Vec::new(),
            album_group: ::std::vec::Vec::new(),
            single_group: ::std::vec::Vec::new(),
            compilation_group: ::std::vec::Vec::new(),
            appears_on_group: ::std::vec::Vec::new(),
            external_id: ::std::vec::Vec::new(),
            portrait: ::std::vec::Vec::new(),
            biography: ::std::vec::Vec::new(),
            activity_period: ::std::vec::Vec::new(),
            restriction: ::std::vec::Vec::new(),
            related: ::std::vec::Vec::new(),
            is_portrait_album_cover: ::std::option::Option::None,
            portrait_group: ::protobuf::MessageField::none(),
            sale_period: ::std::vec::Vec::new(),
            availability: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Artist {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Artist").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Artist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Artist {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.Album)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Album {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Album.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.artist)
    pub artist: ::std::vec::Vec<Artist>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<album::Type>>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.date)
    pub date: ::protobuf::MessageField<Date>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.popularity)
    pub popularity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.cover)
    pub cover: ::std::vec::Vec<Image>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.external_id)
    pub external_id: ::std::vec::Vec<ExternalId>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.disc)
    pub disc: ::std::vec::Vec<Disc>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.review)
    pub review: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.copyright)
    pub copyright: ::std::vec::Vec<Copyright>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.restriction)
    pub restriction: ::std::vec::Vec<Restriction>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.related)
    pub related: ::std::vec::Vec<Album>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.sale_period)
    pub sale_period: ::std::vec::Vec<SalePeriod>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.cover_group)
    pub cover_group: ::protobuf::MessageField<ImageGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.original_title)
    pub original_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.version_title)
    pub version_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.type_str)
    pub type_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Album.availability)
    pub availability: ::std::vec::Vec<Availability>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Album.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Album {
    fn default() -> &'a Album {
        <Album as ::protobuf::Message>::default_instance()
    }
}

impl Album {
    pub fn new() -> Album {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .spotify.metadata.Album.Type type = 4;

    pub fn type_(&self) -> album::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(album::Type::ALBUM),
            None => album::Type::ALBUM,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: album::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string label = 5;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 popularity = 7;

    pub fn popularity(&self) -> i32 {
        self.popularity.unwrap_or(0)
    }

    pub fn clear_popularity(&mut self) {
        self.popularity = ::std::option::Option::None;
    }

    pub fn has_popularity(&self) -> bool {
        self.popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popularity(&mut self, v: i32) {
        self.popularity = ::std::option::Option::Some(v);
    }

    // optional string original_title = 18;

    pub fn original_title(&self) -> &str {
        match self.original_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_original_title(&mut self) {
        self.original_title = ::std::option::Option::None;
    }

    pub fn has_original_title(&self) -> bool {
        self.original_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_title(&mut self, v: ::std::string::String) {
        self.original_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_title(&mut self) -> &mut ::std::string::String {
        if self.original_title.is_none() {
            self.original_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.original_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_title(&mut self) -> ::std::string::String {
        self.original_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version_title = 19;

    pub fn version_title(&self) -> &str {
        match self.version_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_title(&mut self) {
        self.version_title = ::std::option::Option::None;
    }

    pub fn has_version_title(&self) -> bool {
        self.version_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_title(&mut self, v: ::std::string::String) {
        self.version_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_title(&mut self) -> &mut ::std::string::String {
        if self.version_title.is_none() {
            self.version_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_title(&mut self) -> ::std::string::String {
        self.version_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type_str = 20;

    pub fn type_str(&self) -> &str {
        match self.type_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_str(&mut self) {
        self.type_str = ::std::option::Option::None;
    }

    pub fn has_type_str(&self) -> bool {
        self.type_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_str(&mut self, v: ::std::string::String) {
        self.type_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_str(&mut self) -> &mut ::std::string::String {
        if self.type_str.is_none() {
            self.type_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_str(&mut self) -> ::std::string::String {
        self.type_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &Album| { &m.gid },
            |m: &mut Album| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Album| { &m.name },
            |m: &mut Album| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "artist",
            |m: &Album| { &m.artist },
            |m: &mut Album| { &mut m.artist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Album| { &m.type_ },
            |m: &mut Album| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &Album| { &m.label },
            |m: &mut Album| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Date>(
            "date",
            |m: &Album| { &m.date },
            |m: &mut Album| { &mut m.date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "popularity",
            |m: &Album| { &m.popularity },
            |m: &mut Album| { &mut m.popularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cover",
            |m: &Album| { &m.cover },
            |m: &mut Album| { &mut m.cover },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "external_id",
            |m: &Album| { &m.external_id },
            |m: &mut Album| { &mut m.external_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disc",
            |m: &Album| { &m.disc },
            |m: &mut Album| { &mut m.disc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "review",
            |m: &Album| { &m.review },
            |m: &mut Album| { &mut m.review },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "copyright",
            |m: &Album| { &m.copyright },
            |m: &mut Album| { &mut m.copyright },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "restriction",
            |m: &Album| { &m.restriction },
            |m: &mut Album| { &mut m.restriction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "related",
            |m: &Album| { &m.related },
            |m: &mut Album| { &mut m.related },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sale_period",
            |m: &Album| { &m.sale_period },
            |m: &mut Album| { &mut m.sale_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageGroup>(
            "cover_group",
            |m: &Album| { &m.cover_group },
            |m: &mut Album| { &mut m.cover_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_title",
            |m: &Album| { &m.original_title },
            |m: &mut Album| { &mut m.original_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_title",
            |m: &Album| { &m.version_title },
            |m: &mut Album| { &mut m.version_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_str",
            |m: &Album| { &m.type_str },
            |m: &mut Album| { &mut m.type_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "availability",
            |m: &Album| { &m.availability },
            |m: &mut Album| { &mut m.availability },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Album>(
            "Album",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Album {
    const NAME: &'static str = "Album";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.artist.push(is.read_message()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date)?;
                },
                56 => {
                    self.popularity = ::std::option::Option::Some(is.read_sint32()?);
                },
                74 => {
                    self.cover.push(is.read_message()?);
                },
                82 => {
                    self.external_id.push(is.read_message()?);
                },
                90 => {
                    self.disc.push(is.read_message()?);
                },
                98 => {
                    self.review.push(is.read_string()?);
                },
                106 => {
                    self.copyright.push(is.read_message()?);
                },
                114 => {
                    self.restriction.push(is.read_message()?);
                },
                122 => {
                    self.related.push(is.read_message()?);
                },
                130 => {
                    self.sale_period.push(is.read_message()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cover_group)?;
                },
                146 => {
                    self.original_title = ::std::option::Option::Some(is.read_string()?);
                },
                154 => {
                    self.version_title = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.type_str = ::std::option::Option::Some(is.read_string()?);
                },
                186 => {
                    self.availability.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.artist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.date.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.popularity {
            my_size += ::protobuf::rt::sint32_size(7, v);
        }
        for value in &self.cover {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.external_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.disc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.review {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.copyright {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.related {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sale_period {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cover_group.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.original_title.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.version_title.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.type_str.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        for value in &self.availability {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.artist {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.date.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.popularity {
            os.write_sint32(7, v)?;
        }
        for v in &self.cover {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.external_id {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.disc {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.review {
            os.write_string(12, &v)?;
        };
        for v in &self.copyright {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.restriction {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.related {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.sale_period {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if let Some(v) = self.cover_group.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.original_title.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.version_title.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.type_str.as_ref() {
            os.write_string(20, v)?;
        }
        for v in &self.availability {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Album {
        Album::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.artist.clear();
        self.type_ = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.date.clear();
        self.popularity = ::std::option::Option::None;
        self.cover.clear();
        self.external_id.clear();
        self.disc.clear();
        self.review.clear();
        self.copyright.clear();
        self.restriction.clear();
        self.related.clear();
        self.sale_period.clear();
        self.cover_group.clear();
        self.original_title = ::std::option::Option::None;
        self.version_title = ::std::option::Option::None;
        self.type_str = ::std::option::Option::None;
        self.availability.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Album {
        static instance: Album = Album {
            gid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            artist: ::std::vec::Vec::new(),
            type_: ::std::option::Option::None,
            label: ::std::option::Option::None,
            date: ::protobuf::MessageField::none(),
            popularity: ::std::option::Option::None,
            cover: ::std::vec::Vec::new(),
            external_id: ::std::vec::Vec::new(),
            disc: ::std::vec::Vec::new(),
            review: ::std::vec::Vec::new(),
            copyright: ::std::vec::Vec::new(),
            restriction: ::std::vec::Vec::new(),
            related: ::std::vec::Vec::new(),
            sale_period: ::std::vec::Vec::new(),
            cover_group: ::protobuf::MessageField::none(),
            original_title: ::std::option::Option::None,
            version_title: ::std::option::Option::None,
            type_str: ::std::option::Option::None,
            availability: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Album {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Album").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Album {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Album {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Album`
pub mod album {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Album.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Album.Type.ALBUM)
        ALBUM = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Album.Type.SINGLE)
        SINGLE = 2,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Album.Type.COMPILATION)
        COMPILATION = 3,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Album.Type.EP)
        EP = 4,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Album.Type.AUDIOBOOK)
        AUDIOBOOK = 5,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Album.Type.PODCAST)
        PODCAST = 6,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::ALBUM),
                2 => ::std::option::Option::Some(Type::SINGLE),
                3 => ::std::option::Option::Some(Type::COMPILATION),
                4 => ::std::option::Option::Some(Type::EP),
                5 => ::std::option::Option::Some(Type::AUDIOBOOK),
                6 => ::std::option::Option::Some(Type::PODCAST),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "ALBUM" => ::std::option::Option::Some(Type::ALBUM),
                "SINGLE" => ::std::option::Option::Some(Type::SINGLE),
                "COMPILATION" => ::std::option::Option::Some(Type::COMPILATION),
                "EP" => ::std::option::Option::Some(Type::EP),
                "AUDIOBOOK" => ::std::option::Option::Some(Type::AUDIOBOOK),
                "PODCAST" => ::std::option::Option::Some(Type::PODCAST),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::ALBUM,
            Type::SINGLE,
            Type::COMPILATION,
            Type::EP,
            Type::AUDIOBOOK,
            Type::PODCAST,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Album.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::ALBUM => 0,
                Type::SINGLE => 1,
                Type::COMPILATION => 2,
                Type::EP => 3,
                Type::AUDIOBOOK => 4,
                Type::PODCAST => 5,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::ALBUM
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("Album.Type")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.Track)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Track {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Track.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.album)
    pub album: ::protobuf::MessageField<Album>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.artist)
    pub artist: ::std::vec::Vec<Artist>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.disc_number)
    pub disc_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.popularity)
    pub popularity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.explicit)
    pub explicit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.external_id)
    pub external_id: ::std::vec::Vec<ExternalId>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.restriction)
    pub restriction: ::std::vec::Vec<Restriction>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.file)
    pub file: ::std::vec::Vec<AudioFile>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.alternative)
    pub alternative: ::std::vec::Vec<Track>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.sale_period)
    pub sale_period: ::std::vec::Vec<SalePeriod>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.preview)
    pub preview: ::std::vec::Vec<AudioFile>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.earliest_live_timestamp)
    pub earliest_live_timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.has_lyrics)
    pub has_lyrics: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.availability)
    pub availability: ::std::vec::Vec<Availability>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.licensor)
    pub licensor: ::protobuf::MessageField<Licensor>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.language_of_performance)
    pub language_of_performance: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.original_audio)
    pub original_audio: ::protobuf::MessageField<Audio>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.content_rating)
    pub content_rating: ::std::vec::Vec<ContentRating>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.original_title)
    pub original_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.version_title)
    pub version_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.artist_with_role)
    pub artist_with_role: ::std::vec::Vec<ArtistWithRole>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.canonical_uri)
    pub canonical_uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Track.original_video)
    pub original_video: ::std::vec::Vec<Video>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Track.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Track {
    fn default() -> &'a Track {
        <Track as ::protobuf::Message>::default_instance()
    }
}

impl Track {
    pub fn new() -> Track {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 number = 5;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional sint32 disc_number = 6;

    pub fn disc_number(&self) -> i32 {
        self.disc_number.unwrap_or(0)
    }

    pub fn clear_disc_number(&mut self) {
        self.disc_number = ::std::option::Option::None;
    }

    pub fn has_disc_number(&self) -> bool {
        self.disc_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disc_number(&mut self, v: i32) {
        self.disc_number = ::std::option::Option::Some(v);
    }

    // optional sint32 duration = 7;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional sint32 popularity = 8;

    pub fn popularity(&self) -> i32 {
        self.popularity.unwrap_or(0)
    }

    pub fn clear_popularity(&mut self) {
        self.popularity = ::std::option::Option::None;
    }

    pub fn has_popularity(&self) -> bool {
        self.popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popularity(&mut self, v: i32) {
        self.popularity = ::std::option::Option::Some(v);
    }

    // optional bool explicit = 9;

    pub fn explicit(&self) -> bool {
        self.explicit.unwrap_or(false)
    }

    pub fn clear_explicit(&mut self) {
        self.explicit = ::std::option::Option::None;
    }

    pub fn has_explicit(&self) -> bool {
        self.explicit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit(&mut self, v: bool) {
        self.explicit = ::std::option::Option::Some(v);
    }

    // optional int64 earliest_live_timestamp = 17;

    pub fn earliest_live_timestamp(&self) -> i64 {
        self.earliest_live_timestamp.unwrap_or(0)
    }

    pub fn clear_earliest_live_timestamp(&mut self) {
        self.earliest_live_timestamp = ::std::option::Option::None;
    }

    pub fn has_earliest_live_timestamp(&self) -> bool {
        self.earliest_live_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_earliest_live_timestamp(&mut self, v: i64) {
        self.earliest_live_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool has_lyrics = 18;

    pub fn has_lyrics(&self) -> bool {
        self.has_lyrics.unwrap_or(false)
    }

    pub fn clear_has_lyrics(&mut self) {
        self.has_lyrics = ::std::option::Option::None;
    }

    pub fn has_has_lyrics(&self) -> bool {
        self.has_lyrics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_lyrics(&mut self, v: bool) {
        self.has_lyrics = ::std::option::Option::Some(v);
    }

    // optional string original_title = 27;

    pub fn original_title(&self) -> &str {
        match self.original_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_original_title(&mut self) {
        self.original_title = ::std::option::Option::None;
    }

    pub fn has_original_title(&self) -> bool {
        self.original_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_title(&mut self, v: ::std::string::String) {
        self.original_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_title(&mut self) -> &mut ::std::string::String {
        if self.original_title.is_none() {
            self.original_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.original_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_title(&mut self) -> ::std::string::String {
        self.original_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version_title = 28;

    pub fn version_title(&self) -> &str {
        match self.version_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_title(&mut self) {
        self.version_title = ::std::option::Option::None;
    }

    pub fn has_version_title(&self) -> bool {
        self.version_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_title(&mut self, v: ::std::string::String) {
        self.version_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_title(&mut self) -> &mut ::std::string::String {
        if self.version_title.is_none() {
            self.version_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_title(&mut self) -> ::std::string::String {
        self.version_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string canonical_uri = 36;

    pub fn canonical_uri(&self) -> &str {
        match self.canonical_uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_canonical_uri(&mut self) {
        self.canonical_uri = ::std::option::Option::None;
    }

    pub fn has_canonical_uri(&self) -> bool {
        self.canonical_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonical_uri(&mut self, v: ::std::string::String) {
        self.canonical_uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonical_uri(&mut self) -> &mut ::std::string::String {
        if self.canonical_uri.is_none() {
            self.canonical_uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.canonical_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonical_uri(&mut self) -> ::std::string::String {
        self.canonical_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &Track| { &m.gid },
            |m: &mut Track| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Track| { &m.name },
            |m: &mut Track| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Album>(
            "album",
            |m: &Track| { &m.album },
            |m: &mut Track| { &mut m.album },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "artist",
            |m: &Track| { &m.artist },
            |m: &mut Track| { &mut m.artist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &Track| { &m.number },
            |m: &mut Track| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disc_number",
            |m: &Track| { &m.disc_number },
            |m: &mut Track| { &mut m.disc_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &Track| { &m.duration },
            |m: &mut Track| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "popularity",
            |m: &Track| { &m.popularity },
            |m: &mut Track| { &mut m.popularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explicit",
            |m: &Track| { &m.explicit },
            |m: &mut Track| { &mut m.explicit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "external_id",
            |m: &Track| { &m.external_id },
            |m: &mut Track| { &mut m.external_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "restriction",
            |m: &Track| { &m.restriction },
            |m: &mut Track| { &mut m.restriction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &Track| { &m.file },
            |m: &mut Track| { &mut m.file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alternative",
            |m: &Track| { &m.alternative },
            |m: &mut Track| { &mut m.alternative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sale_period",
            |m: &Track| { &m.sale_period },
            |m: &mut Track| { &mut m.sale_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preview",
            |m: &Track| { &m.preview },
            |m: &mut Track| { &mut m.preview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &Track| { &m.tags },
            |m: &mut Track| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "earliest_live_timestamp",
            |m: &Track| { &m.earliest_live_timestamp },
            |m: &mut Track| { &mut m.earliest_live_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_lyrics",
            |m: &Track| { &m.has_lyrics },
            |m: &mut Track| { &mut m.has_lyrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "availability",
            |m: &Track| { &m.availability },
            |m: &mut Track| { &mut m.availability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Licensor>(
            "licensor",
            |m: &Track| { &m.licensor },
            |m: &mut Track| { &mut m.licensor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "language_of_performance",
            |m: &Track| { &m.language_of_performance },
            |m: &mut Track| { &mut m.language_of_performance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Audio>(
            "original_audio",
            |m: &Track| { &m.original_audio },
            |m: &mut Track| { &mut m.original_audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_rating",
            |m: &Track| { &m.content_rating },
            |m: &mut Track| { &mut m.content_rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_title",
            |m: &Track| { &m.original_title },
            |m: &mut Track| { &mut m.original_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version_title",
            |m: &Track| { &m.version_title },
            |m: &mut Track| { &mut m.version_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "artist_with_role",
            |m: &Track| { &m.artist_with_role },
            |m: &mut Track| { &mut m.artist_with_role },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "canonical_uri",
            |m: &Track| { &m.canonical_uri },
            |m: &mut Track| { &mut m.canonical_uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "original_video",
            |m: &Track| { &m.original_video },
            |m: &mut Track| { &mut m.original_video },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Track>(
            "Track",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Track {
    const NAME: &'static str = "Track";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.album)?;
                },
                34 => {
                    self.artist.push(is.read_message()?);
                },
                40 => {
                    self.number = ::std::option::Option::Some(is.read_sint32()?);
                },
                48 => {
                    self.disc_number = ::std::option::Option::Some(is.read_sint32()?);
                },
                56 => {
                    self.duration = ::std::option::Option::Some(is.read_sint32()?);
                },
                64 => {
                    self.popularity = ::std::option::Option::Some(is.read_sint32()?);
                },
                72 => {
                    self.explicit = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.external_id.push(is.read_message()?);
                },
                90 => {
                    self.restriction.push(is.read_message()?);
                },
                98 => {
                    self.file.push(is.read_message()?);
                },
                106 => {
                    self.alternative.push(is.read_message()?);
                },
                114 => {
                    self.sale_period.push(is.read_message()?);
                },
                122 => {
                    self.preview.push(is.read_message()?);
                },
                130 => {
                    self.tags.push(is.read_string()?);
                },
                136 => {
                    self.earliest_live_timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                144 => {
                    self.has_lyrics = ::std::option::Option::Some(is.read_bool()?);
                },
                154 => {
                    self.availability.push(is.read_message()?);
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.licensor)?;
                },
                178 => {
                    self.language_of_performance.push(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.original_audio)?;
                },
                202 => {
                    self.content_rating.push(is.read_message()?);
                },
                218 => {
                    self.original_title = ::std::option::Option::Some(is.read_string()?);
                },
                226 => {
                    self.version_title = ::std::option::Option::Some(is.read_string()?);
                },
                258 => {
                    self.artist_with_role.push(is.read_message()?);
                },
                290 => {
                    self.canonical_uri = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    self.original_video.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.album.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.artist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::sint32_size(5, v);
        }
        if let Some(v) = self.disc_number {
            my_size += ::protobuf::rt::sint32_size(6, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::sint32_size(7, v);
        }
        if let Some(v) = self.popularity {
            my_size += ::protobuf::rt::sint32_size(8, v);
        }
        if let Some(v) = self.explicit {
            my_size += 1 + 1;
        }
        for value in &self.external_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.alternative {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sale_period {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.preview {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        if let Some(v) = self.earliest_live_timestamp {
            my_size += ::protobuf::rt::int64_size(17, v);
        }
        if let Some(v) = self.has_lyrics {
            my_size += 2 + 1;
        }
        for value in &self.availability {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.licensor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.language_of_performance {
            my_size += ::protobuf::rt::string_size(22, &value);
        };
        if let Some(v) = self.original_audio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.content_rating {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.original_title.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.version_title.as_ref() {
            my_size += ::protobuf::rt::string_size(28, &v);
        }
        for value in &self.artist_with_role {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.canonical_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(36, &v);
        }
        for value in &self.original_video {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.album.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.artist {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.number {
            os.write_sint32(5, v)?;
        }
        if let Some(v) = self.disc_number {
            os.write_sint32(6, v)?;
        }
        if let Some(v) = self.duration {
            os.write_sint32(7, v)?;
        }
        if let Some(v) = self.popularity {
            os.write_sint32(8, v)?;
        }
        if let Some(v) = self.explicit {
            os.write_bool(9, v)?;
        }
        for v in &self.external_id {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.restriction {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.file {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.alternative {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.sale_period {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.preview {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.tags {
            os.write_string(16, &v)?;
        };
        if let Some(v) = self.earliest_live_timestamp {
            os.write_int64(17, v)?;
        }
        if let Some(v) = self.has_lyrics {
            os.write_bool(18, v)?;
        }
        for v in &self.availability {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if let Some(v) = self.licensor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        for v in &self.language_of_performance {
            os.write_string(22, &v)?;
        };
        if let Some(v) = self.original_audio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        for v in &self.content_rating {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        if let Some(v) = self.original_title.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.version_title.as_ref() {
            os.write_string(28, v)?;
        }
        for v in &self.artist_with_role {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        };
        if let Some(v) = self.canonical_uri.as_ref() {
            os.write_string(36, v)?;
        }
        for v in &self.original_video {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Track {
        Track::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.album.clear();
        self.artist.clear();
        self.number = ::std::option::Option::None;
        self.disc_number = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.popularity = ::std::option::Option::None;
        self.explicit = ::std::option::Option::None;
        self.external_id.clear();
        self.restriction.clear();
        self.file.clear();
        self.alternative.clear();
        self.sale_period.clear();
        self.preview.clear();
        self.tags.clear();
        self.earliest_live_timestamp = ::std::option::Option::None;
        self.has_lyrics = ::std::option::Option::None;
        self.availability.clear();
        self.licensor.clear();
        self.language_of_performance.clear();
        self.original_audio.clear();
        self.content_rating.clear();
        self.original_title = ::std::option::Option::None;
        self.version_title = ::std::option::Option::None;
        self.artist_with_role.clear();
        self.canonical_uri = ::std::option::Option::None;
        self.original_video.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Track {
        static instance: Track = Track {
            gid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            album: ::protobuf::MessageField::none(),
            artist: ::std::vec::Vec::new(),
            number: ::std::option::Option::None,
            disc_number: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            popularity: ::std::option::Option::None,
            explicit: ::std::option::Option::None,
            external_id: ::std::vec::Vec::new(),
            restriction: ::std::vec::Vec::new(),
            file: ::std::vec::Vec::new(),
            alternative: ::std::vec::Vec::new(),
            sale_period: ::std::vec::Vec::new(),
            preview: ::std::vec::Vec::new(),
            tags: ::std::vec::Vec::new(),
            earliest_live_timestamp: ::std::option::Option::None,
            has_lyrics: ::std::option::Option::None,
            availability: ::std::vec::Vec::new(),
            licensor: ::protobuf::MessageField::none(),
            language_of_performance: ::std::vec::Vec::new(),
            original_audio: ::protobuf::MessageField::none(),
            content_rating: ::std::vec::Vec::new(),
            original_title: ::std::option::Option::None,
            version_title: ::std::option::Option::None,
            artist_with_role: ::std::vec::Vec::new(),
            canonical_uri: ::std::option::Option::None,
            original_video: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Track {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Track").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Track {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Track {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.ArtistWithRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ArtistWithRole {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.ArtistWithRole.artist_gid)
    pub artist_gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.ArtistWithRole.artist_name)
    pub artist_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.ArtistWithRole.role)
    pub role: ::std::option::Option<::protobuf::EnumOrUnknown<artist_with_role::ArtistRole>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.ArtistWithRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtistWithRole {
    fn default() -> &'a ArtistWithRole {
        <ArtistWithRole as ::protobuf::Message>::default_instance()
    }
}

impl ArtistWithRole {
    pub fn new() -> ArtistWithRole {
        ::std::default::Default::default()
    }

    // optional bytes artist_gid = 1;

    pub fn artist_gid(&self) -> &[u8] {
        match self.artist_gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_artist_gid(&mut self) {
        self.artist_gid = ::std::option::Option::None;
    }

    pub fn has_artist_gid(&self) -> bool {
        self.artist_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artist_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.artist_gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artist_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.artist_gid.is_none() {
            self.artist_gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.artist_gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_artist_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.artist_gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string artist_name = 2;

    pub fn artist_name(&self) -> &str {
        match self.artist_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_artist_name(&mut self) {
        self.artist_name = ::std::option::Option::None;
    }

    pub fn has_artist_name(&self) -> bool {
        self.artist_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_artist_name(&mut self, v: ::std::string::String) {
        self.artist_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artist_name(&mut self) -> &mut ::std::string::String {
        if self.artist_name.is_none() {
            self.artist_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.artist_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_artist_name(&mut self) -> ::std::string::String {
        self.artist_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .spotify.metadata.ArtistWithRole.ArtistRole role = 3;

    pub fn role(&self) -> artist_with_role::ArtistRole {
        match self.role {
            Some(e) => e.enum_value_or(artist_with_role::ArtistRole::ARTIST_ROLE_UNKNOWN),
            None => artist_with_role::ArtistRole::ARTIST_ROLE_UNKNOWN,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: artist_with_role::ArtistRole) {
        self.role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "artist_gid",
            |m: &ArtistWithRole| { &m.artist_gid },
            |m: &mut ArtistWithRole| { &mut m.artist_gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "artist_name",
            |m: &ArtistWithRole| { &m.artist_name },
            |m: &mut ArtistWithRole| { &mut m.artist_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &ArtistWithRole| { &m.role },
            |m: &mut ArtistWithRole| { &mut m.role },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtistWithRole>(
            "ArtistWithRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtistWithRole {
    const NAME: &'static str = "ArtistWithRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.artist_gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.artist_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.artist_gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.artist_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.artist_gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.artist_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtistWithRole {
        ArtistWithRole::new()
    }

    fn clear(&mut self) {
        self.artist_gid = ::std::option::Option::None;
        self.artist_name = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtistWithRole {
        static instance: ArtistWithRole = ArtistWithRole {
            artist_gid: ::std::option::Option::None,
            artist_name: ::std::option::Option::None,
            role: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtistWithRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtistWithRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtistWithRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtistWithRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ArtistWithRole`
pub mod artist_with_role {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.ArtistWithRole.ArtistRole)
    pub enum ArtistRole {
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_UNKNOWN)
        ARTIST_ROLE_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_MAIN_ARTIST)
        ARTIST_ROLE_MAIN_ARTIST = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_FEATURED_ARTIST)
        ARTIST_ROLE_FEATURED_ARTIST = 2,
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_REMIXER)
        ARTIST_ROLE_REMIXER = 3,
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_ACTOR)
        ARTIST_ROLE_ACTOR = 4,
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_COMPOSER)
        ARTIST_ROLE_COMPOSER = 5,
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_CONDUCTOR)
        ARTIST_ROLE_CONDUCTOR = 6,
        // @@protoc_insertion_point(enum_value:spotify.metadata.ArtistWithRole.ArtistRole.ARTIST_ROLE_ORCHESTRA)
        ARTIST_ROLE_ORCHESTRA = 7,
    }

    impl ::protobuf::Enum for ArtistRole {
        const NAME: &'static str = "ArtistRole";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ArtistRole> {
            match value {
                0 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_UNKNOWN),
                1 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_MAIN_ARTIST),
                2 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_FEATURED_ARTIST),
                3 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_REMIXER),
                4 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_ACTOR),
                5 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_COMPOSER),
                6 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_CONDUCTOR),
                7 => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_ORCHESTRA),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ArtistRole> {
            match str {
                "ARTIST_ROLE_UNKNOWN" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_UNKNOWN),
                "ARTIST_ROLE_MAIN_ARTIST" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_MAIN_ARTIST),
                "ARTIST_ROLE_FEATURED_ARTIST" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_FEATURED_ARTIST),
                "ARTIST_ROLE_REMIXER" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_REMIXER),
                "ARTIST_ROLE_ACTOR" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_ACTOR),
                "ARTIST_ROLE_COMPOSER" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_COMPOSER),
                "ARTIST_ROLE_CONDUCTOR" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_CONDUCTOR),
                "ARTIST_ROLE_ORCHESTRA" => ::std::option::Option::Some(ArtistRole::ARTIST_ROLE_ORCHESTRA),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ArtistRole] = &[
            ArtistRole::ARTIST_ROLE_UNKNOWN,
            ArtistRole::ARTIST_ROLE_MAIN_ARTIST,
            ArtistRole::ARTIST_ROLE_FEATURED_ARTIST,
            ArtistRole::ARTIST_ROLE_REMIXER,
            ArtistRole::ARTIST_ROLE_ACTOR,
            ArtistRole::ARTIST_ROLE_COMPOSER,
            ArtistRole::ARTIST_ROLE_CONDUCTOR,
            ArtistRole::ARTIST_ROLE_ORCHESTRA,
        ];
    }

    impl ::protobuf::EnumFull for ArtistRole {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ArtistWithRole.ArtistRole").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ArtistRole {
        fn default() -> Self {
            ArtistRole::ARTIST_ROLE_UNKNOWN
        }
    }

    impl ArtistRole {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ArtistRole>("ArtistWithRole.ArtistRole")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.Show)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Show {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Show.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.deprecated_popularity)
    pub deprecated_popularity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.publisher)
    pub publisher: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.explicit)
    pub explicit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.cover_image)
    pub cover_image: ::protobuf::MessageField<ImageGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.episode)
    pub episode: ::std::vec::Vec<Episode>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.copyright)
    pub copyright: ::std::vec::Vec<Copyright>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.restriction)
    pub restriction: ::std::vec::Vec<Restriction>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.keyword)
    pub keyword: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.media_type)
    pub media_type: ::std::option::Option<::protobuf::EnumOrUnknown<show::MediaType>>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.consumption_order)
    pub consumption_order: ::std::option::Option<::protobuf::EnumOrUnknown<show::ConsumptionOrder>>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.availability)
    pub availability: ::std::vec::Vec<Availability>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.trailer_uri)
    pub trailer_uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.music_and_talk)
    pub music_and_talk: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.is_audiobook)
    pub is_audiobook: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Show.is_creator_channel)
    pub is_creator_channel: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Show.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Show {
    fn default() -> &'a Show {
        <Show as ::protobuf::Message>::default_instance()
    }
}

impl Show {
    pub fn new() -> Show {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 64;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 deprecated_popularity = 65;

    pub fn deprecated_popularity(&self) -> i32 {
        self.deprecated_popularity.unwrap_or(0)
    }

    pub fn clear_deprecated_popularity(&mut self) {
        self.deprecated_popularity = ::std::option::Option::None;
    }

    pub fn has_deprecated_popularity(&self) -> bool {
        self.deprecated_popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_popularity(&mut self, v: i32) {
        self.deprecated_popularity = ::std::option::Option::Some(v);
    }

    // optional string publisher = 66;

    pub fn publisher(&self) -> &str {
        match self.publisher.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_publisher(&mut self) {
        self.publisher = ::std::option::Option::None;
    }

    pub fn has_publisher(&self) -> bool {
        self.publisher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher(&mut self, v: ::std::string::String) {
        self.publisher = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publisher(&mut self) -> &mut ::std::string::String {
        if self.publisher.is_none() {
            self.publisher = ::std::option::Option::Some(::std::string::String::new());
        }
        self.publisher.as_mut().unwrap()
    }

    // Take field
    pub fn take_publisher(&mut self) -> ::std::string::String {
        self.publisher.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 67;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool explicit = 68;

    pub fn explicit(&self) -> bool {
        self.explicit.unwrap_or(false)
    }

    pub fn clear_explicit(&mut self) {
        self.explicit = ::std::option::Option::None;
    }

    pub fn has_explicit(&self) -> bool {
        self.explicit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit(&mut self, v: bool) {
        self.explicit = ::std::option::Option::Some(v);
    }

    // optional .spotify.metadata.Show.MediaType media_type = 74;

    pub fn media_type(&self) -> show::MediaType {
        match self.media_type {
            Some(e) => e.enum_value_or(show::MediaType::MIXED),
            None => show::MediaType::MIXED,
        }
    }

    pub fn clear_media_type(&mut self) {
        self.media_type = ::std::option::Option::None;
    }

    pub fn has_media_type(&self) -> bool {
        self.media_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media_type(&mut self, v: show::MediaType) {
        self.media_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .spotify.metadata.Show.ConsumptionOrder consumption_order = 75;

    pub fn consumption_order(&self) -> show::ConsumptionOrder {
        match self.consumption_order {
            Some(e) => e.enum_value_or(show::ConsumptionOrder::SEQUENTIAL),
            None => show::ConsumptionOrder::SEQUENTIAL,
        }
    }

    pub fn clear_consumption_order(&mut self) {
        self.consumption_order = ::std::option::Option::None;
    }

    pub fn has_consumption_order(&self) -> bool {
        self.consumption_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumption_order(&mut self, v: show::ConsumptionOrder) {
        self.consumption_order = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string trailer_uri = 83;

    pub fn trailer_uri(&self) -> &str {
        match self.trailer_uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_trailer_uri(&mut self) {
        self.trailer_uri = ::std::option::Option::None;
    }

    pub fn has_trailer_uri(&self) -> bool {
        self.trailer_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailer_uri(&mut self, v: ::std::string::String) {
        self.trailer_uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trailer_uri(&mut self) -> &mut ::std::string::String {
        if self.trailer_uri.is_none() {
            self.trailer_uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.trailer_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_trailer_uri(&mut self) -> ::std::string::String {
        self.trailer_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool music_and_talk = 85;

    pub fn music_and_talk(&self) -> bool {
        self.music_and_talk.unwrap_or(false)
    }

    pub fn clear_music_and_talk(&mut self) {
        self.music_and_talk = ::std::option::Option::None;
    }

    pub fn has_music_and_talk(&self) -> bool {
        self.music_and_talk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_and_talk(&mut self, v: bool) {
        self.music_and_talk = ::std::option::Option::Some(v);
    }

    // optional bool is_audiobook = 89;

    pub fn is_audiobook(&self) -> bool {
        self.is_audiobook.unwrap_or(false)
    }

    pub fn clear_is_audiobook(&mut self) {
        self.is_audiobook = ::std::option::Option::None;
    }

    pub fn has_is_audiobook(&self) -> bool {
        self.is_audiobook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_audiobook(&mut self, v: bool) {
        self.is_audiobook = ::std::option::Option::Some(v);
    }

    // optional bool is_creator_channel = 90;

    pub fn is_creator_channel(&self) -> bool {
        self.is_creator_channel.unwrap_or(false)
    }

    pub fn clear_is_creator_channel(&mut self) {
        self.is_creator_channel = ::std::option::Option::None;
    }

    pub fn has_is_creator_channel(&self) -> bool {
        self.is_creator_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_creator_channel(&mut self, v: bool) {
        self.is_creator_channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &Show| { &m.gid },
            |m: &mut Show| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Show| { &m.name },
            |m: &mut Show| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &Show| { &m.description },
            |m: &mut Show| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_popularity",
            |m: &Show| { &m.deprecated_popularity },
            |m: &mut Show| { &mut m.deprecated_popularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "publisher",
            |m: &Show| { &m.publisher },
            |m: &mut Show| { &mut m.publisher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &Show| { &m.language },
            |m: &mut Show| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explicit",
            |m: &Show| { &m.explicit },
            |m: &mut Show| { &mut m.explicit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageGroup>(
            "cover_image",
            |m: &Show| { &m.cover_image },
            |m: &mut Show| { &mut m.cover_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "episode",
            |m: &Show| { &m.episode },
            |m: &mut Show| { &mut m.episode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "copyright",
            |m: &Show| { &m.copyright },
            |m: &mut Show| { &mut m.copyright },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "restriction",
            |m: &Show| { &m.restriction },
            |m: &mut Show| { &mut m.restriction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keyword",
            |m: &Show| { &m.keyword },
            |m: &mut Show| { &mut m.keyword },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "media_type",
            |m: &Show| { &m.media_type },
            |m: &mut Show| { &mut m.media_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "consumption_order",
            |m: &Show| { &m.consumption_order },
            |m: &mut Show| { &mut m.consumption_order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "availability",
            |m: &Show| { &m.availability },
            |m: &mut Show| { &mut m.availability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trailer_uri",
            |m: &Show| { &m.trailer_uri },
            |m: &mut Show| { &mut m.trailer_uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_and_talk",
            |m: &Show| { &m.music_and_talk },
            |m: &mut Show| { &mut m.music_and_talk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_audiobook",
            |m: &Show| { &m.is_audiobook },
            |m: &mut Show| { &mut m.is_audiobook },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_creator_channel",
            |m: &Show| { &m.is_creator_channel },
            |m: &mut Show| { &mut m.is_creator_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Show>(
            "Show",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Show {
    const NAME: &'static str = "Show";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                514 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                520 => {
                    self.deprecated_popularity = ::std::option::Option::Some(is.read_sint32()?);
                },
                530 => {
                    self.publisher = ::std::option::Option::Some(is.read_string()?);
                },
                538 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                544 => {
                    self.explicit = ::std::option::Option::Some(is.read_bool()?);
                },
                554 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cover_image)?;
                },
                562 => {
                    self.episode.push(is.read_message()?);
                },
                570 => {
                    self.copyright.push(is.read_message()?);
                },
                578 => {
                    self.restriction.push(is.read_message()?);
                },
                586 => {
                    self.keyword.push(is.read_string()?);
                },
                592 => {
                    self.media_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                600 => {
                    self.consumption_order = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                626 => {
                    self.availability.push(is.read_message()?);
                },
                666 => {
                    self.trailer_uri = ::std::option::Option::Some(is.read_string()?);
                },
                680 => {
                    self.music_and_talk = ::std::option::Option::Some(is.read_bool()?);
                },
                712 => {
                    self.is_audiobook = ::std::option::Option::Some(is.read_bool()?);
                },
                720 => {
                    self.is_creator_channel = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(64, &v);
        }
        if let Some(v) = self.deprecated_popularity {
            my_size += ::protobuf::rt::sint32_size(65, v);
        }
        if let Some(v) = self.publisher.as_ref() {
            my_size += ::protobuf::rt::string_size(66, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(67, &v);
        }
        if let Some(v) = self.explicit {
            my_size += 2 + 1;
        }
        if let Some(v) = self.cover_image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.episode {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.copyright {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.keyword {
            my_size += ::protobuf::rt::string_size(73, &value);
        };
        if let Some(v) = self.media_type {
            my_size += ::protobuf::rt::int32_size(74, v.value());
        }
        if let Some(v) = self.consumption_order {
            my_size += ::protobuf::rt::int32_size(75, v.value());
        }
        for value in &self.availability {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.trailer_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(83, &v);
        }
        if let Some(v) = self.music_and_talk {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_audiobook {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_creator_channel {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(64, v)?;
        }
        if let Some(v) = self.deprecated_popularity {
            os.write_sint32(65, v)?;
        }
        if let Some(v) = self.publisher.as_ref() {
            os.write_string(66, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(67, v)?;
        }
        if let Some(v) = self.explicit {
            os.write_bool(68, v)?;
        }
        if let Some(v) = self.cover_image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(69, v, os)?;
        }
        for v in &self.episode {
            ::protobuf::rt::write_message_field_with_cached_size(70, v, os)?;
        };
        for v in &self.copyright {
            ::protobuf::rt::write_message_field_with_cached_size(71, v, os)?;
        };
        for v in &self.restriction {
            ::protobuf::rt::write_message_field_with_cached_size(72, v, os)?;
        };
        for v in &self.keyword {
            os.write_string(73, &v)?;
        };
        if let Some(v) = self.media_type {
            os.write_enum(74, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.consumption_order {
            os.write_enum(75, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.availability {
            ::protobuf::rt::write_message_field_with_cached_size(78, v, os)?;
        };
        if let Some(v) = self.trailer_uri.as_ref() {
            os.write_string(83, v)?;
        }
        if let Some(v) = self.music_and_talk {
            os.write_bool(85, v)?;
        }
        if let Some(v) = self.is_audiobook {
            os.write_bool(89, v)?;
        }
        if let Some(v) = self.is_creator_channel {
            os.write_bool(90, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Show {
        Show::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.deprecated_popularity = ::std::option::Option::None;
        self.publisher = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.explicit = ::std::option::Option::None;
        self.cover_image.clear();
        self.episode.clear();
        self.copyright.clear();
        self.restriction.clear();
        self.keyword.clear();
        self.media_type = ::std::option::Option::None;
        self.consumption_order = ::std::option::Option::None;
        self.availability.clear();
        self.trailer_uri = ::std::option::Option::None;
        self.music_and_talk = ::std::option::Option::None;
        self.is_audiobook = ::std::option::Option::None;
        self.is_creator_channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Show {
        static instance: Show = Show {
            gid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            description: ::std::option::Option::None,
            deprecated_popularity: ::std::option::Option::None,
            publisher: ::std::option::Option::None,
            language: ::std::option::Option::None,
            explicit: ::std::option::Option::None,
            cover_image: ::protobuf::MessageField::none(),
            episode: ::std::vec::Vec::new(),
            copyright: ::std::vec::Vec::new(),
            restriction: ::std::vec::Vec::new(),
            keyword: ::std::vec::Vec::new(),
            media_type: ::std::option::Option::None,
            consumption_order: ::std::option::Option::None,
            availability: ::std::vec::Vec::new(),
            trailer_uri: ::std::option::Option::None,
            music_and_talk: ::std::option::Option::None,
            is_audiobook: ::std::option::Option::None,
            is_creator_channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Show {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Show").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Show {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Show {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Show`
pub mod show {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Show.MediaType)
    pub enum MediaType {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Show.MediaType.MIXED)
        MIXED = 0,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Show.MediaType.AUDIO)
        AUDIO = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Show.MediaType.VIDEO)
        VIDEO = 2,
    }

    impl ::protobuf::Enum for MediaType {
        const NAME: &'static str = "MediaType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MediaType> {
            match value {
                0 => ::std::option::Option::Some(MediaType::MIXED),
                1 => ::std::option::Option::Some(MediaType::AUDIO),
                2 => ::std::option::Option::Some(MediaType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<MediaType> {
            match str {
                "MIXED" => ::std::option::Option::Some(MediaType::MIXED),
                "AUDIO" => ::std::option::Option::Some(MediaType::AUDIO),
                "VIDEO" => ::std::option::Option::Some(MediaType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MediaType] = &[
            MediaType::MIXED,
            MediaType::AUDIO,
            MediaType::VIDEO,
        ];
    }

    impl ::protobuf::EnumFull for MediaType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Show.MediaType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MediaType {
        fn default() -> Self {
            MediaType::MIXED
        }
    }

    impl MediaType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaType>("Show.MediaType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Show.ConsumptionOrder)
    pub enum ConsumptionOrder {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Show.ConsumptionOrder.SEQUENTIAL)
        SEQUENTIAL = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Show.ConsumptionOrder.EPISODIC)
        EPISODIC = 2,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Show.ConsumptionOrder.RECENT)
        RECENT = 3,
    }

    impl ::protobuf::Enum for ConsumptionOrder {
        const NAME: &'static str = "ConsumptionOrder";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConsumptionOrder> {
            match value {
                1 => ::std::option::Option::Some(ConsumptionOrder::SEQUENTIAL),
                2 => ::std::option::Option::Some(ConsumptionOrder::EPISODIC),
                3 => ::std::option::Option::Some(ConsumptionOrder::RECENT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ConsumptionOrder> {
            match str {
                "SEQUENTIAL" => ::std::option::Option::Some(ConsumptionOrder::SEQUENTIAL),
                "EPISODIC" => ::std::option::Option::Some(ConsumptionOrder::EPISODIC),
                "RECENT" => ::std::option::Option::Some(ConsumptionOrder::RECENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConsumptionOrder] = &[
            ConsumptionOrder::SEQUENTIAL,
            ConsumptionOrder::EPISODIC,
            ConsumptionOrder::RECENT,
        ];
    }

    impl ::protobuf::EnumFull for ConsumptionOrder {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Show.ConsumptionOrder").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ConsumptionOrder::SEQUENTIAL => 0,
                ConsumptionOrder::EPISODIC => 1,
                ConsumptionOrder::RECENT => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ConsumptionOrder {
        fn default() -> Self {
            ConsumptionOrder::SEQUENTIAL
        }
    }

    impl ConsumptionOrder {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConsumptionOrder>("Show.ConsumptionOrder")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.Episode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Episode {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Episode.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.audio)
    pub audio: ::std::vec::Vec<AudioFile>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.publish_time)
    pub publish_time: ::protobuf::MessageField<Date>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.deprecated_popularity)
    pub deprecated_popularity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.cover_image)
    pub cover_image: ::protobuf::MessageField<ImageGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.explicit)
    pub explicit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.show)
    pub show: ::protobuf::MessageField<Show>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.video)
    pub video: ::std::vec::Vec<VideoFile>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.video_preview)
    pub video_preview: ::std::vec::Vec<VideoFile>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.audio_preview)
    pub audio_preview: ::std::vec::Vec<AudioFile>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.restriction)
    pub restriction: ::std::vec::Vec<Restriction>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.freeze_frame)
    pub freeze_frame: ::protobuf::MessageField<ImageGroup>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.keyword)
    pub keyword: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.allow_background_playback)
    pub allow_background_playback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.availability)
    pub availability: ::std::vec::Vec<Availability>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.external_url)
    pub external_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.original_audio)
    pub original_audio: ::protobuf::MessageField<Audio>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<episode::EpisodeType>>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.music_and_talk)
    pub music_and_talk: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.content_rating)
    pub content_rating: ::std::vec::Vec<ContentRating>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.is_audiobook_chapter)
    pub is_audiobook_chapter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.metadata.Episode.is_podcast_short)
    pub is_podcast_short: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Episode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Episode {
    fn default() -> &'a Episode {
        <Episode as ::protobuf::Message>::default_instance()
    }
}

impl Episode {
    pub fn new() -> Episode {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 duration = 7;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string description = 64;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 number = 65;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional sint32 deprecated_popularity = 67;

    pub fn deprecated_popularity(&self) -> i32 {
        self.deprecated_popularity.unwrap_or(0)
    }

    pub fn clear_deprecated_popularity(&mut self) {
        self.deprecated_popularity = ::std::option::Option::None;
    }

    pub fn has_deprecated_popularity(&self) -> bool {
        self.deprecated_popularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_popularity(&mut self, v: i32) {
        self.deprecated_popularity = ::std::option::Option::Some(v);
    }

    // optional string language = 69;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool explicit = 70;

    pub fn explicit(&self) -> bool {
        self.explicit.unwrap_or(false)
    }

    pub fn clear_explicit(&mut self) {
        self.explicit = ::std::option::Option::None;
    }

    pub fn has_explicit(&self) -> bool {
        self.explicit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit(&mut self, v: bool) {
        self.explicit = ::std::option::Option::Some(v);
    }

    // optional bool allow_background_playback = 81;

    pub fn allow_background_playback(&self) -> bool {
        self.allow_background_playback.unwrap_or(false)
    }

    pub fn clear_allow_background_playback(&mut self) {
        self.allow_background_playback = ::std::option::Option::None;
    }

    pub fn has_allow_background_playback(&self) -> bool {
        self.allow_background_playback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_background_playback(&mut self, v: bool) {
        self.allow_background_playback = ::std::option::Option::Some(v);
    }

    // optional string external_url = 83;

    pub fn external_url(&self) -> &str {
        match self.external_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_external_url(&mut self) {
        self.external_url = ::std::option::Option::None;
    }

    pub fn has_external_url(&self) -> bool {
        self.external_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_url(&mut self, v: ::std::string::String) {
        self.external_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_external_url(&mut self) -> &mut ::std::string::String {
        if self.external_url.is_none() {
            self.external_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.external_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_external_url(&mut self) -> ::std::string::String {
        self.external_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .spotify.metadata.Episode.EpisodeType type = 87;

    pub fn type_(&self) -> episode::EpisodeType {
        match self.type_ {
            Some(e) => e.enum_value_or(episode::EpisodeType::FULL),
            None => episode::EpisodeType::FULL,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: episode::EpisodeType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool music_and_talk = 91;

    pub fn music_and_talk(&self) -> bool {
        self.music_and_talk.unwrap_or(false)
    }

    pub fn clear_music_and_talk(&mut self) {
        self.music_and_talk = ::std::option::Option::None;
    }

    pub fn has_music_and_talk(&self) -> bool {
        self.music_and_talk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_music_and_talk(&mut self, v: bool) {
        self.music_and_talk = ::std::option::Option::Some(v);
    }

    // optional bool is_audiobook_chapter = 96;

    pub fn is_audiobook_chapter(&self) -> bool {
        self.is_audiobook_chapter.unwrap_or(false)
    }

    pub fn clear_is_audiobook_chapter(&mut self) {
        self.is_audiobook_chapter = ::std::option::Option::None;
    }

    pub fn has_is_audiobook_chapter(&self) -> bool {
        self.is_audiobook_chapter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_audiobook_chapter(&mut self, v: bool) {
        self.is_audiobook_chapter = ::std::option::Option::Some(v);
    }

    // optional bool is_podcast_short = 97;

    pub fn is_podcast_short(&self) -> bool {
        self.is_podcast_short.unwrap_or(false)
    }

    pub fn clear_is_podcast_short(&mut self) {
        self.is_podcast_short = ::std::option::Option::None;
    }

    pub fn has_is_podcast_short(&self) -> bool {
        self.is_podcast_short.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_podcast_short(&mut self, v: bool) {
        self.is_podcast_short = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &Episode| { &m.gid },
            |m: &mut Episode| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Episode| { &m.name },
            |m: &mut Episode| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &Episode| { &m.duration },
            |m: &mut Episode| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "audio",
            |m: &Episode| { &m.audio },
            |m: &mut Episode| { &mut m.audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &Episode| { &m.description },
            |m: &mut Episode| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &Episode| { &m.number },
            |m: &mut Episode| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Date>(
            "publish_time",
            |m: &Episode| { &m.publish_time },
            |m: &mut Episode| { &mut m.publish_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated_popularity",
            |m: &Episode| { &m.deprecated_popularity },
            |m: &mut Episode| { &mut m.deprecated_popularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageGroup>(
            "cover_image",
            |m: &Episode| { &m.cover_image },
            |m: &mut Episode| { &mut m.cover_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &Episode| { &m.language },
            |m: &mut Episode| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explicit",
            |m: &Episode| { &m.explicit },
            |m: &mut Episode| { &mut m.explicit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Show>(
            "show",
            |m: &Episode| { &m.show },
            |m: &mut Episode| { &mut m.show },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "video",
            |m: &Episode| { &m.video },
            |m: &mut Episode| { &mut m.video },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "video_preview",
            |m: &Episode| { &m.video_preview },
            |m: &mut Episode| { &mut m.video_preview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "audio_preview",
            |m: &Episode| { &m.audio_preview },
            |m: &mut Episode| { &mut m.audio_preview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "restriction",
            |m: &Episode| { &m.restriction },
            |m: &mut Episode| { &mut m.restriction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageGroup>(
            "freeze_frame",
            |m: &Episode| { &m.freeze_frame },
            |m: &mut Episode| { &mut m.freeze_frame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keyword",
            |m: &Episode| { &m.keyword },
            |m: &mut Episode| { &mut m.keyword },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_background_playback",
            |m: &Episode| { &m.allow_background_playback },
            |m: &mut Episode| { &mut m.allow_background_playback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "availability",
            |m: &Episode| { &m.availability },
            |m: &mut Episode| { &mut m.availability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "external_url",
            |m: &Episode| { &m.external_url },
            |m: &mut Episode| { &mut m.external_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Audio>(
            "original_audio",
            |m: &Episode| { &m.original_audio },
            |m: &mut Episode| { &mut m.original_audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Episode| { &m.type_ },
            |m: &mut Episode| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "music_and_talk",
            |m: &Episode| { &m.music_and_talk },
            |m: &mut Episode| { &mut m.music_and_talk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_rating",
            |m: &Episode| { &m.content_rating },
            |m: &mut Episode| { &mut m.content_rating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_audiobook_chapter",
            |m: &Episode| { &m.is_audiobook_chapter },
            |m: &mut Episode| { &mut m.is_audiobook_chapter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_podcast_short",
            |m: &Episode| { &m.is_podcast_short },
            |m: &mut Episode| { &mut m.is_podcast_short },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Episode>(
            "Episode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Episode {
    const NAME: &'static str = "Episode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.duration = ::std::option::Option::Some(is.read_sint32()?);
                },
                98 => {
                    self.audio.push(is.read_message()?);
                },
                514 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                520 => {
                    self.number = ::std::option::Option::Some(is.read_sint32()?);
                },
                530 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.publish_time)?;
                },
                536 => {
                    self.deprecated_popularity = ::std::option::Option::Some(is.read_sint32()?);
                },
                546 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cover_image)?;
                },
                554 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                560 => {
                    self.explicit = ::std::option::Option::Some(is.read_bool()?);
                },
                570 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.show)?;
                },
                578 => {
                    self.video.push(is.read_message()?);
                },
                586 => {
                    self.video_preview.push(is.read_message()?);
                },
                594 => {
                    self.audio_preview.push(is.read_message()?);
                },
                602 => {
                    self.restriction.push(is.read_message()?);
                },
                610 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.freeze_frame)?;
                },
                618 => {
                    self.keyword.push(is.read_string()?);
                },
                648 => {
                    self.allow_background_playback = ::std::option::Option::Some(is.read_bool()?);
                },
                658 => {
                    self.availability.push(is.read_message()?);
                },
                666 => {
                    self.external_url = ::std::option::Option::Some(is.read_string()?);
                },
                674 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.original_audio)?;
                },
                696 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                728 => {
                    self.music_and_talk = ::std::option::Option::Some(is.read_bool()?);
                },
                762 => {
                    self.content_rating.push(is.read_message()?);
                },
                768 => {
                    self.is_audiobook_chapter = ::std::option::Option::Some(is.read_bool()?);
                },
                776 => {
                    self.is_podcast_short = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::sint32_size(7, v);
        }
        for value in &self.audio {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(64, &v);
        }
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::sint32_size(65, v);
        }
        if let Some(v) = self.publish_time.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deprecated_popularity {
            my_size += ::protobuf::rt::sint32_size(67, v);
        }
        if let Some(v) = self.cover_image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(69, &v);
        }
        if let Some(v) = self.explicit {
            my_size += 2 + 1;
        }
        if let Some(v) = self.show.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.video {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.video_preview {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.audio_preview {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.freeze_frame.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keyword {
            my_size += ::protobuf::rt::string_size(77, &value);
        };
        if let Some(v) = self.allow_background_playback {
            my_size += 2 + 1;
        }
        for value in &self.availability {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.external_url.as_ref() {
            my_size += ::protobuf::rt::string_size(83, &v);
        }
        if let Some(v) = self.original_audio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(87, v.value());
        }
        if let Some(v) = self.music_and_talk {
            my_size += 2 + 1;
        }
        for value in &self.content_rating {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_audiobook_chapter {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_podcast_short {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_sint32(7, v)?;
        }
        for v in &self.audio {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.description.as_ref() {
            os.write_string(64, v)?;
        }
        if let Some(v) = self.number {
            os.write_sint32(65, v)?;
        }
        if let Some(v) = self.publish_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(66, v, os)?;
        }
        if let Some(v) = self.deprecated_popularity {
            os.write_sint32(67, v)?;
        }
        if let Some(v) = self.cover_image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(68, v, os)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(69, v)?;
        }
        if let Some(v) = self.explicit {
            os.write_bool(70, v)?;
        }
        if let Some(v) = self.show.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(71, v, os)?;
        }
        for v in &self.video {
            ::protobuf::rt::write_message_field_with_cached_size(72, v, os)?;
        };
        for v in &self.video_preview {
            ::protobuf::rt::write_message_field_with_cached_size(73, v, os)?;
        };
        for v in &self.audio_preview {
            ::protobuf::rt::write_message_field_with_cached_size(74, v, os)?;
        };
        for v in &self.restriction {
            ::protobuf::rt::write_message_field_with_cached_size(75, v, os)?;
        };
        if let Some(v) = self.freeze_frame.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(76, v, os)?;
        }
        for v in &self.keyword {
            os.write_string(77, &v)?;
        };
        if let Some(v) = self.allow_background_playback {
            os.write_bool(81, v)?;
        }
        for v in &self.availability {
            ::protobuf::rt::write_message_field_with_cached_size(82, v, os)?;
        };
        if let Some(v) = self.external_url.as_ref() {
            os.write_string(83, v)?;
        }
        if let Some(v) = self.original_audio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(84, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(87, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.music_and_talk {
            os.write_bool(91, v)?;
        }
        for v in &self.content_rating {
            ::protobuf::rt::write_message_field_with_cached_size(95, v, os)?;
        };
        if let Some(v) = self.is_audiobook_chapter {
            os.write_bool(96, v)?;
        }
        if let Some(v) = self.is_podcast_short {
            os.write_bool(97, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Episode {
        Episode::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.audio.clear();
        self.description = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.publish_time.clear();
        self.deprecated_popularity = ::std::option::Option::None;
        self.cover_image.clear();
        self.language = ::std::option::Option::None;
        self.explicit = ::std::option::Option::None;
        self.show.clear();
        self.video.clear();
        self.video_preview.clear();
        self.audio_preview.clear();
        self.restriction.clear();
        self.freeze_frame.clear();
        self.keyword.clear();
        self.allow_background_playback = ::std::option::Option::None;
        self.availability.clear();
        self.external_url = ::std::option::Option::None;
        self.original_audio.clear();
        self.type_ = ::std::option::Option::None;
        self.music_and_talk = ::std::option::Option::None;
        self.content_rating.clear();
        self.is_audiobook_chapter = ::std::option::Option::None;
        self.is_podcast_short = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Episode {
        static instance: Episode = Episode {
            gid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            audio: ::std::vec::Vec::new(),
            description: ::std::option::Option::None,
            number: ::std::option::Option::None,
            publish_time: ::protobuf::MessageField::none(),
            deprecated_popularity: ::std::option::Option::None,
            cover_image: ::protobuf::MessageField::none(),
            language: ::std::option::Option::None,
            explicit: ::std::option::Option::None,
            show: ::protobuf::MessageField::none(),
            video: ::std::vec::Vec::new(),
            video_preview: ::std::vec::Vec::new(),
            audio_preview: ::std::vec::Vec::new(),
            restriction: ::std::vec::Vec::new(),
            freeze_frame: ::protobuf::MessageField::none(),
            keyword: ::std::vec::Vec::new(),
            allow_background_playback: ::std::option::Option::None,
            availability: ::std::vec::Vec::new(),
            external_url: ::std::option::Option::None,
            original_audio: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            music_and_talk: ::std::option::Option::None,
            content_rating: ::std::vec::Vec::new(),
            is_audiobook_chapter: ::std::option::Option::None,
            is_podcast_short: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Episode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Episode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Episode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Episode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Episode`
pub mod episode {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Episode.EpisodeType)
    pub enum EpisodeType {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Episode.EpisodeType.FULL)
        FULL = 0,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Episode.EpisodeType.TRAILER)
        TRAILER = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Episode.EpisodeType.BONUS)
        BONUS = 2,
    }

    impl ::protobuf::Enum for EpisodeType {
        const NAME: &'static str = "EpisodeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EpisodeType> {
            match value {
                0 => ::std::option::Option::Some(EpisodeType::FULL),
                1 => ::std::option::Option::Some(EpisodeType::TRAILER),
                2 => ::std::option::Option::Some(EpisodeType::BONUS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EpisodeType> {
            match str {
                "FULL" => ::std::option::Option::Some(EpisodeType::FULL),
                "TRAILER" => ::std::option::Option::Some(EpisodeType::TRAILER),
                "BONUS" => ::std::option::Option::Some(EpisodeType::BONUS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EpisodeType] = &[
            EpisodeType::FULL,
            EpisodeType::TRAILER,
            EpisodeType::BONUS,
        ];
    }

    impl ::protobuf::EnumFull for EpisodeType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Episode.EpisodeType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EpisodeType {
        fn default() -> Self {
            EpisodeType::FULL
        }
    }

    impl EpisodeType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EpisodeType>("Episode.EpisodeType")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.Licensor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Licensor {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Licensor.uuid)
    pub uuid: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Licensor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Licensor {
    fn default() -> &'a Licensor {
        <Licensor as ::protobuf::Message>::default_instance()
    }
}

impl Licensor {
    pub fn new() -> Licensor {
        ::std::default::Default::default()
    }

    // optional bytes uuid = 1;

    pub fn uuid(&self) -> &[u8] {
        match self.uuid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_uuid(&mut self) {
        self.uuid = ::std::option::Option::None;
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.uuid.is_none() {
            self.uuid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uuid",
            |m: &Licensor| { &m.uuid },
            |m: &mut Licensor| { &mut m.uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Licensor>(
            "Licensor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Licensor {
    const NAME: &'static str = "Licensor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uuid.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Licensor {
        Licensor::new()
    }

    fn clear(&mut self) {
        self.uuid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Licensor {
        static instance: Licensor = Licensor {
            uuid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Licensor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Licensor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Licensor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Licensor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.Audio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Audio {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Audio.uuid)
    pub uuid: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Audio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Audio {
    fn default() -> &'a Audio {
        <Audio as ::protobuf::Message>::default_instance()
    }
}

impl Audio {
    pub fn new() -> Audio {
        ::std::default::Default::default()
    }

    // optional bytes uuid = 1;

    pub fn uuid(&self) -> &[u8] {
        match self.uuid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_uuid(&mut self) {
        self.uuid = ::std::option::Option::None;
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.uuid.is_none() {
            self.uuid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uuid",
            |m: &Audio| { &m.uuid },
            |m: &mut Audio| { &mut m.uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Audio>(
            "Audio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Audio {
    const NAME: &'static str = "Audio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uuid.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Audio {
        Audio::new()
    }

    fn clear(&mut self) {
        self.uuid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Audio {
        static instance: Audio = Audio {
            uuid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Audio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Audio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Audio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Audio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.TopTracks)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TopTracks {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.TopTracks.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.TopTracks.track)
    pub track: ::std::vec::Vec<Track>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.TopTracks.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TopTracks {
    fn default() -> &'a TopTracks {
        <TopTracks as ::protobuf::Message>::default_instance()
    }
}

impl TopTracks {
    pub fn new() -> TopTracks {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &TopTracks| { &m.country },
            |m: &mut TopTracks| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "track",
            |m: &TopTracks| { &m.track },
            |m: &mut TopTracks| { &mut m.track },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TopTracks>(
            "TopTracks",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TopTracks {
    const NAME: &'static str = "TopTracks";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.track.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.track {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.track {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TopTracks {
        TopTracks::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.track.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TopTracks {
        static instance: TopTracks = TopTracks {
            country: ::std::option::Option::None,
            track: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TopTracks {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TopTracks").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TopTracks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopTracks {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.ActivityPeriod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityPeriod {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.ActivityPeriod.start_year)
    pub start_year: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.ActivityPeriod.end_year)
    pub end_year: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.ActivityPeriod.decade)
    pub decade: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.ActivityPeriod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityPeriod {
    fn default() -> &'a ActivityPeriod {
        <ActivityPeriod as ::protobuf::Message>::default_instance()
    }
}

impl ActivityPeriod {
    pub fn new() -> ActivityPeriod {
        ::std::default::Default::default()
    }

    // optional sint32 start_year = 1;

    pub fn start_year(&self) -> i32 {
        self.start_year.unwrap_or(0)
    }

    pub fn clear_start_year(&mut self) {
        self.start_year = ::std::option::Option::None;
    }

    pub fn has_start_year(&self) -> bool {
        self.start_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_year(&mut self, v: i32) {
        self.start_year = ::std::option::Option::Some(v);
    }

    // optional sint32 end_year = 2;

    pub fn end_year(&self) -> i32 {
        self.end_year.unwrap_or(0)
    }

    pub fn clear_end_year(&mut self) {
        self.end_year = ::std::option::Option::None;
    }

    pub fn has_end_year(&self) -> bool {
        self.end_year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_year(&mut self, v: i32) {
        self.end_year = ::std::option::Option::Some(v);
    }

    // optional sint32 decade = 3;

    pub fn decade(&self) -> i32 {
        self.decade.unwrap_or(0)
    }

    pub fn clear_decade(&mut self) {
        self.decade = ::std::option::Option::None;
    }

    pub fn has_decade(&self) -> bool {
        self.decade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decade(&mut self, v: i32) {
        self.decade = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_year",
            |m: &ActivityPeriod| { &m.start_year },
            |m: &mut ActivityPeriod| { &mut m.start_year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_year",
            |m: &ActivityPeriod| { &m.end_year },
            |m: &mut ActivityPeriod| { &mut m.end_year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decade",
            |m: &ActivityPeriod| { &m.decade },
            |m: &mut ActivityPeriod| { &mut m.decade },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityPeriod>(
            "ActivityPeriod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityPeriod {
    const NAME: &'static str = "ActivityPeriod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_year = ::std::option::Option::Some(is.read_sint32()?);
                },
                16 => {
                    self.end_year = ::std::option::Option::Some(is.read_sint32()?);
                },
                24 => {
                    self.decade = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_year {
            my_size += ::protobuf::rt::sint32_size(1, v);
        }
        if let Some(v) = self.end_year {
            my_size += ::protobuf::rt::sint32_size(2, v);
        }
        if let Some(v) = self.decade {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_year {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.end_year {
            os.write_sint32(2, v)?;
        }
        if let Some(v) = self.decade {
            os.write_sint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityPeriod {
        ActivityPeriod::new()
    }

    fn clear(&mut self) {
        self.start_year = ::std::option::Option::None;
        self.end_year = ::std::option::Option::None;
        self.decade = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityPeriod {
        static instance: ActivityPeriod = ActivityPeriod {
            start_year: ::std::option::Option::None,
            end_year: ::std::option::Option::None,
            decade: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityPeriod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityPeriod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityPeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityPeriod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.AlbumGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlbumGroup {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.AlbumGroup.album)
    pub album: ::std::vec::Vec<Album>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.AlbumGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlbumGroup {
    fn default() -> &'a AlbumGroup {
        <AlbumGroup as ::protobuf::Message>::default_instance()
    }
}

impl AlbumGroup {
    pub fn new() -> AlbumGroup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "album",
            |m: &AlbumGroup| { &m.album },
            |m: &mut AlbumGroup| { &mut m.album },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlbumGroup>(
            "AlbumGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlbumGroup {
    const NAME: &'static str = "AlbumGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.album.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.album {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.album {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlbumGroup {
        AlbumGroup::new()
    }

    fn clear(&mut self) {
        self.album.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlbumGroup {
        static instance: AlbumGroup = AlbumGroup {
            album: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlbumGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlbumGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlbumGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlbumGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.Date)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Date {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Date.year)
    pub year: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Date.month)
    pub month: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Date.day)
    pub day: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Date.hour)
    pub hour: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Date.minute)
    pub minute: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Date.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Date {
    fn default() -> &'a Date {
        <Date as ::protobuf::Message>::default_instance()
    }
}

impl Date {
    pub fn new() -> Date {
        ::std::default::Default::default()
    }

    // optional sint32 year = 1;

    pub fn year(&self) -> i32 {
        self.year.unwrap_or(0)
    }

    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: i32) {
        self.year = ::std::option::Option::Some(v);
    }

    // optional sint32 month = 2;

    pub fn month(&self) -> i32 {
        self.month.unwrap_or(0)
    }

    pub fn clear_month(&mut self) {
        self.month = ::std::option::Option::None;
    }

    pub fn has_month(&self) -> bool {
        self.month.is_some()
    }

    // Param is passed by value, moved
    pub fn set_month(&mut self, v: i32) {
        self.month = ::std::option::Option::Some(v);
    }

    // optional sint32 day = 3;

    pub fn day(&self) -> i32 {
        self.day.unwrap_or(0)
    }

    pub fn clear_day(&mut self) {
        self.day = ::std::option::Option::None;
    }

    pub fn has_day(&self) -> bool {
        self.day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day(&mut self, v: i32) {
        self.day = ::std::option::Option::Some(v);
    }

    // optional sint32 hour = 4;

    pub fn hour(&self) -> i32 {
        self.hour.unwrap_or(0)
    }

    pub fn clear_hour(&mut self) {
        self.hour = ::std::option::Option::None;
    }

    pub fn has_hour(&self) -> bool {
        self.hour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hour(&mut self, v: i32) {
        self.hour = ::std::option::Option::Some(v);
    }

    // optional sint32 minute = 5;

    pub fn minute(&self) -> i32 {
        self.minute.unwrap_or(0)
    }

    pub fn clear_minute(&mut self) {
        self.minute = ::std::option::Option::None;
    }

    pub fn has_minute(&self) -> bool {
        self.minute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minute(&mut self, v: i32) {
        self.minute = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "year",
            |m: &Date| { &m.year },
            |m: &mut Date| { &mut m.year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "month",
            |m: &Date| { &m.month },
            |m: &mut Date| { &mut m.month },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "day",
            |m: &Date| { &m.day },
            |m: &mut Date| { &mut m.day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hour",
            |m: &Date| { &m.hour },
            |m: &mut Date| { &mut m.hour },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minute",
            |m: &Date| { &m.minute },
            |m: &mut Date| { &mut m.minute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Date>(
            "Date",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Date {
    const NAME: &'static str = "Date";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.year = ::std::option::Option::Some(is.read_sint32()?);
                },
                16 => {
                    self.month = ::std::option::Option::Some(is.read_sint32()?);
                },
                24 => {
                    self.day = ::std::option::Option::Some(is.read_sint32()?);
                },
                32 => {
                    self.hour = ::std::option::Option::Some(is.read_sint32()?);
                },
                40 => {
                    self.minute = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::sint32_size(1, v);
        }
        if let Some(v) = self.month {
            my_size += ::protobuf::rt::sint32_size(2, v);
        }
        if let Some(v) = self.day {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.hour {
            my_size += ::protobuf::rt::sint32_size(4, v);
        }
        if let Some(v) = self.minute {
            my_size += ::protobuf::rt::sint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.year {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.month {
            os.write_sint32(2, v)?;
        }
        if let Some(v) = self.day {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.hour {
            os.write_sint32(4, v)?;
        }
        if let Some(v) = self.minute {
            os.write_sint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Date {
        Date::new()
    }

    fn clear(&mut self) {
        self.year = ::std::option::Option::None;
        self.month = ::std::option::Option::None;
        self.day = ::std::option::Option::None;
        self.hour = ::std::option::Option::None;
        self.minute = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Date {
        static instance: Date = Date {
            year: ::std::option::Option::None,
            month: ::std::option::Option::None,
            day: ::std::option::Option::None,
            hour: ::std::option::Option::None,
            minute: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Date {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Date").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Date {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Date {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.Image)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Image {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Image.file_id)
    pub file_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.Image.size)
    pub size: ::std::option::Option<::protobuf::EnumOrUnknown<image::Size>>,
    // @@protoc_insertion_point(field:spotify.metadata.Image.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Image.height)
    pub height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Image.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // optional bytes file_id = 1;

    pub fn file_id(&self) -> &[u8] {
        match self.file_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_file_id(&mut self) {
        self.file_id = ::std::option::Option::None;
    }

    pub fn has_file_id(&self) -> bool {
        self.file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.file_id.is_none() {
            self.file_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_id(&mut self) -> ::std::vec::Vec<u8> {
        self.file_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .spotify.metadata.Image.Size size = 2;

    pub fn size(&self) -> image::Size {
        match self.size {
            Some(e) => e.enum_value_or(image::Size::DEFAULT),
            None => image::Size::DEFAULT,
        }
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: image::Size) {
        self.size = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional sint32 width = 3;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional sint32 height = 4;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_id",
            |m: &Image| { &m.file_id },
            |m: &mut Image| { &mut m.file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &Image| { &m.size },
            |m: &mut Image| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &Image| { &m.width },
            |m: &mut Image| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &Image| { &m.height },
            |m: &mut Image| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Image>(
            "Image",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Image {
    const NAME: &'static str = "Image";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.size = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_sint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::sint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_id.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.width {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_sint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Image {
        Image::new()
    }

    fn clear(&mut self) {
        self.file_id = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Image {
        static instance: Image = Image {
            file_id: ::std::option::Option::None,
            size: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Image {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Image").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Image`
pub mod image {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Image.Size)
    pub enum Size {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Image.Size.DEFAULT)
        DEFAULT = 0,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Image.Size.SMALL)
        SMALL = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Image.Size.LARGE)
        LARGE = 2,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Image.Size.XLARGE)
        XLARGE = 3,
    }

    impl ::protobuf::Enum for Size {
        const NAME: &'static str = "Size";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Size> {
            match value {
                0 => ::std::option::Option::Some(Size::DEFAULT),
                1 => ::std::option::Option::Some(Size::SMALL),
                2 => ::std::option::Option::Some(Size::LARGE),
                3 => ::std::option::Option::Some(Size::XLARGE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Size> {
            match str {
                "DEFAULT" => ::std::option::Option::Some(Size::DEFAULT),
                "SMALL" => ::std::option::Option::Some(Size::SMALL),
                "LARGE" => ::std::option::Option::Some(Size::LARGE),
                "XLARGE" => ::std::option::Option::Some(Size::XLARGE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Size] = &[
            Size::DEFAULT,
            Size::SMALL,
            Size::LARGE,
            Size::XLARGE,
        ];
    }

    impl ::protobuf::EnumFull for Size {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Image.Size").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Size {
        fn default() -> Self {
            Size::DEFAULT
        }
    }

    impl Size {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Size>("Image.Size")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.ImageGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ImageGroup {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.ImageGroup.image)
    pub image: ::std::vec::Vec<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.ImageGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ImageGroup {
    fn default() -> &'a ImageGroup {
        <ImageGroup as ::protobuf::Message>::default_instance()
    }
}

impl ImageGroup {
    pub fn new() -> ImageGroup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "image",
            |m: &ImageGroup| { &m.image },
            |m: &mut ImageGroup| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImageGroup>(
            "ImageGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ImageGroup {
    const NAME: &'static str = "ImageGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.image.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.image {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ImageGroup {
        ImageGroup::new()
    }

    fn clear(&mut self) {
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ImageGroup {
        static instance: ImageGroup = ImageGroup {
            image: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ImageGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ImageGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ImageGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.Biography)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Biography {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Biography.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Biography.portrait)
    pub portrait: ::std::vec::Vec<Image>,
    // @@protoc_insertion_point(field:spotify.metadata.Biography.portrait_group)
    pub portrait_group: ::std::vec::Vec<ImageGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Biography.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Biography {
    fn default() -> &'a Biography {
        <Biography as ::protobuf::Message>::default_instance()
    }
}

impl Biography {
    pub fn new() -> Biography {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &Biography| { &m.text },
            |m: &mut Biography| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "portrait",
            |m: &Biography| { &m.portrait },
            |m: &mut Biography| { &mut m.portrait },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "portrait_group",
            |m: &Biography| { &m.portrait_group },
            |m: &mut Biography| { &mut m.portrait_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Biography>(
            "Biography",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Biography {
    const NAME: &'static str = "Biography";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.portrait.push(is.read_message()?);
                },
                26 => {
                    self.portrait_group.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.portrait {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.portrait_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.portrait {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.portrait_group {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Biography {
        Biography::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.portrait.clear();
        self.portrait_group.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Biography {
        static instance: Biography = Biography {
            text: ::std::option::Option::None,
            portrait: ::std::vec::Vec::new(),
            portrait_group: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Biography {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Biography").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Biography {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Biography {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.Disc)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Disc {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Disc.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.metadata.Disc.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Disc.track)
    pub track: ::std::vec::Vec<Track>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Disc.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Disc {
    fn default() -> &'a Disc {
        <Disc as ::protobuf::Message>::default_instance()
    }
}

impl Disc {
    pub fn new() -> Disc {
        ::std::default::Default::default()
    }

    // optional sint32 number = 1;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &Disc| { &m.number },
            |m: &mut Disc| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Disc| { &m.name },
            |m: &mut Disc| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "track",
            |m: &Disc| { &m.track },
            |m: &mut Disc| { &mut m.track },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Disc>(
            "Disc",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Disc {
    const NAME: &'static str = "Disc";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.number = ::std::option::Option::Some(is.read_sint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.track.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::sint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.track {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.number {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.track {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Disc {
        Disc::new()
    }

    fn clear(&mut self) {
        self.number = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.track.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Disc {
        static instance: Disc = Disc {
            number: ::std::option::Option::None,
            name: ::std::option::Option::None,
            track: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Disc {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Disc").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Disc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Disc {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.Copyright)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Copyright {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Copyright.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<copyright::Type>>,
    // @@protoc_insertion_point(field:spotify.metadata.Copyright.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Copyright.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Copyright {
    fn default() -> &'a Copyright {
        <Copyright as ::protobuf::Message>::default_instance()
    }
}

impl Copyright {
    pub fn new() -> Copyright {
        ::std::default::Default::default()
    }

    // optional .spotify.metadata.Copyright.Type type = 1;

    pub fn type_(&self) -> copyright::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(copyright::Type::P),
            None => copyright::Type::P,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: copyright::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Copyright| { &m.type_ },
            |m: &mut Copyright| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &Copyright| { &m.text },
            |m: &mut Copyright| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Copyright>(
            "Copyright",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Copyright {
    const NAME: &'static str = "Copyright";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Copyright {
        Copyright::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Copyright {
        static instance: Copyright = Copyright {
            type_: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Copyright {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Copyright").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Copyright {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Copyright {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Copyright`
pub mod copyright {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Copyright.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Copyright.Type.P)
        P = 0,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Copyright.Type.C)
        C = 1,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::P),
                1 => ::std::option::Option::Some(Type::C),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "P" => ::std::option::Option::Some(Type::P),
                "C" => ::std::option::Option::Some(Type::C),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::P,
            Type::C,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Copyright.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::P
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("Copyright.Type")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.Restriction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Restriction {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Restriction.catalogue)
    pub catalogue: ::std::vec::Vec<::protobuf::EnumOrUnknown<restriction::Catalogue>>,
    // @@protoc_insertion_point(field:spotify.metadata.Restriction.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<restriction::Type>>,
    // @@protoc_insertion_point(field:spotify.metadata.Restriction.catalogue_str)
    pub catalogue_str: ::std::vec::Vec<::std::string::String>,
    // message oneof groups
    pub country_restriction: ::std::option::Option<restriction::Country_restriction>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Restriction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Restriction {
    fn default() -> &'a Restriction {
        <Restriction as ::protobuf::Message>::default_instance()
    }
}

impl Restriction {
    pub fn new() -> Restriction {
        ::std::default::Default::default()
    }

    // optional .spotify.metadata.Restriction.Type type = 4;

    pub fn type_(&self) -> restriction::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(restriction::Type::STREAMING),
            None => restriction::Type::STREAMING,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: restriction::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string countries_allowed = 2;

    pub fn countries_allowed(&self) -> &str {
        match self.country_restriction {
            ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_countries_allowed(&mut self) {
        self.country_restriction = ::std::option::Option::None;
    }

    pub fn has_countries_allowed(&self) -> bool {
        match self.country_restriction {
            ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_countries_allowed(&mut self, v: ::std::string::String) {
        self.country_restriction = ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_countries_allowed(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(_)) = self.country_restriction {
        } else {
            self.country_restriction = ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(::std::string::String::new()));
        }
        match self.country_restriction {
            ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_countries_allowed(&mut self) -> ::std::string::String {
        if self.has_countries_allowed() {
            match self.country_restriction.take() {
                ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string countries_forbidden = 3;

    pub fn countries_forbidden(&self) -> &str {
        match self.country_restriction {
            ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_countries_forbidden(&mut self) {
        self.country_restriction = ::std::option::Option::None;
    }

    pub fn has_countries_forbidden(&self) -> bool {
        match self.country_restriction {
            ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_countries_forbidden(&mut self, v: ::std::string::String) {
        self.country_restriction = ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(v))
    }

    // Mutable pointer to the field.
    pub fn mut_countries_forbidden(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(_)) = self.country_restriction {
        } else {
            self.country_restriction = ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(::std::string::String::new()));
        }
        match self.country_restriction {
            ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_countries_forbidden(&mut self) -> ::std::string::String {
        if self.has_countries_forbidden() {
            match self.country_restriction.take() {
                ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "catalogue",
            |m: &Restriction| { &m.catalogue },
            |m: &mut Restriction| { &mut m.catalogue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Restriction| { &m.type_ },
            |m: &mut Restriction| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "catalogue_str",
            |m: &Restriction| { &m.catalogue_str },
            |m: &mut Restriction| { &mut m.catalogue_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "countries_allowed",
            Restriction::has_countries_allowed,
            Restriction::countries_allowed,
            Restriction::set_countries_allowed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "countries_forbidden",
            Restriction::has_countries_forbidden,
            Restriction::countries_forbidden,
            Restriction::set_countries_forbidden,
        ));
        oneofs.push(restriction::Country_restriction::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Restriction>(
            "Restriction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Restriction {
    const NAME: &'static str = "Restriction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.catalogue.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.catalogue)?
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.catalogue_str.push(is.read_string()?);
                },
                18 => {
                    self.country_restriction = ::std::option::Option::Some(restriction::Country_restriction::CountriesAllowed(is.read_string()?));
                },
                26 => {
                    self.country_restriction = ::std::option::Option::Some(restriction::Country_restriction::CountriesForbidden(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.catalogue {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.catalogue_str {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.country_restriction {
            match v {
                &restriction::Country_restriction::CountriesAllowed(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &restriction::Country_restriction::CountriesForbidden(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.catalogue {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.catalogue_str {
            os.write_string(5, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.country_restriction {
            match v {
                &restriction::Country_restriction::CountriesAllowed(ref v) => {
                    os.write_string(2, v)?;
                },
                &restriction::Country_restriction::CountriesForbidden(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Restriction {
        Restriction::new()
    }

    fn clear(&mut self) {
        self.catalogue.clear();
        self.type_ = ::std::option::Option::None;
        self.catalogue_str.clear();
        self.country_restriction = ::std::option::Option::None;
        self.country_restriction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Restriction {
        static instance: Restriction = Restriction {
            catalogue: ::std::vec::Vec::new(),
            type_: ::std::option::Option::None,
            catalogue_str: ::std::vec::Vec::new(),
            country_restriction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Restriction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Restriction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Restriction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Restriction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Restriction`
pub mod restriction {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.metadata.Restriction.country_restriction)
    pub enum Country_restriction {
        // @@protoc_insertion_point(oneof_field:spotify.metadata.Restriction.countries_allowed)
        CountriesAllowed(::std::string::String),
        // @@protoc_insertion_point(oneof_field:spotify.metadata.Restriction.countries_forbidden)
        CountriesForbidden(::std::string::String),
    }

    impl ::protobuf::Oneof for Country_restriction {
    }

    impl ::protobuf::OneofFull for Country_restriction {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Restriction as ::protobuf::MessageFull>::descriptor().oneof_by_name("country_restriction").unwrap()).clone()
        }
    }

    impl Country_restriction {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Country_restriction>("country_restriction")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Restriction.Catalogue)
    pub enum Catalogue {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Restriction.Catalogue.AD)
        AD = 0,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Restriction.Catalogue.SUBSCRIPTION)
        SUBSCRIPTION = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Restriction.Catalogue.CATALOGUE_ALL)
        CATALOGUE_ALL = 2,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Restriction.Catalogue.SHUFFLE)
        SHUFFLE = 3,
        // @@protoc_insertion_point(enum_value:spotify.metadata.Restriction.Catalogue.COMMERCIAL)
        COMMERCIAL = 4,
    }

    impl ::protobuf::Enum for Catalogue {
        const NAME: &'static str = "Catalogue";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Catalogue> {
            match value {
                0 => ::std::option::Option::Some(Catalogue::AD),
                1 => ::std::option::Option::Some(Catalogue::SUBSCRIPTION),
                2 => ::std::option::Option::Some(Catalogue::CATALOGUE_ALL),
                3 => ::std::option::Option::Some(Catalogue::SHUFFLE),
                4 => ::std::option::Option::Some(Catalogue::COMMERCIAL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Catalogue> {
            match str {
                "AD" => ::std::option::Option::Some(Catalogue::AD),
                "SUBSCRIPTION" => ::std::option::Option::Some(Catalogue::SUBSCRIPTION),
                "CATALOGUE_ALL" => ::std::option::Option::Some(Catalogue::CATALOGUE_ALL),
                "SHUFFLE" => ::std::option::Option::Some(Catalogue::SHUFFLE),
                "COMMERCIAL" => ::std::option::Option::Some(Catalogue::COMMERCIAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Catalogue] = &[
            Catalogue::AD,
            Catalogue::SUBSCRIPTION,
            Catalogue::CATALOGUE_ALL,
            Catalogue::SHUFFLE,
            Catalogue::COMMERCIAL,
        ];
    }

    impl ::protobuf::EnumFull for Catalogue {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Restriction.Catalogue").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Catalogue {
        fn default() -> Self {
            Catalogue::AD
        }
    }

    impl Catalogue {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Catalogue>("Restriction.Catalogue")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.Restriction.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:spotify.metadata.Restriction.Type.STREAMING)
        STREAMING = 0,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::STREAMING),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "STREAMING" => ::std::option::Option::Some(Type::STREAMING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::STREAMING,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Restriction.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::STREAMING
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("Restriction.Type")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.Availability)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Availability {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Availability.catalogue_str)
    pub catalogue_str: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.Availability.start)
    pub start: ::protobuf::MessageField<Date>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Availability.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Availability {
    fn default() -> &'a Availability {
        <Availability as ::protobuf::Message>::default_instance()
    }
}

impl Availability {
    pub fn new() -> Availability {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "catalogue_str",
            |m: &Availability| { &m.catalogue_str },
            |m: &mut Availability| { &mut m.catalogue_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Date>(
            "start",
            |m: &Availability| { &m.start },
            |m: &mut Availability| { &mut m.start },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Availability>(
            "Availability",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Availability {
    const NAME: &'static str = "Availability";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.catalogue_str.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.catalogue_str {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.catalogue_str {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Availability {
        Availability::new()
    }

    fn clear(&mut self) {
        self.catalogue_str.clear();
        self.start.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Availability {
        static instance: Availability = Availability {
            catalogue_str: ::std::vec::Vec::new(),
            start: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Availability {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Availability").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Availability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.SalePeriod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SalePeriod {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.SalePeriod.restriction)
    pub restriction: ::std::vec::Vec<Restriction>,
    // @@protoc_insertion_point(field:spotify.metadata.SalePeriod.start)
    pub start: ::protobuf::MessageField<Date>,
    // @@protoc_insertion_point(field:spotify.metadata.SalePeriod.end)
    pub end: ::protobuf::MessageField<Date>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.SalePeriod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SalePeriod {
    fn default() -> &'a SalePeriod {
        <SalePeriod as ::protobuf::Message>::default_instance()
    }
}

impl SalePeriod {
    pub fn new() -> SalePeriod {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "restriction",
            |m: &SalePeriod| { &m.restriction },
            |m: &mut SalePeriod| { &mut m.restriction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Date>(
            "start",
            |m: &SalePeriod| { &m.start },
            |m: &mut SalePeriod| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Date>(
            "end",
            |m: &SalePeriod| { &m.end },
            |m: &mut SalePeriod| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SalePeriod>(
            "SalePeriod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SalePeriod {
    const NAME: &'static str = "SalePeriod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.restriction.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.restriction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.restriction {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SalePeriod {
        SalePeriod::new()
    }

    fn clear(&mut self) {
        self.restriction.clear();
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SalePeriod {
        static instance: SalePeriod = SalePeriod {
            restriction: ::std::vec::Vec::new(),
            start: ::protobuf::MessageField::none(),
            end: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SalePeriod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SalePeriod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SalePeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SalePeriod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.ExternalId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExternalId {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.ExternalId.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.ExternalId.id)
    pub id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.ExternalId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExternalId {
    fn default() -> &'a ExternalId {
        <ExternalId as ::protobuf::Message>::default_instance()
    }
}

impl ExternalId {
    pub fn new() -> ExternalId {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ExternalId| { &m.type_ },
            |m: &mut ExternalId| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ExternalId| { &m.id },
            |m: &mut ExternalId| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalId>(
            "ExternalId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExternalId {
    const NAME: &'static str = "ExternalId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExternalId {
        ExternalId::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExternalId {
        static instance: ExternalId = ExternalId {
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExternalId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExternalId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExternalId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.AudioFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioFile {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.AudioFile.file_id)
    pub file_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.metadata.AudioFile.format)
    pub format: ::std::option::Option<::protobuf::EnumOrUnknown<audio_file::Format>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.AudioFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioFile {
    fn default() -> &'a AudioFile {
        <AudioFile as ::protobuf::Message>::default_instance()
    }
}

impl AudioFile {
    pub fn new() -> AudioFile {
        ::std::default::Default::default()
    }

    // optional bytes file_id = 1;

    pub fn file_id(&self) -> &[u8] {
        match self.file_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_file_id(&mut self) {
        self.file_id = ::std::option::Option::None;
    }

    pub fn has_file_id(&self) -> bool {
        self.file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.file_id.is_none() {
            self.file_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_id(&mut self) -> ::std::vec::Vec<u8> {
        self.file_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .spotify.metadata.AudioFile.Format format = 2;

    pub fn format(&self) -> audio_file::Format {
        match self.format {
            Some(e) => e.enum_value_or(audio_file::Format::OGG_VORBIS_96),
            None => audio_file::Format::OGG_VORBIS_96,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: audio_file::Format) {
        self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_id",
            |m: &AudioFile| { &m.file_id },
            |m: &mut AudioFile| { &mut m.file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &AudioFile| { &m.format },
            |m: &mut AudioFile| { &mut m.format },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFile>(
            "AudioFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioFile {
    const NAME: &'static str = "AudioFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_id.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.format {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioFile {
        AudioFile::new()
    }

    fn clear(&mut self) {
        self.file_id = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioFile {
        static instance: AudioFile = AudioFile {
            file_id: ::std::option::Option::None,
            format: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AudioFile`
pub mod audio_file {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.metadata.AudioFile.Format)
    pub enum Format {
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.OGG_VORBIS_96)
        OGG_VORBIS_96 = 0,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.OGG_VORBIS_160)
        OGG_VORBIS_160 = 1,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.OGG_VORBIS_320)
        OGG_VORBIS_320 = 2,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.MP3_256)
        MP3_256 = 3,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.MP3_320)
        MP3_320 = 4,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.MP3_160)
        MP3_160 = 5,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.MP3_96)
        MP3_96 = 6,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.MP3_160_ENC)
        MP3_160_ENC = 7,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.AAC_24)
        AAC_24 = 8,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.AAC_48)
        AAC_48 = 9,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.FLAC_FLAC)
        FLAC_FLAC = 16,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.XHE_AAC_24)
        XHE_AAC_24 = 18,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.XHE_AAC_16)
        XHE_AAC_16 = 19,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.XHE_AAC_12)
        XHE_AAC_12 = 20,
        // @@protoc_insertion_point(enum_value:spotify.metadata.AudioFile.Format.FLAC_FLAC_24BIT)
        FLAC_FLAC_24BIT = 22,
    }

    impl ::protobuf::Enum for Format {
        const NAME: &'static str = "Format";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Format> {
            match value {
                0 => ::std::option::Option::Some(Format::OGG_VORBIS_96),
                1 => ::std::option::Option::Some(Format::OGG_VORBIS_160),
                2 => ::std::option::Option::Some(Format::OGG_VORBIS_320),
                3 => ::std::option::Option::Some(Format::MP3_256),
                4 => ::std::option::Option::Some(Format::MP3_320),
                5 => ::std::option::Option::Some(Format::MP3_160),
                6 => ::std::option::Option::Some(Format::MP3_96),
                7 => ::std::option::Option::Some(Format::MP3_160_ENC),
                8 => ::std::option::Option::Some(Format::AAC_24),
                9 => ::std::option::Option::Some(Format::AAC_48),
                16 => ::std::option::Option::Some(Format::FLAC_FLAC),
                18 => ::std::option::Option::Some(Format::XHE_AAC_24),
                19 => ::std::option::Option::Some(Format::XHE_AAC_16),
                20 => ::std::option::Option::Some(Format::XHE_AAC_12),
                22 => ::std::option::Option::Some(Format::FLAC_FLAC_24BIT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Format> {
            match str {
                "OGG_VORBIS_96" => ::std::option::Option::Some(Format::OGG_VORBIS_96),
                "OGG_VORBIS_160" => ::std::option::Option::Some(Format::OGG_VORBIS_160),
                "OGG_VORBIS_320" => ::std::option::Option::Some(Format::OGG_VORBIS_320),
                "MP3_256" => ::std::option::Option::Some(Format::MP3_256),
                "MP3_320" => ::std::option::Option::Some(Format::MP3_320),
                "MP3_160" => ::std::option::Option::Some(Format::MP3_160),
                "MP3_96" => ::std::option::Option::Some(Format::MP3_96),
                "MP3_160_ENC" => ::std::option::Option::Some(Format::MP3_160_ENC),
                "AAC_24" => ::std::option::Option::Some(Format::AAC_24),
                "AAC_48" => ::std::option::Option::Some(Format::AAC_48),
                "FLAC_FLAC" => ::std::option::Option::Some(Format::FLAC_FLAC),
                "XHE_AAC_24" => ::std::option::Option::Some(Format::XHE_AAC_24),
                "XHE_AAC_16" => ::std::option::Option::Some(Format::XHE_AAC_16),
                "XHE_AAC_12" => ::std::option::Option::Some(Format::XHE_AAC_12),
                "FLAC_FLAC_24BIT" => ::std::option::Option::Some(Format::FLAC_FLAC_24BIT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Format] = &[
            Format::OGG_VORBIS_96,
            Format::OGG_VORBIS_160,
            Format::OGG_VORBIS_320,
            Format::MP3_256,
            Format::MP3_320,
            Format::MP3_160,
            Format::MP3_96,
            Format::MP3_160_ENC,
            Format::AAC_24,
            Format::AAC_48,
            Format::FLAC_FLAC,
            Format::XHE_AAC_24,
            Format::XHE_AAC_16,
            Format::XHE_AAC_12,
            Format::FLAC_FLAC_24BIT,
        ];
    }

    impl ::protobuf::EnumFull for Format {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AudioFile.Format").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Format::OGG_VORBIS_96 => 0,
                Format::OGG_VORBIS_160 => 1,
                Format::OGG_VORBIS_320 => 2,
                Format::MP3_256 => 3,
                Format::MP3_320 => 4,
                Format::MP3_160 => 5,
                Format::MP3_96 => 6,
                Format::MP3_160_ENC => 7,
                Format::AAC_24 => 8,
                Format::AAC_48 => 9,
                Format::FLAC_FLAC => 10,
                Format::XHE_AAC_24 => 11,
                Format::XHE_AAC_16 => 12,
                Format::XHE_AAC_12 => 13,
                Format::FLAC_FLAC_24BIT => 14,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Format {
        fn default() -> Self {
            Format::OGG_VORBIS_96
        }
    }

    impl Format {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Format>("AudioFile.Format")
        }
    }
}

// @@protoc_insertion_point(message:spotify.metadata.Video)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Video {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.Video.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.Video.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Video {
    fn default() -> &'a Video {
        <Video as ::protobuf::Message>::default_instance()
    }
}

impl Video {
    pub fn new() -> Video {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &Video| { &m.gid },
            |m: &mut Video| { &mut m.gid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Video>(
            "Video",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Video {
    const NAME: &'static str = "Video";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Video {
        Video::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Video {
        static instance: Video = Video {
            gid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Video {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Video").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Video {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Video {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.VideoFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VideoFile {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.VideoFile.file_id)
    pub file_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.VideoFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoFile {
    fn default() -> &'a VideoFile {
        <VideoFile as ::protobuf::Message>::default_instance()
    }
}

impl VideoFile {
    pub fn new() -> VideoFile {
        ::std::default::Default::default()
    }

    // optional bytes file_id = 1;

    pub fn file_id(&self) -> &[u8] {
        match self.file_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_file_id(&mut self) {
        self.file_id = ::std::option::Option::None;
    }

    pub fn has_file_id(&self) -> bool {
        self.file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.file_id.is_none() {
            self.file_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_id(&mut self) -> ::std::vec::Vec<u8> {
        self.file_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_id",
            |m: &VideoFile| { &m.file_id },
            |m: &mut VideoFile| { &mut m.file_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoFile>(
            "VideoFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoFile {
    const NAME: &'static str = "VideoFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_id.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoFile {
        VideoFile::new()
    }

    fn clear(&mut self) {
        self.file_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoFile {
        static instance: VideoFile = VideoFile {
            file_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.metadata.ContentRating)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContentRating {
    // message fields
    // @@protoc_insertion_point(field:spotify.metadata.ContentRating.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.metadata.ContentRating.tag)
    pub tag: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.metadata.ContentRating.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentRating {
    fn default() -> &'a ContentRating {
        <ContentRating as ::protobuf::Message>::default_instance()
    }
}

impl ContentRating {
    pub fn new() -> ContentRating {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &ContentRating| { &m.country },
            |m: &mut ContentRating| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tag",
            |m: &ContentRating| { &m.tag },
            |m: &mut ContentRating| { &mut m.tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentRating>(
            "ContentRating",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentRating {
    const NAME: &'static str = "ContentRating";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.tag.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.tag {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.tag {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentRating {
        ContentRating::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.tag.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentRating {
        static instance: ContentRating = ContentRating {
            country: ::std::option::Option::None,
            tag: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentRating {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentRating").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentRating {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0emetadata.proto\x12\x10spotify.metadata\"\x8f\x08\n\x06Artist\x12\
    \x10\n\x03gid\x18\x01\x20\x01(\x0cR\x03gid\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x1e\n\npopularity\x18\x03\x20\x01(\x11R\npopularity\
    \x128\n\ttop_track\x18\x04\x20\x03(\x0b2\x1b.spotify.metadata.TopTracksR\
    \x08topTrack\x12=\n\x0balbum_group\x18\x05\x20\x03(\x0b2\x1c.spotify.met\
    adata.AlbumGroupR\nalbumGroup\x12?\n\x0csingle_group\x18\x06\x20\x03(\
    \x0b2\x1c.spotify.metadata.AlbumGroupR\x0bsingleGroup\x12I\n\x11compilat\
    ion_group\x18\x07\x20\x03(\x0b2\x1c.spotify.metadata.AlbumGroupR\x10comp\
    ilationGroup\x12F\n\x10appears_on_group\x18\x08\x20\x03(\x0b2\x1c.spotif\
    y.metadata.AlbumGroupR\x0eappearsOnGroup\x12=\n\x0bexternal_id\x18\n\x20\
    \x03(\x0b2\x1c.spotify.metadata.ExternalIdR\nexternalId\x123\n\x08portra\
    it\x18\x0b\x20\x03(\x0b2\x17.spotify.metadata.ImageR\x08portrait\x129\n\
    \tbiography\x18\x0c\x20\x03(\x0b2\x1b.spotify.metadata.BiographyR\tbiogr\
    aphy\x12I\n\x0factivity_period\x18\r\x20\x03(\x0b2\x20.spotify.metadata.\
    ActivityPeriodR\x0eactivityPeriod\x12?\n\x0brestriction\x18\x0e\x20\x03(\
    \x0b2\x1d.spotify.metadata.RestrictionR\x0brestriction\x122\n\x07related\
    \x18\x0f\x20\x03(\x0b2\x18.spotify.metadata.ArtistR\x07related\x125\n\
    \x17is_portrait_album_cover\x18\x10\x20\x01(\x08R\x14isPortraitAlbumCove\
    r\x12C\n\x0eportrait_group\x18\x11\x20\x01(\x0b2\x1c.spotify.metadata.Im\
    ageGroupR\rportraitGroup\x12=\n\x0bsale_period\x18\x12\x20\x03(\x0b2\x1c\
    .spotify.metadata.SalePeriodR\nsalePeriod\x12B\n\x0cavailability\x18\x14\
    \x20\x03(\x0b2\x1e.spotify.metadata.AvailabilityR\x0cavailabilityJ\x04\
    \x08\t\x10\n\"\xd7\x07\n\x05Album\x12\x10\n\x03gid\x18\x01\x20\x01(\x0cR\
    \x03gid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x120\n\x06artist\
    \x18\x03\x20\x03(\x0b2\x18.spotify.metadata.ArtistR\x06artist\x120\n\x04\
    type\x18\x04\x20\x01(\x0e2\x1c.spotify.metadata.Album.TypeR\x04type\x12\
    \x14\n\x05label\x18\x05\x20\x01(\tR\x05label\x12*\n\x04date\x18\x06\x20\
    \x01(\x0b2\x16.spotify.metadata.DateR\x04date\x12\x1e\n\npopularity\x18\
    \x07\x20\x01(\x11R\npopularity\x12-\n\x05cover\x18\t\x20\x03(\x0b2\x17.s\
    potify.metadata.ImageR\x05cover\x12=\n\x0bexternal_id\x18\n\x20\x03(\x0b\
    2\x1c.spotify.metadata.ExternalIdR\nexternalId\x12*\n\x04disc\x18\x0b\
    \x20\x03(\x0b2\x16.spotify.metadata.DiscR\x04disc\x12\x16\n\x06review\
    \x18\x0c\x20\x03(\tR\x06review\x129\n\tcopyright\x18\r\x20\x03(\x0b2\x1b\
    .spotify.metadata.CopyrightR\tcopyright\x12?\n\x0brestriction\x18\x0e\
    \x20\x03(\x0b2\x1d.spotify.metadata.RestrictionR\x0brestriction\x121\n\
    \x07related\x18\x0f\x20\x03(\x0b2\x17.spotify.metadata.AlbumR\x07related\
    \x12=\n\x0bsale_period\x18\x10\x20\x03(\x0b2\x1c.spotify.metadata.SalePe\
    riodR\nsalePeriod\x12=\n\x0bcover_group\x18\x11\x20\x01(\x0b2\x1c.spotif\
    y.metadata.ImageGroupR\ncoverGroup\x12%\n\x0eoriginal_title\x18\x12\x20\
    \x01(\tR\roriginalTitle\x12#\n\rversion_title\x18\x13\x20\x01(\tR\x0cver\
    sionTitle\x12\x19\n\x08type_str\x18\x14\x20\x01(\tR\x07typeStr\x12B\n\
    \x0cavailability\x18\x17\x20\x03(\x0b2\x1e.spotify.metadata.Availability\
    R\x0cavailability\"R\n\x04Type\x12\t\n\x05ALBUM\x10\x01\x12\n\n\x06SINGL\
    E\x10\x02\x12\x0f\n\x0bCOMPILATION\x10\x03\x12\x06\n\x02EP\x10\x04\x12\r\
    \n\tAUDIOBOOK\x10\x05\x12\x0b\n\x07PODCAST\x10\x06J\x04\x08\x08\x10\t\"\
    \xa5\n\n\x05Track\x12\x10\n\x03gid\x18\x01\x20\x01(\x0cR\x03gid\x12\x12\
    \n\x04name\x18\x02\x20\x01(\tR\x04name\x12-\n\x05album\x18\x03\x20\x01(\
    \x0b2\x17.spotify.metadata.AlbumR\x05album\x120\n\x06artist\x18\x04\x20\
    \x03(\x0b2\x18.spotify.metadata.ArtistR\x06artist\x12\x16\n\x06number\
    \x18\x05\x20\x01(\x11R\x06number\x12\x1f\n\x0bdisc_number\x18\x06\x20\
    \x01(\x11R\ndiscNumber\x12\x1a\n\x08duration\x18\x07\x20\x01(\x11R\x08du\
    ration\x12\x1e\n\npopularity\x18\x08\x20\x01(\x11R\npopularity\x12\x1a\n\
    \x08explicit\x18\t\x20\x01(\x08R\x08explicit\x12=\n\x0bexternal_id\x18\n\
    \x20\x03(\x0b2\x1c.spotify.metadata.ExternalIdR\nexternalId\x12?\n\x0bre\
    striction\x18\x0b\x20\x03(\x0b2\x1d.spotify.metadata.RestrictionR\x0bres\
    triction\x12/\n\x04file\x18\x0c\x20\x03(\x0b2\x1b.spotify.metadata.Audio\
    FileR\x04file\x129\n\x0balternative\x18\r\x20\x03(\x0b2\x17.spotify.meta\
    data.TrackR\x0balternative\x12=\n\x0bsale_period\x18\x0e\x20\x03(\x0b2\
    \x1c.spotify.metadata.SalePeriodR\nsalePeriod\x125\n\x07preview\x18\x0f\
    \x20\x03(\x0b2\x1b.spotify.metadata.AudioFileR\x07preview\x12\x12\n\x04t\
    ags\x18\x10\x20\x03(\tR\x04tags\x126\n\x17earliest_live_timestamp\x18\
    \x11\x20\x01(\x03R\x15earliestLiveTimestamp\x12\x1d\n\nhas_lyrics\x18\
    \x12\x20\x01(\x08R\thasLyrics\x12B\n\x0cavailability\x18\x13\x20\x03(\
    \x0b2\x1e.spotify.metadata.AvailabilityR\x0cavailability\x126\n\x08licen\
    sor\x18\x15\x20\x01(\x0b2\x1a.spotify.metadata.LicensorR\x08licensor\x12\
    6\n\x17language_of_performance\x18\x16\x20\x03(\tR\x15languageOfPerforma\
    nce\x12>\n\x0eoriginal_audio\x18\x18\x20\x01(\x0b2\x17.spotify.metadata.\
    AudioR\roriginalAudio\x12F\n\x0econtent_rating\x18\x19\x20\x03(\x0b2\x1f\
    .spotify.metadata.ContentRatingR\rcontentRating\x12%\n\x0eoriginal_title\
    \x18\x1b\x20\x01(\tR\roriginalTitle\x12#\n\rversion_title\x18\x1c\x20\
    \x01(\tR\x0cversionTitle\x12J\n\x10artist_with_role\x18\x20\x20\x03(\x0b\
    2\x20.spotify.metadata.ArtistWithRoleR\x0eartistWithRole\x12#\n\rcanonic\
    al_uri\x18$\x20\x01(\tR\x0ccanonicalUri\x12>\n\x0eoriginal_video\x18&\
    \x20\x03(\x0b2\x17.spotify.metadata.VideoR\roriginalVideo\"\xf7\x02\n\
    \x0eArtistWithRole\x12\x1d\n\nartist_gid\x18\x01\x20\x01(\x0cR\tartistGi\
    d\x12\x1f\n\x0bartist_name\x18\x02\x20\x01(\tR\nartistName\x12?\n\x04rol\
    e\x18\x03\x20\x01(\x0e2+.spotify.metadata.ArtistWithRole.ArtistRoleR\x04\
    role\"\xe3\x01\n\nArtistRole\x12\x17\n\x13ARTIST_ROLE_UNKNOWN\x10\0\x12\
    \x1b\n\x17ARTIST_ROLE_MAIN_ARTIST\x10\x01\x12\x1f\n\x1bARTIST_ROLE_FEATU\
    RED_ARTIST\x10\x02\x12\x17\n\x13ARTIST_ROLE_REMIXER\x10\x03\x12\x15\n\
    \x11ARTIST_ROLE_ACTOR\x10\x04\x12\x18\n\x14ARTIST_ROLE_COMPOSER\x10\x05\
    \x12\x19\n\x15ARTIST_ROLE_CONDUCTOR\x10\x06\x12\x19\n\x15ARTIST_ROLE_ORC\
    HESTRA\x10\x07\"\xc2\x07\n\x04Show\x12\x10\n\x03gid\x18\x01\x20\x01(\x0c\
    R\x03gid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bdesc\
    ription\x18@\x20\x01(\tR\x0bdescription\x123\n\x15deprecated_popularity\
    \x18A\x20\x01(\x11R\x14deprecatedPopularity\x12\x1c\n\tpublisher\x18B\
    \x20\x01(\tR\tpublisher\x12\x1a\n\x08language\x18C\x20\x01(\tR\x08langua\
    ge\x12\x1a\n\x08explicit\x18D\x20\x01(\x08R\x08explicit\x12=\n\x0bcover_\
    image\x18E\x20\x01(\x0b2\x1c.spotify.metadata.ImageGroupR\ncoverImage\
    \x123\n\x07episode\x18F\x20\x03(\x0b2\x19.spotify.metadata.EpisodeR\x07e\
    pisode\x129\n\tcopyright\x18G\x20\x03(\x0b2\x1b.spotify.metadata.Copyrig\
    htR\tcopyright\x12?\n\x0brestriction\x18H\x20\x03(\x0b2\x1d.spotify.meta\
    data.RestrictionR\x0brestriction\x12\x18\n\x07keyword\x18I\x20\x03(\tR\
    \x07keyword\x12?\n\nmedia_type\x18J\x20\x01(\x0e2\x20.spotify.metadata.S\
    how.MediaTypeR\tmediaType\x12T\n\x11consumption_order\x18K\x20\x01(\x0e2\
    '.spotify.metadata.Show.ConsumptionOrderR\x10consumptionOrder\x12B\n\x0c\
    availability\x18N\x20\x03(\x0b2\x1e.spotify.metadata.AvailabilityR\x0cav\
    ailability\x12\x1f\n\x0btrailer_uri\x18S\x20\x01(\tR\ntrailerUri\x12$\n\
    \x0emusic_and_talk\x18U\x20\x01(\x08R\x0cmusicAndTalk\x12!\n\x0cis_audio\
    book\x18Y\x20\x01(\x08R\x0bisAudiobook\x12,\n\x12is_creator_channel\x18Z\
    \x20\x01(\x08R\x10isCreatorChannel\",\n\tMediaType\x12\t\n\x05MIXED\x10\
    \0\x12\t\n\x05AUDIO\x10\x01\x12\t\n\x05VIDEO\x10\x02\"<\n\x10Consumption\
    Order\x12\x0e\n\nSEQUENTIAL\x10\x01\x12\x0c\n\x08EPISODIC\x10\x02\x12\n\
    \n\x06RECENT\x10\x03\"\xb7\n\n\x07Episode\x12\x10\n\x03gid\x18\x01\x20\
    \x01(\x0cR\x03gid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1a\
    \n\x08duration\x18\x07\x20\x01(\x11R\x08duration\x121\n\x05audio\x18\x0c\
    \x20\x03(\x0b2\x1b.spotify.metadata.AudioFileR\x05audio\x12\x20\n\x0bdes\
    cription\x18@\x20\x01(\tR\x0bdescription\x12\x16\n\x06number\x18A\x20\
    \x01(\x11R\x06number\x129\n\x0cpublish_time\x18B\x20\x01(\x0b2\x16.spoti\
    fy.metadata.DateR\x0bpublishTime\x123\n\x15deprecated_popularity\x18C\
    \x20\x01(\x11R\x14deprecatedPopularity\x12=\n\x0bcover_image\x18D\x20\
    \x01(\x0b2\x1c.spotify.metadata.ImageGroupR\ncoverImage\x12\x1a\n\x08lan\
    guage\x18E\x20\x01(\tR\x08language\x12\x1a\n\x08explicit\x18F\x20\x01(\
    \x08R\x08explicit\x12*\n\x04show\x18G\x20\x01(\x0b2\x16.spotify.metadata\
    .ShowR\x04show\x121\n\x05video\x18H\x20\x03(\x0b2\x1b.spotify.metadata.V\
    ideoFileR\x05video\x12@\n\rvideo_preview\x18I\x20\x03(\x0b2\x1b.spotify.\
    metadata.VideoFileR\x0cvideoPreview\x12@\n\raudio_preview\x18J\x20\x03(\
    \x0b2\x1b.spotify.metadata.AudioFileR\x0caudioPreview\x12?\n\x0brestrict\
    ion\x18K\x20\x03(\x0b2\x1d.spotify.metadata.RestrictionR\x0brestriction\
    \x12?\n\x0cfreeze_frame\x18L\x20\x01(\x0b2\x1c.spotify.metadata.ImageGro\
    upR\x0bfreezeFrame\x12\x18\n\x07keyword\x18M\x20\x03(\tR\x07keyword\x12:\
    \n\x19allow_background_playback\x18Q\x20\x01(\x08R\x17allowBackgroundPla\
    yback\x12B\n\x0cavailability\x18R\x20\x03(\x0b2\x1e.spotify.metadata.Ava\
    ilabilityR\x0cavailability\x12!\n\x0cexternal_url\x18S\x20\x01(\tR\x0bex\
    ternalUrl\x12>\n\x0eoriginal_audio\x18T\x20\x01(\x0b2\x17.spotify.metada\
    ta.AudioR\roriginalAudio\x129\n\x04type\x18W\x20\x01(\x0e2%.spotify.meta\
    data.Episode.EpisodeTypeR\x04type\x12$\n\x0emusic_and_talk\x18[\x20\x01(\
    \x08R\x0cmusicAndTalk\x12F\n\x0econtent_rating\x18_\x20\x03(\x0b2\x1f.sp\
    otify.metadata.ContentRatingR\rcontentRating\x120\n\x14is_audiobook_chap\
    ter\x18`\x20\x01(\x08R\x12isAudiobookChapter\x12(\n\x10is_podcast_short\
    \x18a\x20\x01(\x08R\x0eisPodcastShort\"/\n\x0bEpisodeType\x12\x08\n\x04F\
    ULL\x10\0\x12\x0b\n\x07TRAILER\x10\x01\x12\t\n\x05BONUS\x10\x02\"\x1e\n\
    \x08Licensor\x12\x12\n\x04uuid\x18\x01\x20\x01(\x0cR\x04uuid\"\x1b\n\x05\
    Audio\x12\x12\n\x04uuid\x18\x01\x20\x01(\x0cR\x04uuid\"T\n\tTopTracks\
    \x12\x18\n\x07country\x18\x01\x20\x01(\tR\x07country\x12-\n\x05track\x18\
    \x02\x20\x03(\x0b2\x17.spotify.metadata.TrackR\x05track\"b\n\x0eActivity\
    Period\x12\x1d\n\nstart_year\x18\x01\x20\x01(\x11R\tstartYear\x12\x19\n\
    \x08end_year\x18\x02\x20\x01(\x11R\x07endYear\x12\x16\n\x06decade\x18\
    \x03\x20\x01(\x11R\x06decade\";\n\nAlbumGroup\x12-\n\x05album\x18\x01\
    \x20\x03(\x0b2\x17.spotify.metadata.AlbumR\x05album\"n\n\x04Date\x12\x12\
    \n\x04year\x18\x01\x20\x01(\x11R\x04year\x12\x14\n\x05month\x18\x02\x20\
    \x01(\x11R\x05month\x12\x10\n\x03day\x18\x03\x20\x01(\x11R\x03day\x12\
    \x12\n\x04hour\x18\x04\x20\x01(\x11R\x04hour\x12\x16\n\x06minute\x18\x05\
    \x20\x01(\x11R\x06minute\"\xb7\x01\n\x05Image\x12\x17\n\x07file_id\x18\
    \x01\x20\x01(\x0cR\x06fileId\x120\n\x04size\x18\x02\x20\x01(\x0e2\x1c.sp\
    otify.metadata.Image.SizeR\x04size\x12\x14\n\x05width\x18\x03\x20\x01(\
    \x11R\x05width\x12\x16\n\x06height\x18\x04\x20\x01(\x11R\x06height\"5\n\
    \x04Size\x12\x0b\n\x07DEFAULT\x10\0\x12\t\n\x05SMALL\x10\x01\x12\t\n\x05\
    LARGE\x10\x02\x12\n\n\x06XLARGE\x10\x03\";\n\nImageGroup\x12-\n\x05image\
    \x18\x01\x20\x03(\x0b2\x17.spotify.metadata.ImageR\x05image\"\x99\x01\n\
    \tBiography\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\x123\n\x08port\
    rait\x18\x02\x20\x03(\x0b2\x17.spotify.metadata.ImageR\x08portrait\x12C\
    \n\x0eportrait_group\x18\x03\x20\x03(\x0b2\x1c.spotify.metadata.ImageGro\
    upR\rportraitGroup\"a\n\x04Disc\x12\x16\n\x06number\x18\x01\x20\x01(\x11\
    R\x06number\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12-\n\x05trac\
    k\x18\x03\x20\x03(\x0b2\x17.spotify.metadata.TrackR\x05track\"k\n\tCopyr\
    ight\x124\n\x04type\x18\x01\x20\x01(\x0e2\x20.spotify.metadata.Copyright\
    .TypeR\x04type\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"\x14\n\x04\
    Type\x12\x05\n\x01P\x10\0\x12\x05\n\x01C\x10\x01\"\x98\x03\n\x0bRestrict\
    ion\x12E\n\tcatalogue\x18\x01\x20\x03(\x0e2'.spotify.metadata.Restrictio\
    n.CatalogueR\tcatalogue\x126\n\x04type\x18\x04\x20\x01(\x0e2\".spotify.m\
    etadata.Restriction.TypeR\x04type\x12#\n\rcatalogue_str\x18\x05\x20\x03(\
    \tR\x0ccatalogueStr\x12-\n\x11countries_allowed\x18\x02\x20\x01(\tH\0R\
    \x10countriesAllowed\x121\n\x13countries_forbidden\x18\x03\x20\x01(\tH\0\
    R\x12countriesForbidden\"U\n\tCatalogue\x12\x06\n\x02AD\x10\0\x12\x10\n\
    \x0cSUBSCRIPTION\x10\x01\x12\x11\n\rCATALOGUE_ALL\x10\x02\x12\x0b\n\x07S\
    HUFFLE\x10\x03\x12\x0e\n\nCOMMERCIAL\x10\x04\"\x15\n\x04Type\x12\r\n\tST\
    REAMING\x10\0B\x15\n\x13country_restriction\"a\n\x0cAvailability\x12#\n\
    \rcatalogue_str\x18\x01\x20\x03(\tR\x0ccatalogueStr\x12,\n\x05start\x18\
    \x02\x20\x01(\x0b2\x16.spotify.metadata.DateR\x05start\"\xa5\x01\n\nSale\
    Period\x12?\n\x0brestriction\x18\x01\x20\x03(\x0b2\x1d.spotify.metadata.\
    RestrictionR\x0brestriction\x12,\n\x05start\x18\x02\x20\x01(\x0b2\x16.sp\
    otify.metadata.DateR\x05start\x12(\n\x03end\x18\x03\x20\x01(\x0b2\x16.sp\
    otify.metadata.DateR\x03end\"0\n\nExternalId\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\xd6\x02\
    \n\tAudioFile\x12\x17\n\x07file_id\x18\x01\x20\x01(\x0cR\x06fileId\x12:\
    \n\x06format\x18\x02\x20\x01(\x0e2\".spotify.metadata.AudioFile.FormatR\
    \x06format\"\xf3\x01\n\x06Format\x12\x11\n\rOGG_VORBIS_96\x10\0\x12\x12\
    \n\x0eOGG_VORBIS_160\x10\x01\x12\x12\n\x0eOGG_VORBIS_320\x10\x02\x12\x0b\
    \n\x07MP3_256\x10\x03\x12\x0b\n\x07MP3_320\x10\x04\x12\x0b\n\x07MP3_160\
    \x10\x05\x12\n\n\x06MP3_96\x10\x06\x12\x0f\n\x0bMP3_160_ENC\x10\x07\x12\
    \n\n\x06AAC_24\x10\x08\x12\n\n\x06AAC_48\x10\t\x12\r\n\tFLAC_FLAC\x10\
    \x10\x12\x0e\n\nXHE_AAC_24\x10\x12\x12\x0e\n\nXHE_AAC_16\x10\x13\x12\x0e\
    \n\nXHE_AAC_12\x10\x14\x12\x13\n\x0fFLAC_FLAC_24BIT\x10\x16\"\x19\n\x05V\
    ideo\x12\x10\n\x03gid\x18\x01\x20\x01(\x0cR\x03gid\"$\n\tVideoFile\x12\
    \x17\n\x07file_id\x18\x01\x20\x01(\x0cR\x06fileId\";\n\rContentRating\
    \x12\x18\n\x07country\x18\x01\x20\x01(\tR\x07country\x12\x10\n\x03tag\
    \x18\x02\x20\x03(\tR\x03tagB(\n\x1acom.spotify.metadata.protoB\x08Metada\
    taH\x02b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(25);
            messages.push(Artist::generated_message_descriptor_data());
            messages.push(Album::generated_message_descriptor_data());
            messages.push(Track::generated_message_descriptor_data());
            messages.push(ArtistWithRole::generated_message_descriptor_data());
            messages.push(Show::generated_message_descriptor_data());
            messages.push(Episode::generated_message_descriptor_data());
            messages.push(Licensor::generated_message_descriptor_data());
            messages.push(Audio::generated_message_descriptor_data());
            messages.push(TopTracks::generated_message_descriptor_data());
            messages.push(ActivityPeriod::generated_message_descriptor_data());
            messages.push(AlbumGroup::generated_message_descriptor_data());
            messages.push(Date::generated_message_descriptor_data());
            messages.push(Image::generated_message_descriptor_data());
            messages.push(ImageGroup::generated_message_descriptor_data());
            messages.push(Biography::generated_message_descriptor_data());
            messages.push(Disc::generated_message_descriptor_data());
            messages.push(Copyright::generated_message_descriptor_data());
            messages.push(Restriction::generated_message_descriptor_data());
            messages.push(Availability::generated_message_descriptor_data());
            messages.push(SalePeriod::generated_message_descriptor_data());
            messages.push(ExternalId::generated_message_descriptor_data());
            messages.push(AudioFile::generated_message_descriptor_data());
            messages.push(Video::generated_message_descriptor_data());
            messages.push(VideoFile::generated_message_descriptor_data());
            messages.push(ContentRating::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(album::Type::generated_enum_descriptor_data());
            enums.push(artist_with_role::ArtistRole::generated_enum_descriptor_data());
            enums.push(show::MediaType::generated_enum_descriptor_data());
            enums.push(show::ConsumptionOrder::generated_enum_descriptor_data());
            enums.push(episode::EpisodeType::generated_enum_descriptor_data());
            enums.push(image::Size::generated_enum_descriptor_data());
            enums.push(copyright::Type::generated_enum_descriptor_data());
            enums.push(restriction::Catalogue::generated_enum_descriptor_data());
            enums.push(restriction::Type::generated_enum_descriptor_data());
            enums.push(audio_file::Format::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
