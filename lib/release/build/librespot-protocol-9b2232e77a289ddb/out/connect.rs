// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `connect.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.connectstate.ClusterUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterUpdate {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.cluster)
    pub cluster: ::protobuf::MessageField<Cluster>,
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.update_reason)
    pub update_reason: ::protobuf::EnumOrUnknown<ClusterUpdateReason>,
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.ack_id)
    pub ack_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.devices_that_changed)
    pub devices_that_changed: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.ClusterUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterUpdate {
    fn default() -> &'a ClusterUpdate {
        <ClusterUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ClusterUpdate {
    pub fn new() -> ClusterUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Cluster>(
            "cluster",
            |m: &ClusterUpdate| { &m.cluster },
            |m: &mut ClusterUpdate| { &mut m.cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "update_reason",
            |m: &ClusterUpdate| { &m.update_reason },
            |m: &mut ClusterUpdate| { &mut m.update_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_id",
            |m: &ClusterUpdate| { &m.ack_id },
            |m: &mut ClusterUpdate| { &mut m.ack_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices_that_changed",
            |m: &ClusterUpdate| { &m.devices_that_changed },
            |m: &mut ClusterUpdate| { &mut m.devices_that_changed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterUpdate>(
            "ClusterUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterUpdate {
    const NAME: &'static str = "ClusterUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cluster)?;
                },
                16 => {
                    self.update_reason = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.ack_id = is.read_string()?;
                },
                34 => {
                    self.devices_that_changed.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cluster.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.update_reason != ::protobuf::EnumOrUnknown::new(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON) {
            my_size += ::protobuf::rt::int32_size(2, self.update_reason.value());
        }
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ack_id);
        }
        for value in &self.devices_that_changed {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cluster.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.update_reason != ::protobuf::EnumOrUnknown::new(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.update_reason))?;
        }
        if !self.ack_id.is_empty() {
            os.write_string(3, &self.ack_id)?;
        }
        for v in &self.devices_that_changed {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterUpdate {
        ClusterUpdate::new()
    }

    fn clear(&mut self) {
        self.cluster.clear();
        self.update_reason = ::protobuf::EnumOrUnknown::new(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON);
        self.ack_id.clear();
        self.devices_that_changed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterUpdate {
        static instance: ClusterUpdate = ClusterUpdate {
            cluster: ::protobuf::MessageField::none(),
            update_reason: ::protobuf::EnumOrUnknown::from_i32(0),
            ack_id: ::std::string::String::new(),
            devices_that_changed: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.Device)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Device {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.Device.device_info)
    pub device_info: ::protobuf::MessageField<DeviceInfo>,
    // @@protoc_insertion_point(field:spotify.connectstate.Device.player_state)
    pub player_state: ::protobuf::MessageField<super::player::PlayerState>,
    // @@protoc_insertion_point(field:spotify.connectstate.Device.private_device_info)
    pub private_device_info: ::protobuf::MessageField<PrivateDeviceInfo>,
    // @@protoc_insertion_point(field:spotify.connectstate.Device.transfer_data)
    pub transfer_data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.Device.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceInfo>(
            "device_info",
            |m: &Device| { &m.device_info },
            |m: &mut Device| { &mut m.device_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::player::PlayerState>(
            "player_state",
            |m: &Device| { &m.player_state },
            |m: &mut Device| { &mut m.player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PrivateDeviceInfo>(
            "private_device_info",
            |m: &Device| { &m.private_device_info },
            |m: &mut Device| { &mut m.private_device_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transfer_data",
            |m: &Device| { &m.transfer_data },
            |m: &mut Device| { &mut m.transfer_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
            "Device",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Device {
    const NAME: &'static str = "Device";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.device_info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.private_device_info)?;
                },
                34 => {
                    self.transfer_data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.private_device_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.transfer_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.transfer_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.player_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.private_device_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.transfer_data.is_empty() {
            os.write_bytes(4, &self.transfer_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Device {
        Device::new()
    }

    fn clear(&mut self) {
        self.device_info.clear();
        self.player_state.clear();
        self.private_device_info.clear();
        self.transfer_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Device {
        static instance: Device = Device {
            device_info: ::protobuf::MessageField::none(),
            player_state: ::protobuf::MessageField::none(),
            private_device_info: ::protobuf::MessageField::none(),
            transfer_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Device {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Device").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.Cluster)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cluster {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.changed_timestamp_ms)
    pub changed_timestamp_ms: i64,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.active_device_id)
    pub active_device_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.player_state)
    pub player_state: ::protobuf::MessageField<super::player::PlayerState>,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.device)
    pub device: ::std::collections::HashMap<::std::string::String, DeviceInfo>,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.transfer_data)
    pub transfer_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.transfer_data_timestamp)
    pub transfer_data_timestamp: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.need_full_player_state)
    pub need_full_player_state: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.server_timestamp_ms)
    pub server_timestamp_ms: i64,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.needs_state_updates)
    pub needs_state_updates: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.started_playing_at_timestamp)
    pub started_playing_at_timestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.Cluster.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cluster {
    fn default() -> &'a Cluster {
        <Cluster as ::protobuf::Message>::default_instance()
    }
}

impl Cluster {
    pub fn new() -> Cluster {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "changed_timestamp_ms",
            |m: &Cluster| { &m.changed_timestamp_ms },
            |m: &mut Cluster| { &mut m.changed_timestamp_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_device_id",
            |m: &Cluster| { &m.active_device_id },
            |m: &mut Cluster| { &mut m.active_device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::player::PlayerState>(
            "player_state",
            |m: &Cluster| { &m.player_state },
            |m: &mut Cluster| { &mut m.player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "device",
            |m: &Cluster| { &m.device },
            |m: &mut Cluster| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transfer_data",
            |m: &Cluster| { &m.transfer_data },
            |m: &mut Cluster| { &mut m.transfer_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transfer_data_timestamp",
            |m: &Cluster| { &m.transfer_data_timestamp },
            |m: &mut Cluster| { &mut m.transfer_data_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "need_full_player_state",
            |m: &Cluster| { &m.need_full_player_state },
            |m: &mut Cluster| { &mut m.need_full_player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_timestamp_ms",
            |m: &Cluster| { &m.server_timestamp_ms },
            |m: &mut Cluster| { &mut m.server_timestamp_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_state_updates",
            |m: &Cluster| { &m.needs_state_updates },
            |m: &mut Cluster| { &mut m.needs_state_updates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "started_playing_at_timestamp",
            |m: &Cluster| { &m.started_playing_at_timestamp },
            |m: &mut Cluster| { &mut m.started_playing_at_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cluster>(
            "Cluster",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cluster {
    const NAME: &'static str = "Cluster";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.changed_timestamp_ms = is.read_int64()?;
                },
                18 => {
                    self.active_device_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_state)?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.device.insert(key, value);
                },
                42 => {
                    self.transfer_data = is.read_bytes()?;
                },
                48 => {
                    self.transfer_data_timestamp = is.read_uint64()?;
                },
                64 => {
                    self.need_full_player_state = is.read_bool()?;
                },
                72 => {
                    self.server_timestamp_ms = is.read_int64()?;
                },
                80 => {
                    self.needs_state_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.started_playing_at_timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.changed_timestamp_ms != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.changed_timestamp_ms);
        }
        if !self.active_device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.active_device_id);
        }
        if let Some(v) = self.player_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.device {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.transfer_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.transfer_data);
        }
        if self.transfer_data_timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.transfer_data_timestamp);
        }
        if self.need_full_player_state != false {
            my_size += 1 + 1;
        }
        if self.server_timestamp_ms != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.server_timestamp_ms);
        }
        if let Some(v) = self.needs_state_updates {
            my_size += 1 + 1;
        }
        if let Some(v) = self.started_playing_at_timestamp {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.changed_timestamp_ms != 0 {
            os.write_int64(1, self.changed_timestamp_ms)?;
        }
        if !self.active_device_id.is_empty() {
            os.write_string(2, &self.active_device_id)?;
        }
        if let Some(v) = self.player_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for (k, v) in &self.device {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.transfer_data.is_empty() {
            os.write_bytes(5, &self.transfer_data)?;
        }
        if self.transfer_data_timestamp != 0 {
            os.write_uint64(6, self.transfer_data_timestamp)?;
        }
        if self.need_full_player_state != false {
            os.write_bool(8, self.need_full_player_state)?;
        }
        if self.server_timestamp_ms != 0 {
            os.write_int64(9, self.server_timestamp_ms)?;
        }
        if let Some(v) = self.needs_state_updates {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.started_playing_at_timestamp {
            os.write_uint64(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cluster {
        Cluster::new()
    }

    fn clear(&mut self) {
        self.changed_timestamp_ms = 0;
        self.active_device_id.clear();
        self.player_state.clear();
        self.device.clear();
        self.transfer_data.clear();
        self.transfer_data_timestamp = 0;
        self.need_full_player_state = false;
        self.server_timestamp_ms = 0;
        self.needs_state_updates = ::std::option::Option::None;
        self.started_playing_at_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cluster {
        static instance: ::protobuf::rt::Lazy<Cluster> = ::protobuf::rt::Lazy::new();
        instance.get(Cluster::new)
    }
}

impl ::protobuf::MessageFull for Cluster {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cluster").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.PutStateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutStateRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.callback_url)
    pub callback_url: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.device)
    pub device: ::protobuf::MessageField<Device>,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.member_type)
    pub member_type: ::protobuf::EnumOrUnknown<MemberType>,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.is_active)
    pub is_active: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.put_state_reason)
    pub put_state_reason: ::protobuf::EnumOrUnknown<PutStateReason>,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.message_id)
    pub message_id: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.last_command_sent_by_device_id)
    pub last_command_sent_by_device_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.last_command_message_id)
    pub last_command_message_id: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.started_playing_at)
    pub started_playing_at: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.has_been_playing_for_ms)
    pub has_been_playing_for_ms: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.client_side_timestamp)
    pub client_side_timestamp: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.only_write_player_state)
    pub only_write_player_state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.PutStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutStateRequest {
    fn default() -> &'a PutStateRequest {
        <PutStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutStateRequest {
    pub fn new() -> PutStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "callback_url",
            |m: &PutStateRequest| { &m.callback_url },
            |m: &mut PutStateRequest| { &mut m.callback_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Device>(
            "device",
            |m: &PutStateRequest| { &m.device },
            |m: &mut PutStateRequest| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "member_type",
            |m: &PutStateRequest| { &m.member_type },
            |m: &mut PutStateRequest| { &mut m.member_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_active",
            |m: &PutStateRequest| { &m.is_active },
            |m: &mut PutStateRequest| { &mut m.is_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "put_state_reason",
            |m: &PutStateRequest| { &m.put_state_reason },
            |m: &mut PutStateRequest| { &mut m.put_state_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &PutStateRequest| { &m.message_id },
            |m: &mut PutStateRequest| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_command_sent_by_device_id",
            |m: &PutStateRequest| { &m.last_command_sent_by_device_id },
            |m: &mut PutStateRequest| { &mut m.last_command_sent_by_device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_command_message_id",
            |m: &PutStateRequest| { &m.last_command_message_id },
            |m: &mut PutStateRequest| { &mut m.last_command_message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "started_playing_at",
            |m: &PutStateRequest| { &m.started_playing_at },
            |m: &mut PutStateRequest| { &mut m.started_playing_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_been_playing_for_ms",
            |m: &PutStateRequest| { &m.has_been_playing_for_ms },
            |m: &mut PutStateRequest| { &mut m.has_been_playing_for_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_side_timestamp",
            |m: &PutStateRequest| { &m.client_side_timestamp },
            |m: &mut PutStateRequest| { &mut m.client_side_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "only_write_player_state",
            |m: &PutStateRequest| { &m.only_write_player_state },
            |m: &mut PutStateRequest| { &mut m.only_write_player_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutStateRequest>(
            "PutStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutStateRequest {
    const NAME: &'static str = "PutStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.callback_url = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.device)?;
                },
                24 => {
                    self.member_type = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.is_active = is.read_bool()?;
                },
                40 => {
                    self.put_state_reason = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.message_id = is.read_uint32()?;
                },
                58 => {
                    self.last_command_sent_by_device_id = is.read_string()?;
                },
                64 => {
                    self.last_command_message_id = is.read_uint32()?;
                },
                72 => {
                    self.started_playing_at = is.read_uint64()?;
                },
                88 => {
                    self.has_been_playing_for_ms = is.read_uint64()?;
                },
                96 => {
                    self.client_side_timestamp = is.read_uint64()?;
                },
                104 => {
                    self.only_write_player_state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.callback_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.callback_url);
        }
        if let Some(v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.member_type != ::protobuf::EnumOrUnknown::new(MemberType::SPIRC_V2) {
            my_size += ::protobuf::rt::int32_size(3, self.member_type.value());
        }
        if self.is_active != false {
            my_size += 1 + 1;
        }
        if self.put_state_reason != ::protobuf::EnumOrUnknown::new(PutStateReason::UNKNOWN_PUT_STATE_REASON) {
            my_size += ::protobuf::rt::int32_size(5, self.put_state_reason.value());
        }
        if self.message_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.message_id);
        }
        if !self.last_command_sent_by_device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.last_command_sent_by_device_id);
        }
        if self.last_command_message_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.last_command_message_id);
        }
        if self.started_playing_at != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.started_playing_at);
        }
        if self.has_been_playing_for_ms != 0 {
            my_size += ::protobuf::rt::uint64_size(11, self.has_been_playing_for_ms);
        }
        if self.client_side_timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(12, self.client_side_timestamp);
        }
        if self.only_write_player_state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.callback_url.is_empty() {
            os.write_string(1, &self.callback_url)?;
        }
        if let Some(v) = self.device.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.member_type != ::protobuf::EnumOrUnknown::new(MemberType::SPIRC_V2) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.member_type))?;
        }
        if self.is_active != false {
            os.write_bool(4, self.is_active)?;
        }
        if self.put_state_reason != ::protobuf::EnumOrUnknown::new(PutStateReason::UNKNOWN_PUT_STATE_REASON) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.put_state_reason))?;
        }
        if self.message_id != 0 {
            os.write_uint32(6, self.message_id)?;
        }
        if !self.last_command_sent_by_device_id.is_empty() {
            os.write_string(7, &self.last_command_sent_by_device_id)?;
        }
        if self.last_command_message_id != 0 {
            os.write_uint32(8, self.last_command_message_id)?;
        }
        if self.started_playing_at != 0 {
            os.write_uint64(9, self.started_playing_at)?;
        }
        if self.has_been_playing_for_ms != 0 {
            os.write_uint64(11, self.has_been_playing_for_ms)?;
        }
        if self.client_side_timestamp != 0 {
            os.write_uint64(12, self.client_side_timestamp)?;
        }
        if self.only_write_player_state != false {
            os.write_bool(13, self.only_write_player_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutStateRequest {
        PutStateRequest::new()
    }

    fn clear(&mut self) {
        self.callback_url.clear();
        self.device.clear();
        self.member_type = ::protobuf::EnumOrUnknown::new(MemberType::SPIRC_V2);
        self.is_active = false;
        self.put_state_reason = ::protobuf::EnumOrUnknown::new(PutStateReason::UNKNOWN_PUT_STATE_REASON);
        self.message_id = 0;
        self.last_command_sent_by_device_id.clear();
        self.last_command_message_id = 0;
        self.started_playing_at = 0;
        self.has_been_playing_for_ms = 0;
        self.client_side_timestamp = 0;
        self.only_write_player_state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutStateRequest {
        static instance: PutStateRequest = PutStateRequest {
            callback_url: ::std::string::String::new(),
            device: ::protobuf::MessageField::none(),
            member_type: ::protobuf::EnumOrUnknown::from_i32(0),
            is_active: false,
            put_state_reason: ::protobuf::EnumOrUnknown::from_i32(0),
            message_id: 0,
            last_command_sent_by_device_id: ::std::string::String::new(),
            last_command_message_id: 0,
            started_playing_at: 0,
            has_been_playing_for_ms: 0,
            client_side_timestamp: 0,
            only_write_player_state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.PrivateDeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrivateDeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.PrivateDeviceInfo.platform)
    pub platform: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.PrivateDeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrivateDeviceInfo {
    fn default() -> &'a PrivateDeviceInfo {
        <PrivateDeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl PrivateDeviceInfo {
    pub fn new() -> PrivateDeviceInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform",
            |m: &PrivateDeviceInfo| { &m.platform },
            |m: &mut PrivateDeviceInfo| { &mut m.platform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrivateDeviceInfo>(
            "PrivateDeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrivateDeviceInfo {
    const NAME: &'static str = "PrivateDeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.platform = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.platform.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.platform);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.platform.is_empty() {
            os.write_string(1, &self.platform)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrivateDeviceInfo {
        PrivateDeviceInfo::new()
    }

    fn clear(&mut self) {
        self.platform.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrivateDeviceInfo {
        static instance: PrivateDeviceInfo = PrivateDeviceInfo {
            platform: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrivateDeviceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrivateDeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrivateDeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrivateDeviceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.DeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.can_play)
    pub can_play: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.volume)
    pub volume: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_software_version)
    pub device_software_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_type)
    pub device_type: ::protobuf::EnumOrUnknown<super::devices::DeviceType>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.spirc_version)
    pub spirc_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_id)
    pub device_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_private_session)
    pub is_private_session: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_social_connect)
    pub is_social_connect: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.client_id)
    pub client_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.brand)
    pub brand: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.model)
    pub model: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.metadata_map)
    pub metadata_map: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.product_id)
    pub product_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.deduplication_id)
    pub deduplication_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.selected_alias_id)
    pub selected_alias_id: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_aliases)
    pub device_aliases: ::std::collections::HashMap<::std::string::String, super::devices::DeviceAlias>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_offline)
    pub is_offline: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.public_ip)
    pub public_ip: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.license)
    pub license: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_group)
    pub is_group: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_dynamic_device)
    pub is_dynamic_device: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.disallow_playback_reasons)
    pub disallow_playback_reasons: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.disallow_transfer_reasons)
    pub disallow_transfer_reasons: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.audio_output_device_info)
    pub audio_output_device_info: ::protobuf::MessageField<AudioOutputDeviceInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.DeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceInfo {
    fn default() -> &'a DeviceInfo {
        <DeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfo {
    pub fn new() -> DeviceInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_play",
            |m: &DeviceInfo| { &m.can_play },
            |m: &mut DeviceInfo| { &mut m.can_play },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &DeviceInfo| { &m.volume },
            |m: &mut DeviceInfo| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeviceInfo| { &m.name },
            |m: &mut DeviceInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &DeviceInfo| { &m.capabilities },
            |m: &mut DeviceInfo| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_software_version",
            |m: &DeviceInfo| { &m.device_software_version },
            |m: &mut DeviceInfo| { &mut m.device_software_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_type",
            |m: &DeviceInfo| { &m.device_type },
            |m: &mut DeviceInfo| { &mut m.device_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spirc_version",
            |m: &DeviceInfo| { &m.spirc_version },
            |m: &mut DeviceInfo| { &mut m.spirc_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &DeviceInfo| { &m.device_id },
            |m: &mut DeviceInfo| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_private_session",
            |m: &DeviceInfo| { &m.is_private_session },
            |m: &mut DeviceInfo| { &mut m.is_private_session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_social_connect",
            |m: &DeviceInfo| { &m.is_social_connect },
            |m: &mut DeviceInfo| { &mut m.is_social_connect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &DeviceInfo| { &m.client_id },
            |m: &mut DeviceInfo| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brand",
            |m: &DeviceInfo| { &m.brand },
            |m: &mut DeviceInfo| { &mut m.brand },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &DeviceInfo| { &m.model },
            |m: &mut DeviceInfo| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "metadata_map",
            |m: &DeviceInfo| { &m.metadata_map },
            |m: &mut DeviceInfo| { &mut m.metadata_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_id",
            |m: &DeviceInfo| { &m.product_id },
            |m: &mut DeviceInfo| { &mut m.product_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deduplication_id",
            |m: &DeviceInfo| { &m.deduplication_id },
            |m: &mut DeviceInfo| { &mut m.deduplication_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "selected_alias_id",
            |m: &DeviceInfo| { &m.selected_alias_id },
            |m: &mut DeviceInfo| { &mut m.selected_alias_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "device_aliases",
            |m: &DeviceInfo| { &m.device_aliases },
            |m: &mut DeviceInfo| { &mut m.device_aliases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_offline",
            |m: &DeviceInfo| { &m.is_offline },
            |m: &mut DeviceInfo| { &mut m.is_offline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_ip",
            |m: &DeviceInfo| { &m.public_ip },
            |m: &mut DeviceInfo| { &mut m.public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "license",
            |m: &DeviceInfo| { &m.license },
            |m: &mut DeviceInfo| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_group",
            |m: &DeviceInfo| { &m.is_group },
            |m: &mut DeviceInfo| { &mut m.is_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_dynamic_device",
            |m: &DeviceInfo| { &m.is_dynamic_device },
            |m: &mut DeviceInfo| { &mut m.is_dynamic_device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disallow_playback_reasons",
            |m: &DeviceInfo| { &m.disallow_playback_reasons },
            |m: &mut DeviceInfo| { &mut m.disallow_playback_reasons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disallow_transfer_reasons",
            |m: &DeviceInfo| { &m.disallow_transfer_reasons },
            |m: &mut DeviceInfo| { &mut m.disallow_transfer_reasons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AudioOutputDeviceInfo>(
            "audio_output_device_info",
            |m: &DeviceInfo| { &m.audio_output_device_info },
            |m: &mut DeviceInfo| { &mut m.audio_output_device_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInfo>(
            "DeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInfo {
    const NAME: &'static str = "DeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.can_play = is.read_bool()?;
                },
                16 => {
                    self.volume = is.read_uint32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                50 => {
                    self.device_software_version = is.read_string()?;
                },
                56 => {
                    self.device_type = is.read_enum_or_unknown()?;
                },
                74 => {
                    self.spirc_version = is.read_string()?;
                },
                82 => {
                    self.device_id = is.read_string()?;
                },
                88 => {
                    self.is_private_session = is.read_bool()?;
                },
                96 => {
                    self.is_social_connect = is.read_bool()?;
                },
                106 => {
                    self.client_id = is.read_string()?;
                },
                114 => {
                    self.brand = is.read_string()?;
                },
                122 => {
                    self.model = is.read_string()?;
                },
                130 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata_map.insert(key, value);
                },
                138 => {
                    self.product_id = is.read_string()?;
                },
                146 => {
                    self.deduplication_id = is.read_string()?;
                },
                152 => {
                    self.selected_alias_id = is.read_uint32()?;
                },
                162 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.device_aliases.insert(key, value);
                },
                168 => {
                    self.is_offline = is.read_bool()?;
                },
                178 => {
                    self.public_ip = is.read_string()?;
                },
                186 => {
                    self.license = is.read_string()?;
                },
                200 => {
                    self.is_group = is.read_bool()?;
                },
                208 => {
                    self.is_dynamic_device = is.read_bool()?;
                },
                218 => {
                    self.disallow_playback_reasons.push(is.read_string()?);
                },
                226 => {
                    self.disallow_transfer_reasons.push(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio_output_device_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.can_play != false {
            my_size += 1 + 1;
        }
        if self.volume != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.volume);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.device_software_version.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.device_software_version);
        }
        if self.device_type != ::protobuf::EnumOrUnknown::new(super::devices::DeviceType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(7, self.device_type.value());
        }
        if !self.spirc_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.spirc_version);
        }
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.device_id);
        }
        if self.is_private_session != false {
            my_size += 1 + 1;
        }
        if self.is_social_connect != false {
            my_size += 1 + 1;
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.client_id);
        }
        if !self.brand.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.brand);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.model);
        }
        for (k, v) in &self.metadata_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.product_id.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.product_id);
        }
        if !self.deduplication_id.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.deduplication_id);
        }
        if self.selected_alias_id != 0 {
            my_size += ::protobuf::rt::uint32_size(19, self.selected_alias_id);
        }
        for (k, v) in &self.device_aliases {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.is_offline != false {
            my_size += 2 + 1;
        }
        if !self.public_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.public_ip);
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.license);
        }
        if self.is_group != false {
            my_size += 2 + 1;
        }
        if self.is_dynamic_device != false {
            my_size += 2 + 1;
        }
        for value in &self.disallow_playback_reasons {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        for value in &self.disallow_transfer_reasons {
            my_size += ::protobuf::rt::string_size(28, &value);
        };
        if let Some(v) = self.audio_output_device_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.can_play != false {
            os.write_bool(1, self.can_play)?;
        }
        if self.volume != 0 {
            os.write_uint32(2, self.volume)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.device_software_version.is_empty() {
            os.write_string(6, &self.device_software_version)?;
        }
        if self.device_type != ::protobuf::EnumOrUnknown::new(super::devices::DeviceType::UNKNOWN) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.device_type))?;
        }
        if !self.spirc_version.is_empty() {
            os.write_string(9, &self.spirc_version)?;
        }
        if !self.device_id.is_empty() {
            os.write_string(10, &self.device_id)?;
        }
        if self.is_private_session != false {
            os.write_bool(11, self.is_private_session)?;
        }
        if self.is_social_connect != false {
            os.write_bool(12, self.is_social_connect)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(13, &self.client_id)?;
        }
        if !self.brand.is_empty() {
            os.write_string(14, &self.brand)?;
        }
        if !self.model.is_empty() {
            os.write_string(15, &self.model)?;
        }
        for (k, v) in &self.metadata_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(130)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.product_id.is_empty() {
            os.write_string(17, &self.product_id)?;
        }
        if !self.deduplication_id.is_empty() {
            os.write_string(18, &self.deduplication_id)?;
        }
        if self.selected_alias_id != 0 {
            os.write_uint32(19, self.selected_alias_id)?;
        }
        for (k, v) in &self.device_aliases {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(162)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.is_offline != false {
            os.write_bool(21, self.is_offline)?;
        }
        if !self.public_ip.is_empty() {
            os.write_string(22, &self.public_ip)?;
        }
        if !self.license.is_empty() {
            os.write_string(23, &self.license)?;
        }
        if self.is_group != false {
            os.write_bool(25, self.is_group)?;
        }
        if self.is_dynamic_device != false {
            os.write_bool(26, self.is_dynamic_device)?;
        }
        for v in &self.disallow_playback_reasons {
            os.write_string(27, &v)?;
        };
        for v in &self.disallow_transfer_reasons {
            os.write_string(28, &v)?;
        };
        if let Some(v) = self.audio_output_device_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInfo {
        DeviceInfo::new()
    }

    fn clear(&mut self) {
        self.can_play = false;
        self.volume = 0;
        self.name.clear();
        self.capabilities.clear();
        self.device_software_version.clear();
        self.device_type = ::protobuf::EnumOrUnknown::new(super::devices::DeviceType::UNKNOWN);
        self.spirc_version.clear();
        self.device_id.clear();
        self.is_private_session = false;
        self.is_social_connect = false;
        self.client_id.clear();
        self.brand.clear();
        self.model.clear();
        self.metadata_map.clear();
        self.product_id.clear();
        self.deduplication_id.clear();
        self.selected_alias_id = 0;
        self.device_aliases.clear();
        self.is_offline = false;
        self.public_ip.clear();
        self.license.clear();
        self.is_group = false;
        self.is_dynamic_device = false;
        self.disallow_playback_reasons.clear();
        self.disallow_transfer_reasons.clear();
        self.audio_output_device_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInfo {
        static instance: ::protobuf::rt::Lazy<DeviceInfo> = ::protobuf::rt::Lazy::new();
        instance.get(DeviceInfo::new)
    }
}

impl ::protobuf::MessageFull for DeviceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.AudioOutputDeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioOutputDeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.AudioOutputDeviceInfo.audio_output_device_type)
    pub audio_output_device_type: ::std::option::Option<::protobuf::EnumOrUnknown<AudioOutputDeviceType>>,
    // @@protoc_insertion_point(field:spotify.connectstate.AudioOutputDeviceInfo.device_name)
    pub device_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.AudioOutputDeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioOutputDeviceInfo {
    fn default() -> &'a AudioOutputDeviceInfo {
        <AudioOutputDeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl AudioOutputDeviceInfo {
    pub fn new() -> AudioOutputDeviceInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_output_device_type",
            |m: &AudioOutputDeviceInfo| { &m.audio_output_device_type },
            |m: &mut AudioOutputDeviceInfo| { &mut m.audio_output_device_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_name",
            |m: &AudioOutputDeviceInfo| { &m.device_name },
            |m: &mut AudioOutputDeviceInfo| { &mut m.device_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioOutputDeviceInfo>(
            "AudioOutputDeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioOutputDeviceInfo {
    const NAME: &'static str = "AudioOutputDeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.audio_output_device_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.device_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio_output_device_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audio_output_device_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.device_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioOutputDeviceInfo {
        AudioOutputDeviceInfo::new()
    }

    fn clear(&mut self) {
        self.audio_output_device_type = ::std::option::Option::None;
        self.device_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioOutputDeviceInfo {
        static instance: AudioOutputDeviceInfo = AudioOutputDeviceInfo {
            audio_output_device_type: ::std::option::Option::None,
            device_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioOutputDeviceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioOutputDeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioOutputDeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioOutputDeviceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.Capabilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Capabilities {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.can_be_player)
    pub can_be_player: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.restrict_to_local)
    pub restrict_to_local: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.gaia_eq_connect_id)
    pub gaia_eq_connect_id: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_logout)
    pub supports_logout: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.is_observable)
    pub is_observable: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.volume_steps)
    pub volume_steps: i32,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supported_types)
    pub supported_types: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.command_acks)
    pub command_acks: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_rename)
    pub supports_rename: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.hidden)
    pub hidden: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.disable_volume)
    pub disable_volume: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.connect_disabled)
    pub connect_disabled: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_playlist_v2)
    pub supports_playlist_v2: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.is_controllable)
    pub is_controllable: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_external_episodes)
    pub supports_external_episodes: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_set_backend_metadata)
    pub supports_set_backend_metadata: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_transfer_command)
    pub supports_transfer_command: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_command_request)
    pub supports_command_request: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.is_voice_enabled)
    pub is_voice_enabled: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.needs_full_player_state)
    pub needs_full_player_state: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_gzip_pushes)
    pub supports_gzip_pushes: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_set_options_command)
    pub supports_set_options_command: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_hifi)
    pub supports_hifi: ::protobuf::MessageField<CapabilitySupportDetails>,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.connect_capabilities)
    pub connect_capabilities: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_rooms)
    pub supports_rooms: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_dj)
    pub supports_dj: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supported_audio_quality)
    pub supported_audio_quality: ::protobuf::EnumOrUnknown<super::media::AudioQuality>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.Capabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Capabilities {
    fn default() -> &'a Capabilities {
        <Capabilities as ::protobuf::Message>::default_instance()
    }
}

impl Capabilities {
    pub fn new() -> Capabilities {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_be_player",
            |m: &Capabilities| { &m.can_be_player },
            |m: &mut Capabilities| { &mut m.can_be_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "restrict_to_local",
            |m: &Capabilities| { &m.restrict_to_local },
            |m: &mut Capabilities| { &mut m.restrict_to_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gaia_eq_connect_id",
            |m: &Capabilities| { &m.gaia_eq_connect_id },
            |m: &mut Capabilities| { &mut m.gaia_eq_connect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_logout",
            |m: &Capabilities| { &m.supports_logout },
            |m: &mut Capabilities| { &mut m.supports_logout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_observable",
            |m: &Capabilities| { &m.is_observable },
            |m: &mut Capabilities| { &mut m.is_observable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume_steps",
            |m: &Capabilities| { &m.volume_steps },
            |m: &mut Capabilities| { &mut m.volume_steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_types",
            |m: &Capabilities| { &m.supported_types },
            |m: &mut Capabilities| { &mut m.supported_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command_acks",
            |m: &Capabilities| { &m.command_acks },
            |m: &mut Capabilities| { &mut m.command_acks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_rename",
            |m: &Capabilities| { &m.supports_rename },
            |m: &mut Capabilities| { &mut m.supports_rename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hidden",
            |m: &Capabilities| { &m.hidden },
            |m: &mut Capabilities| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_volume",
            |m: &Capabilities| { &m.disable_volume },
            |m: &mut Capabilities| { &mut m.disable_volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connect_disabled",
            |m: &Capabilities| { &m.connect_disabled },
            |m: &mut Capabilities| { &mut m.connect_disabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_playlist_v2",
            |m: &Capabilities| { &m.supports_playlist_v2 },
            |m: &mut Capabilities| { &mut m.supports_playlist_v2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_controllable",
            |m: &Capabilities| { &m.is_controllable },
            |m: &mut Capabilities| { &mut m.is_controllable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_external_episodes",
            |m: &Capabilities| { &m.supports_external_episodes },
            |m: &mut Capabilities| { &mut m.supports_external_episodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_set_backend_metadata",
            |m: &Capabilities| { &m.supports_set_backend_metadata },
            |m: &mut Capabilities| { &mut m.supports_set_backend_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_transfer_command",
            |m: &Capabilities| { &m.supports_transfer_command },
            |m: &mut Capabilities| { &mut m.supports_transfer_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_command_request",
            |m: &Capabilities| { &m.supports_command_request },
            |m: &mut Capabilities| { &mut m.supports_command_request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_voice_enabled",
            |m: &Capabilities| { &m.is_voice_enabled },
            |m: &mut Capabilities| { &mut m.is_voice_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "needs_full_player_state",
            |m: &Capabilities| { &m.needs_full_player_state },
            |m: &mut Capabilities| { &mut m.needs_full_player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_gzip_pushes",
            |m: &Capabilities| { &m.supports_gzip_pushes },
            |m: &mut Capabilities| { &mut m.supports_gzip_pushes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_set_options_command",
            |m: &Capabilities| { &m.supports_set_options_command },
            |m: &mut Capabilities| { &mut m.supports_set_options_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CapabilitySupportDetails>(
            "supports_hifi",
            |m: &Capabilities| { &m.supports_hifi },
            |m: &mut Capabilities| { &mut m.supports_hifi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connect_capabilities",
            |m: &Capabilities| { &m.connect_capabilities },
            |m: &mut Capabilities| { &mut m.connect_capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_rooms",
            |m: &Capabilities| { &m.supports_rooms },
            |m: &mut Capabilities| { &mut m.supports_rooms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_dj",
            |m: &Capabilities| { &m.supports_dj },
            |m: &mut Capabilities| { &mut m.supports_dj },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supported_audio_quality",
            |m: &Capabilities| { &m.supported_audio_quality },
            |m: &mut Capabilities| { &mut m.supported_audio_quality },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Capabilities>(
            "Capabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Capabilities {
    const NAME: &'static str = "Capabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.can_be_player = is.read_bool()?;
                },
                24 => {
                    self.restrict_to_local = is.read_bool()?;
                },
                40 => {
                    self.gaia_eq_connect_id = is.read_bool()?;
                },
                48 => {
                    self.supports_logout = is.read_bool()?;
                },
                56 => {
                    self.is_observable = is.read_bool()?;
                },
                64 => {
                    self.volume_steps = is.read_int32()?;
                },
                74 => {
                    self.supported_types.push(is.read_string()?);
                },
                80 => {
                    self.command_acks = is.read_bool()?;
                },
                88 => {
                    self.supports_rename = is.read_bool()?;
                },
                96 => {
                    self.hidden = is.read_bool()?;
                },
                104 => {
                    self.disable_volume = is.read_bool()?;
                },
                112 => {
                    self.connect_disabled = is.read_bool()?;
                },
                120 => {
                    self.supports_playlist_v2 = is.read_bool()?;
                },
                128 => {
                    self.is_controllable = is.read_bool()?;
                },
                136 => {
                    self.supports_external_episodes = is.read_bool()?;
                },
                144 => {
                    self.supports_set_backend_metadata = is.read_bool()?;
                },
                152 => {
                    self.supports_transfer_command = is.read_bool()?;
                },
                160 => {
                    self.supports_command_request = is.read_bool()?;
                },
                168 => {
                    self.is_voice_enabled = is.read_bool()?;
                },
                176 => {
                    self.needs_full_player_state = is.read_bool()?;
                },
                184 => {
                    self.supports_gzip_pushes = is.read_bool()?;
                },
                200 => {
                    self.supports_set_options_command = is.read_bool()?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.supports_hifi)?;
                },
                218 => {
                    self.connect_capabilities = is.read_string()?;
                },
                224 => {
                    self.supports_rooms = is.read_bool()?;
                },
                232 => {
                    self.supports_dj = is.read_bool()?;
                },
                240 => {
                    self.supported_audio_quality = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.can_be_player != false {
            my_size += 1 + 1;
        }
        if self.restrict_to_local != false {
            my_size += 1 + 1;
        }
        if self.gaia_eq_connect_id != false {
            my_size += 1 + 1;
        }
        if self.supports_logout != false {
            my_size += 1 + 1;
        }
        if self.is_observable != false {
            my_size += 1 + 1;
        }
        if self.volume_steps != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.volume_steps);
        }
        for value in &self.supported_types {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.command_acks != false {
            my_size += 1 + 1;
        }
        if self.supports_rename != false {
            my_size += 1 + 1;
        }
        if self.hidden != false {
            my_size += 1 + 1;
        }
        if self.disable_volume != false {
            my_size += 1 + 1;
        }
        if self.connect_disabled != false {
            my_size += 1 + 1;
        }
        if self.supports_playlist_v2 != false {
            my_size += 1 + 1;
        }
        if self.is_controllable != false {
            my_size += 2 + 1;
        }
        if self.supports_external_episodes != false {
            my_size += 2 + 1;
        }
        if self.supports_set_backend_metadata != false {
            my_size += 2 + 1;
        }
        if self.supports_transfer_command != false {
            my_size += 2 + 1;
        }
        if self.supports_command_request != false {
            my_size += 2 + 1;
        }
        if self.is_voice_enabled != false {
            my_size += 2 + 1;
        }
        if self.needs_full_player_state != false {
            my_size += 2 + 1;
        }
        if self.supports_gzip_pushes != false {
            my_size += 2 + 1;
        }
        if self.supports_set_options_command != false {
            my_size += 2 + 1;
        }
        if let Some(v) = self.supports_hifi.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.connect_capabilities.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.connect_capabilities);
        }
        if self.supports_rooms != false {
            my_size += 2 + 1;
        }
        if self.supports_dj != false {
            my_size += 2 + 1;
        }
        if self.supported_audio_quality != ::protobuf::EnumOrUnknown::new(super::media::AudioQuality::DEFAULT) {
            my_size += ::protobuf::rt::int32_size(30, self.supported_audio_quality.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.can_be_player != false {
            os.write_bool(2, self.can_be_player)?;
        }
        if self.restrict_to_local != false {
            os.write_bool(3, self.restrict_to_local)?;
        }
        if self.gaia_eq_connect_id != false {
            os.write_bool(5, self.gaia_eq_connect_id)?;
        }
        if self.supports_logout != false {
            os.write_bool(6, self.supports_logout)?;
        }
        if self.is_observable != false {
            os.write_bool(7, self.is_observable)?;
        }
        if self.volume_steps != 0 {
            os.write_int32(8, self.volume_steps)?;
        }
        for v in &self.supported_types {
            os.write_string(9, &v)?;
        };
        if self.command_acks != false {
            os.write_bool(10, self.command_acks)?;
        }
        if self.supports_rename != false {
            os.write_bool(11, self.supports_rename)?;
        }
        if self.hidden != false {
            os.write_bool(12, self.hidden)?;
        }
        if self.disable_volume != false {
            os.write_bool(13, self.disable_volume)?;
        }
        if self.connect_disabled != false {
            os.write_bool(14, self.connect_disabled)?;
        }
        if self.supports_playlist_v2 != false {
            os.write_bool(15, self.supports_playlist_v2)?;
        }
        if self.is_controllable != false {
            os.write_bool(16, self.is_controllable)?;
        }
        if self.supports_external_episodes != false {
            os.write_bool(17, self.supports_external_episodes)?;
        }
        if self.supports_set_backend_metadata != false {
            os.write_bool(18, self.supports_set_backend_metadata)?;
        }
        if self.supports_transfer_command != false {
            os.write_bool(19, self.supports_transfer_command)?;
        }
        if self.supports_command_request != false {
            os.write_bool(20, self.supports_command_request)?;
        }
        if self.is_voice_enabled != false {
            os.write_bool(21, self.is_voice_enabled)?;
        }
        if self.needs_full_player_state != false {
            os.write_bool(22, self.needs_full_player_state)?;
        }
        if self.supports_gzip_pushes != false {
            os.write_bool(23, self.supports_gzip_pushes)?;
        }
        if self.supports_set_options_command != false {
            os.write_bool(25, self.supports_set_options_command)?;
        }
        if let Some(v) = self.supports_hifi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if !self.connect_capabilities.is_empty() {
            os.write_string(27, &self.connect_capabilities)?;
        }
        if self.supports_rooms != false {
            os.write_bool(28, self.supports_rooms)?;
        }
        if self.supports_dj != false {
            os.write_bool(29, self.supports_dj)?;
        }
        if self.supported_audio_quality != ::protobuf::EnumOrUnknown::new(super::media::AudioQuality::DEFAULT) {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&self.supported_audio_quality))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Capabilities {
        Capabilities::new()
    }

    fn clear(&mut self) {
        self.can_be_player = false;
        self.restrict_to_local = false;
        self.gaia_eq_connect_id = false;
        self.supports_logout = false;
        self.is_observable = false;
        self.volume_steps = 0;
        self.supported_types.clear();
        self.command_acks = false;
        self.supports_rename = false;
        self.hidden = false;
        self.disable_volume = false;
        self.connect_disabled = false;
        self.supports_playlist_v2 = false;
        self.is_controllable = false;
        self.supports_external_episodes = false;
        self.supports_set_backend_metadata = false;
        self.supports_transfer_command = false;
        self.supports_command_request = false;
        self.is_voice_enabled = false;
        self.needs_full_player_state = false;
        self.supports_gzip_pushes = false;
        self.supports_set_options_command = false;
        self.supports_hifi.clear();
        self.connect_capabilities.clear();
        self.supports_rooms = false;
        self.supports_dj = false;
        self.supported_audio_quality = ::protobuf::EnumOrUnknown::new(super::media::AudioQuality::DEFAULT);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Capabilities {
        static instance: Capabilities = Capabilities {
            can_be_player: false,
            restrict_to_local: false,
            gaia_eq_connect_id: false,
            supports_logout: false,
            is_observable: false,
            volume_steps: 0,
            supported_types: ::std::vec::Vec::new(),
            command_acks: false,
            supports_rename: false,
            hidden: false,
            disable_volume: false,
            connect_disabled: false,
            supports_playlist_v2: false,
            is_controllable: false,
            supports_external_episodes: false,
            supports_set_backend_metadata: false,
            supports_transfer_command: false,
            supports_command_request: false,
            is_voice_enabled: false,
            needs_full_player_state: false,
            supports_gzip_pushes: false,
            supports_set_options_command: false,
            supports_hifi: ::protobuf::MessageField::none(),
            connect_capabilities: ::std::string::String::new(),
            supports_rooms: false,
            supports_dj: false,
            supported_audio_quality: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Capabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Capabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Capabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.CapabilitySupportDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CapabilitySupportDetails {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.CapabilitySupportDetails.fully_supported)
    pub fully_supported: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.CapabilitySupportDetails.user_eligible)
    pub user_eligible: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.CapabilitySupportDetails.device_supported)
    pub device_supported: bool,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.CapabilitySupportDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CapabilitySupportDetails {
    fn default() -> &'a CapabilitySupportDetails {
        <CapabilitySupportDetails as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitySupportDetails {
    pub fn new() -> CapabilitySupportDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fully_supported",
            |m: &CapabilitySupportDetails| { &m.fully_supported },
            |m: &mut CapabilitySupportDetails| { &mut m.fully_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_eligible",
            |m: &CapabilitySupportDetails| { &m.user_eligible },
            |m: &mut CapabilitySupportDetails| { &mut m.user_eligible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_supported",
            |m: &CapabilitySupportDetails| { &m.device_supported },
            |m: &mut CapabilitySupportDetails| { &mut m.device_supported },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CapabilitySupportDetails>(
            "CapabilitySupportDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CapabilitySupportDetails {
    const NAME: &'static str = "CapabilitySupportDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fully_supported = is.read_bool()?;
                },
                16 => {
                    self.user_eligible = is.read_bool()?;
                },
                24 => {
                    self.device_supported = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fully_supported != false {
            my_size += 1 + 1;
        }
        if self.user_eligible != false {
            my_size += 1 + 1;
        }
        if self.device_supported != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fully_supported != false {
            os.write_bool(1, self.fully_supported)?;
        }
        if self.user_eligible != false {
            os.write_bool(2, self.user_eligible)?;
        }
        if self.device_supported != false {
            os.write_bool(3, self.device_supported)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CapabilitySupportDetails {
        CapabilitySupportDetails::new()
    }

    fn clear(&mut self) {
        self.fully_supported = false;
        self.user_eligible = false;
        self.device_supported = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CapabilitySupportDetails {
        static instance: CapabilitySupportDetails = CapabilitySupportDetails {
            fully_supported: false,
            user_eligible: false,
            device_supported: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CapabilitySupportDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CapabilitySupportDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CapabilitySupportDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitySupportDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.ConnectCommandOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectCommandOptions {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectCommandOptions.message_id)
    pub message_id: i32,
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectCommandOptions.target_alias_id)
    pub target_alias_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.ConnectCommandOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectCommandOptions {
    fn default() -> &'a ConnectCommandOptions {
        <ConnectCommandOptions as ::protobuf::Message>::default_instance()
    }
}

impl ConnectCommandOptions {
    pub fn new() -> ConnectCommandOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &ConnectCommandOptions| { &m.message_id },
            |m: &mut ConnectCommandOptions| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_alias_id",
            |m: &ConnectCommandOptions| { &m.target_alias_id },
            |m: &mut ConnectCommandOptions| { &mut m.target_alias_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectCommandOptions>(
            "ConnectCommandOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectCommandOptions {
    const NAME: &'static str = "ConnectCommandOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_id = is.read_int32()?;
                },
                24 => {
                    self.target_alias_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.message_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.message_id);
        }
        if self.target_alias_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.target_alias_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.message_id != 0 {
            os.write_int32(1, self.message_id)?;
        }
        if self.target_alias_id != 0 {
            os.write_uint32(3, self.target_alias_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectCommandOptions {
        ConnectCommandOptions::new()
    }

    fn clear(&mut self) {
        self.message_id = 0;
        self.target_alias_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectCommandOptions {
        static instance: ConnectCommandOptions = ConnectCommandOptions {
            message_id: 0,
            target_alias_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectCommandOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectCommandOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectCommandOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectCommandOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.ConnectLoggingParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectLoggingParams {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectLoggingParams.interaction_ids)
    pub interaction_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectLoggingParams.page_instance_ids)
    pub page_instance_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.ConnectLoggingParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectLoggingParams {
    fn default() -> &'a ConnectLoggingParams {
        <ConnectLoggingParams as ::protobuf::Message>::default_instance()
    }
}

impl ConnectLoggingParams {
    pub fn new() -> ConnectLoggingParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interaction_ids",
            |m: &ConnectLoggingParams| { &m.interaction_ids },
            |m: &mut ConnectLoggingParams| { &mut m.interaction_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "page_instance_ids",
            |m: &ConnectLoggingParams| { &m.page_instance_ids },
            |m: &mut ConnectLoggingParams| { &mut m.page_instance_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectLoggingParams>(
            "ConnectLoggingParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectLoggingParams {
    const NAME: &'static str = "ConnectLoggingParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.interaction_ids.push(is.read_string()?);
                },
                18 => {
                    self.page_instance_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.interaction_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.page_instance_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.interaction_ids {
            os.write_string(1, &v)?;
        };
        for v in &self.page_instance_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectLoggingParams {
        ConnectLoggingParams::new()
    }

    fn clear(&mut self) {
        self.interaction_ids.clear();
        self.page_instance_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectLoggingParams {
        static instance: ConnectLoggingParams = ConnectLoggingParams {
            interaction_ids: ::std::vec::Vec::new(),
            page_instance_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectLoggingParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectLoggingParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectLoggingParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectLoggingParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.LogoutCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogoutCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.LogoutCommand.command_options)
    pub command_options: ::protobuf::MessageField<ConnectCommandOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.LogoutCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogoutCommand {
    fn default() -> &'a LogoutCommand {
        <LogoutCommand as ::protobuf::Message>::default_instance()
    }
}

impl LogoutCommand {
    pub fn new() -> LogoutCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectCommandOptions>(
            "command_options",
            |m: &LogoutCommand| { &m.command_options },
            |m: &mut LogoutCommand| { &mut m.command_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogoutCommand>(
            "LogoutCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogoutCommand {
    const NAME: &'static str = "LogoutCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogoutCommand {
        LogoutCommand::new()
    }

    fn clear(&mut self) {
        self.command_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogoutCommand {
        static instance: LogoutCommand = LogoutCommand {
            command_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogoutCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogoutCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogoutCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogoutCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.SetVolumeCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetVolumeCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.SetVolumeCommand.volume)
    pub volume: i32,
    // @@protoc_insertion_point(field:spotify.connectstate.SetVolumeCommand.command_options)
    pub command_options: ::protobuf::MessageField<ConnectCommandOptions>,
    // @@protoc_insertion_point(field:spotify.connectstate.SetVolumeCommand.logging_params)
    pub logging_params: ::protobuf::MessageField<ConnectLoggingParams>,
    // @@protoc_insertion_point(field:spotify.connectstate.SetVolumeCommand.connection_type)
    pub connection_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.SetVolumeCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetVolumeCommand {
    fn default() -> &'a SetVolumeCommand {
        <SetVolumeCommand as ::protobuf::Message>::default_instance()
    }
}

impl SetVolumeCommand {
    pub fn new() -> SetVolumeCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &SetVolumeCommand| { &m.volume },
            |m: &mut SetVolumeCommand| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectCommandOptions>(
            "command_options",
            |m: &SetVolumeCommand| { &m.command_options },
            |m: &mut SetVolumeCommand| { &mut m.command_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectLoggingParams>(
            "logging_params",
            |m: &SetVolumeCommand| { &m.logging_params },
            |m: &mut SetVolumeCommand| { &mut m.logging_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connection_type",
            |m: &SetVolumeCommand| { &m.connection_type },
            |m: &mut SetVolumeCommand| { &mut m.connection_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetVolumeCommand>(
            "SetVolumeCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetVolumeCommand {
    const NAME: &'static str = "SetVolumeCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.volume = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_options)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.logging_params)?;
                },
                34 => {
                    self.connection_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.volume != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.volume);
        }
        if let Some(v) = self.command_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.logging_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.connection_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.connection_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.volume != 0 {
            os.write_int32(1, self.volume)?;
        }
        if let Some(v) = self.command_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.logging_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.connection_type.is_empty() {
            os.write_string(4, &self.connection_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetVolumeCommand {
        SetVolumeCommand::new()
    }

    fn clear(&mut self) {
        self.volume = 0;
        self.command_options.clear();
        self.logging_params.clear();
        self.connection_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetVolumeCommand {
        static instance: SetVolumeCommand = SetVolumeCommand {
            volume: 0,
            command_options: ::protobuf::MessageField::none(),
            logging_params: ::protobuf::MessageField::none(),
            connection_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetVolumeCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetVolumeCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetVolumeCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetVolumeCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.RenameCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RenameCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.RenameCommand.rename_to)
    pub rename_to: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.RenameCommand.command_options)
    pub command_options: ::protobuf::MessageField<ConnectCommandOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.RenameCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenameCommand {
    fn default() -> &'a RenameCommand {
        <RenameCommand as ::protobuf::Message>::default_instance()
    }
}

impl RenameCommand {
    pub fn new() -> RenameCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rename_to",
            |m: &RenameCommand| { &m.rename_to },
            |m: &mut RenameCommand| { &mut m.rename_to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectCommandOptions>(
            "command_options",
            |m: &RenameCommand| { &m.command_options },
            |m: &mut RenameCommand| { &mut m.command_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenameCommand>(
            "RenameCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenameCommand {
    const NAME: &'static str = "RenameCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rename_to = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.rename_to.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rename_to);
        }
        if let Some(v) = self.command_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.rename_to.is_empty() {
            os.write_string(1, &self.rename_to)?;
        }
        if let Some(v) = self.command_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenameCommand {
        RenameCommand::new()
    }

    fn clear(&mut self) {
        self.rename_to.clear();
        self.command_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenameCommand {
        static instance: RenameCommand = RenameCommand {
            rename_to: ::std::string::String::new(),
            command_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenameCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenameCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenameCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.SetBackendMetadataCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetBackendMetadataCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.SetBackendMetadataCommand.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.SetBackendMetadataCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetBackendMetadataCommand {
    fn default() -> &'a SetBackendMetadataCommand {
        <SetBackendMetadataCommand as ::protobuf::Message>::default_instance()
    }
}

impl SetBackendMetadataCommand {
    pub fn new() -> SetBackendMetadataCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "metadata",
            |m: &SetBackendMetadataCommand| { &m.metadata },
            |m: &mut SetBackendMetadataCommand| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetBackendMetadataCommand>(
            "SetBackendMetadataCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetBackendMetadataCommand {
    const NAME: &'static str = "SetBackendMetadataCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetBackendMetadataCommand {
        SetBackendMetadataCommand::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetBackendMetadataCommand {
        static instance: ::protobuf::rt::Lazy<SetBackendMetadataCommand> = ::protobuf::rt::Lazy::new();
        instance.get(SetBackendMetadataCommand::new)
    }
}

impl ::protobuf::MessageFull for SetBackendMetadataCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetBackendMetadataCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetBackendMetadataCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBackendMetadataCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.AudioOutputDeviceType)
pub enum AudioOutputDeviceType {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE)
    UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.BUILT_IN_SPEAKER)
    BUILT_IN_SPEAKER = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.LINE_OUT)
    LINE_OUT = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.BLUETOOTH)
    BLUETOOTH = 3,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.AIRPLAY)
    AIRPLAY = 4,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.AUTOMOTIVE)
    AUTOMOTIVE = 5,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.CAR_PROJECTED)
    CAR_PROJECTED = 6,
}

impl ::protobuf::Enum for AudioOutputDeviceType {
    const NAME: &'static str = "AudioOutputDeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioOutputDeviceType> {
        match value {
            0 => ::std::option::Option::Some(AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE),
            1 => ::std::option::Option::Some(AudioOutputDeviceType::BUILT_IN_SPEAKER),
            2 => ::std::option::Option::Some(AudioOutputDeviceType::LINE_OUT),
            3 => ::std::option::Option::Some(AudioOutputDeviceType::BLUETOOTH),
            4 => ::std::option::Option::Some(AudioOutputDeviceType::AIRPLAY),
            5 => ::std::option::Option::Some(AudioOutputDeviceType::AUTOMOTIVE),
            6 => ::std::option::Option::Some(AudioOutputDeviceType::CAR_PROJECTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AudioOutputDeviceType> {
        match str {
            "UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE" => ::std::option::Option::Some(AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE),
            "BUILT_IN_SPEAKER" => ::std::option::Option::Some(AudioOutputDeviceType::BUILT_IN_SPEAKER),
            "LINE_OUT" => ::std::option::Option::Some(AudioOutputDeviceType::LINE_OUT),
            "BLUETOOTH" => ::std::option::Option::Some(AudioOutputDeviceType::BLUETOOTH),
            "AIRPLAY" => ::std::option::Option::Some(AudioOutputDeviceType::AIRPLAY),
            "AUTOMOTIVE" => ::std::option::Option::Some(AudioOutputDeviceType::AUTOMOTIVE),
            "CAR_PROJECTED" => ::std::option::Option::Some(AudioOutputDeviceType::CAR_PROJECTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AudioOutputDeviceType] = &[
        AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE,
        AudioOutputDeviceType::BUILT_IN_SPEAKER,
        AudioOutputDeviceType::LINE_OUT,
        AudioOutputDeviceType::BLUETOOTH,
        AudioOutputDeviceType::AIRPLAY,
        AudioOutputDeviceType::AUTOMOTIVE,
        AudioOutputDeviceType::CAR_PROJECTED,
    ];
}

impl ::protobuf::EnumFull for AudioOutputDeviceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AudioOutputDeviceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AudioOutputDeviceType {
    fn default() -> Self {
        AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE
    }
}

impl AudioOutputDeviceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AudioOutputDeviceType>("AudioOutputDeviceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.PutStateReason)
pub enum PutStateReason {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.UNKNOWN_PUT_STATE_REASON)
    UNKNOWN_PUT_STATE_REASON = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.SPIRC_HELLO)
    SPIRC_HELLO = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.SPIRC_NOTIFY)
    SPIRC_NOTIFY = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.NEW_DEVICE)
    NEW_DEVICE = 3,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.PLAYER_STATE_CHANGED)
    PLAYER_STATE_CHANGED = 4,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.VOLUME_CHANGED)
    VOLUME_CHANGED = 5,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.PICKER_OPENED)
    PICKER_OPENED = 6,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.BECAME_INACTIVE)
    BECAME_INACTIVE = 7,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.ALIAS_CHANGED)
    ALIAS_CHANGED = 8,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.NEW_CONNECTION)
    NEW_CONNECTION = 9,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.PULL_PLAYBACK)
    PULL_PLAYBACK = 10,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.AUDIO_DRIVER_INFO_CHANGED)
    AUDIO_DRIVER_INFO_CHANGED = 11,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.PUT_STATE_RATE_LIMITED)
    PUT_STATE_RATE_LIMITED = 12,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.BACKEND_METADATA_APPLIED)
    BACKEND_METADATA_APPLIED = 13,
}

impl ::protobuf::Enum for PutStateReason {
    const NAME: &'static str = "PutStateReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PutStateReason> {
        match value {
            0 => ::std::option::Option::Some(PutStateReason::UNKNOWN_PUT_STATE_REASON),
            1 => ::std::option::Option::Some(PutStateReason::SPIRC_HELLO),
            2 => ::std::option::Option::Some(PutStateReason::SPIRC_NOTIFY),
            3 => ::std::option::Option::Some(PutStateReason::NEW_DEVICE),
            4 => ::std::option::Option::Some(PutStateReason::PLAYER_STATE_CHANGED),
            5 => ::std::option::Option::Some(PutStateReason::VOLUME_CHANGED),
            6 => ::std::option::Option::Some(PutStateReason::PICKER_OPENED),
            7 => ::std::option::Option::Some(PutStateReason::BECAME_INACTIVE),
            8 => ::std::option::Option::Some(PutStateReason::ALIAS_CHANGED),
            9 => ::std::option::Option::Some(PutStateReason::NEW_CONNECTION),
            10 => ::std::option::Option::Some(PutStateReason::PULL_PLAYBACK),
            11 => ::std::option::Option::Some(PutStateReason::AUDIO_DRIVER_INFO_CHANGED),
            12 => ::std::option::Option::Some(PutStateReason::PUT_STATE_RATE_LIMITED),
            13 => ::std::option::Option::Some(PutStateReason::BACKEND_METADATA_APPLIED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PutStateReason> {
        match str {
            "UNKNOWN_PUT_STATE_REASON" => ::std::option::Option::Some(PutStateReason::UNKNOWN_PUT_STATE_REASON),
            "SPIRC_HELLO" => ::std::option::Option::Some(PutStateReason::SPIRC_HELLO),
            "SPIRC_NOTIFY" => ::std::option::Option::Some(PutStateReason::SPIRC_NOTIFY),
            "NEW_DEVICE" => ::std::option::Option::Some(PutStateReason::NEW_DEVICE),
            "PLAYER_STATE_CHANGED" => ::std::option::Option::Some(PutStateReason::PLAYER_STATE_CHANGED),
            "VOLUME_CHANGED" => ::std::option::Option::Some(PutStateReason::VOLUME_CHANGED),
            "PICKER_OPENED" => ::std::option::Option::Some(PutStateReason::PICKER_OPENED),
            "BECAME_INACTIVE" => ::std::option::Option::Some(PutStateReason::BECAME_INACTIVE),
            "ALIAS_CHANGED" => ::std::option::Option::Some(PutStateReason::ALIAS_CHANGED),
            "NEW_CONNECTION" => ::std::option::Option::Some(PutStateReason::NEW_CONNECTION),
            "PULL_PLAYBACK" => ::std::option::Option::Some(PutStateReason::PULL_PLAYBACK),
            "AUDIO_DRIVER_INFO_CHANGED" => ::std::option::Option::Some(PutStateReason::AUDIO_DRIVER_INFO_CHANGED),
            "PUT_STATE_RATE_LIMITED" => ::std::option::Option::Some(PutStateReason::PUT_STATE_RATE_LIMITED),
            "BACKEND_METADATA_APPLIED" => ::std::option::Option::Some(PutStateReason::BACKEND_METADATA_APPLIED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PutStateReason] = &[
        PutStateReason::UNKNOWN_PUT_STATE_REASON,
        PutStateReason::SPIRC_HELLO,
        PutStateReason::SPIRC_NOTIFY,
        PutStateReason::NEW_DEVICE,
        PutStateReason::PLAYER_STATE_CHANGED,
        PutStateReason::VOLUME_CHANGED,
        PutStateReason::PICKER_OPENED,
        PutStateReason::BECAME_INACTIVE,
        PutStateReason::ALIAS_CHANGED,
        PutStateReason::NEW_CONNECTION,
        PutStateReason::PULL_PLAYBACK,
        PutStateReason::AUDIO_DRIVER_INFO_CHANGED,
        PutStateReason::PUT_STATE_RATE_LIMITED,
        PutStateReason::BACKEND_METADATA_APPLIED,
    ];
}

impl ::protobuf::EnumFull for PutStateReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PutStateReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PutStateReason {
    fn default() -> Self {
        PutStateReason::UNKNOWN_PUT_STATE_REASON
    }
}

impl PutStateReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PutStateReason>("PutStateReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.MemberType)
pub enum MemberType {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.SPIRC_V2)
    SPIRC_V2 = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.SPIRC_V3)
    SPIRC_V3 = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.CONNECT_STATE)
    CONNECT_STATE = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.CONNECT_STATE_EXTENDED)
    CONNECT_STATE_EXTENDED = 5,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.ACTIVE_DEVICE_TRACKER)
    ACTIVE_DEVICE_TRACKER = 6,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.PLAY_TOKEN)
    PLAY_TOKEN = 7,
}

impl ::protobuf::Enum for MemberType {
    const NAME: &'static str = "MemberType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MemberType> {
        match value {
            0 => ::std::option::Option::Some(MemberType::SPIRC_V2),
            1 => ::std::option::Option::Some(MemberType::SPIRC_V3),
            2 => ::std::option::Option::Some(MemberType::CONNECT_STATE),
            5 => ::std::option::Option::Some(MemberType::CONNECT_STATE_EXTENDED),
            6 => ::std::option::Option::Some(MemberType::ACTIVE_DEVICE_TRACKER),
            7 => ::std::option::Option::Some(MemberType::PLAY_TOKEN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MemberType> {
        match str {
            "SPIRC_V2" => ::std::option::Option::Some(MemberType::SPIRC_V2),
            "SPIRC_V3" => ::std::option::Option::Some(MemberType::SPIRC_V3),
            "CONNECT_STATE" => ::std::option::Option::Some(MemberType::CONNECT_STATE),
            "CONNECT_STATE_EXTENDED" => ::std::option::Option::Some(MemberType::CONNECT_STATE_EXTENDED),
            "ACTIVE_DEVICE_TRACKER" => ::std::option::Option::Some(MemberType::ACTIVE_DEVICE_TRACKER),
            "PLAY_TOKEN" => ::std::option::Option::Some(MemberType::PLAY_TOKEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MemberType] = &[
        MemberType::SPIRC_V2,
        MemberType::SPIRC_V3,
        MemberType::CONNECT_STATE,
        MemberType::CONNECT_STATE_EXTENDED,
        MemberType::ACTIVE_DEVICE_TRACKER,
        MemberType::PLAY_TOKEN,
    ];
}

impl ::protobuf::EnumFull for MemberType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MemberType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MemberType::SPIRC_V2 => 0,
            MemberType::SPIRC_V3 => 1,
            MemberType::CONNECT_STATE => 2,
            MemberType::CONNECT_STATE_EXTENDED => 3,
            MemberType::ACTIVE_DEVICE_TRACKER => 4,
            MemberType::PLAY_TOKEN => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MemberType {
    fn default() -> Self {
        MemberType::SPIRC_V2
    }
}

impl MemberType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MemberType>("MemberType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.ClusterUpdateReason)
pub enum ClusterUpdateReason {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.UNKNOWN_CLUSTER_UPDATE_REASON)
    UNKNOWN_CLUSTER_UPDATE_REASON = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICES_DISAPPEARED)
    DEVICES_DISAPPEARED = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICE_STATE_CHANGED)
    DEVICE_STATE_CHANGED = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.NEW_DEVICE_APPEARED)
    NEW_DEVICE_APPEARED = 3,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICE_VOLUME_CHANGED)
    DEVICE_VOLUME_CHANGED = 4,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICE_ALIAS_CHANGED)
    DEVICE_ALIAS_CHANGED = 5,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICE_NEW_CONNECTION)
    DEVICE_NEW_CONNECTION = 6,
}

impl ::protobuf::Enum for ClusterUpdateReason {
    const NAME: &'static str = "ClusterUpdateReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClusterUpdateReason> {
        match value {
            0 => ::std::option::Option::Some(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON),
            1 => ::std::option::Option::Some(ClusterUpdateReason::DEVICES_DISAPPEARED),
            2 => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_STATE_CHANGED),
            3 => ::std::option::Option::Some(ClusterUpdateReason::NEW_DEVICE_APPEARED),
            4 => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_VOLUME_CHANGED),
            5 => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_ALIAS_CHANGED),
            6 => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_NEW_CONNECTION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClusterUpdateReason> {
        match str {
            "UNKNOWN_CLUSTER_UPDATE_REASON" => ::std::option::Option::Some(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON),
            "DEVICES_DISAPPEARED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICES_DISAPPEARED),
            "DEVICE_STATE_CHANGED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_STATE_CHANGED),
            "NEW_DEVICE_APPEARED" => ::std::option::Option::Some(ClusterUpdateReason::NEW_DEVICE_APPEARED),
            "DEVICE_VOLUME_CHANGED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_VOLUME_CHANGED),
            "DEVICE_ALIAS_CHANGED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_ALIAS_CHANGED),
            "DEVICE_NEW_CONNECTION" => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_NEW_CONNECTION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClusterUpdateReason] = &[
        ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON,
        ClusterUpdateReason::DEVICES_DISAPPEARED,
        ClusterUpdateReason::DEVICE_STATE_CHANGED,
        ClusterUpdateReason::NEW_DEVICE_APPEARED,
        ClusterUpdateReason::DEVICE_VOLUME_CHANGED,
        ClusterUpdateReason::DEVICE_ALIAS_CHANGED,
        ClusterUpdateReason::DEVICE_NEW_CONNECTION,
    ];
}

impl ::protobuf::EnumFull for ClusterUpdateReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClusterUpdateReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClusterUpdateReason {
    fn default() -> Self {
        ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON
    }
}

impl ClusterUpdateReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClusterUpdateReason>("ClusterUpdateReason")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rconnect.proto\x12\x14spotify.connectstate\x1a\x0cplayer.proto\x1a\rd\
    evices.proto\x1a\x0bmedia.proto\"\xe1\x01\n\rClusterUpdate\x127\n\x07clu\
    ster\x18\x01\x20\x01(\x0b2\x1d.spotify.connectstate.ClusterR\x07cluster\
    \x12N\n\rupdate_reason\x18\x02\x20\x01(\x0e2).spotify.connectstate.Clust\
    erUpdateReasonR\x0cupdateReason\x12\x15\n\x06ack_id\x18\x03\x20\x01(\tR\
    \x05ackId\x120\n\x14devices_that_changed\x18\x04\x20\x03(\tR\x12devicesT\
    hatChanged\"\x8f\x02\n\x06Device\x12A\n\x0bdevice_info\x18\x01\x20\x01(\
    \x0b2\x20.spotify.connectstate.DeviceInfoR\ndeviceInfo\x12D\n\x0cplayer_\
    state\x18\x02\x20\x01(\x0b2!.spotify.connectstate.PlayerStateR\x0bplayer\
    State\x12W\n\x13private_device_info\x18\x03\x20\x01(\x0b2'.spotify.conne\
    ctstate.PrivateDeviceInfoR\x11privateDeviceInfo\x12#\n\rtransfer_data\
    \x18\x04\x20\x01(\x0cR\x0ctransferData\"\xc7\x05\n\x07Cluster\x120\n\x14\
    changed_timestamp_ms\x18\x01\x20\x01(\x03R\x12changedTimestampMs\x12(\n\
    \x10active_device_id\x18\x02\x20\x01(\tR\x0eactiveDeviceId\x12D\n\x0cpla\
    yer_state\x18\x03\x20\x01(\x0b2!.spotify.connectstate.PlayerStateR\x0bpl\
    ayerState\x12A\n\x06device\x18\x04\x20\x03(\x0b2).spotify.connectstate.C\
    luster.DeviceEntryR\x06device\x12#\n\rtransfer_data\x18\x05\x20\x01(\x0c\
    R\x0ctransferData\x126\n\x17transfer_data_timestamp\x18\x06\x20\x01(\x04\
    R\x15transferDataTimestamp\x123\n\x16need_full_player_state\x18\x08\x20\
    \x01(\x08R\x13needFullPlayerState\x12.\n\x13server_timestamp_ms\x18\t\
    \x20\x01(\x03R\x11serverTimestampMs\x123\n\x13needs_state_updates\x18\n\
    \x20\x01(\x08H\0R\x11needsStateUpdates\x88\x01\x01\x12D\n\x1cstarted_pla\
    ying_at_timestamp\x18\x0b\x20\x01(\x04H\x01R\x19startedPlayingAtTimestam\
    p\x88\x01\x01\x1a[\n\x0bDeviceEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x126\n\x05value\x18\x02\x20\x01(\x0b2\x20.spotify.connectstate.D\
    eviceInfoR\x05value:\x028\x01B\x16\n\x14_needs_state_updatesB\x1f\n\x1d_\
    started_playing_at_timestampJ\x04\x08\x07\x10\x08\"\x82\x05\n\x0fPutStat\
    eRequest\x12!\n\x0ccallback_url\x18\x01\x20\x01(\tR\x0bcallbackUrl\x124\
    \n\x06device\x18\x02\x20\x01(\x0b2\x1c.spotify.connectstate.DeviceR\x06d\
    evice\x12A\n\x0bmember_type\x18\x03\x20\x01(\x0e2\x20.spotify.connectsta\
    te.MemberTypeR\nmemberType\x12\x1b\n\tis_active\x18\x04\x20\x01(\x08R\
    \x08isActive\x12N\n\x10put_state_reason\x18\x05\x20\x01(\x0e2$.spotify.c\
    onnectstate.PutStateReasonR\x0eputStateReason\x12\x1d\n\nmessage_id\x18\
    \x06\x20\x01(\rR\tmessageId\x12A\n\x1elast_command_sent_by_device_id\x18\
    \x07\x20\x01(\tR\x19lastCommandSentByDeviceId\x125\n\x17last_command_mes\
    sage_id\x18\x08\x20\x01(\rR\x14lastCommandMessageId\x12,\n\x12started_pl\
    aying_at\x18\t\x20\x01(\x04R\x10startedPlayingAt\x124\n\x17has_been_play\
    ing_for_ms\x18\x0b\x20\x01(\x04R\x13hasBeenPlayingForMs\x122\n\x15client\
    _side_timestamp\x18\x0c\x20\x01(\x04R\x13clientSideTimestamp\x125\n\x17o\
    nly_write_player_state\x18\r\x20\x01(\x08R\x14onlyWritePlayerState\"/\n\
    \x11PrivateDeviceInfo\x12\x1a\n\x08platform\x18\x01\x20\x01(\tR\x08platf\
    orm\"\xfb\n\n\nDeviceInfo\x12\x19\n\x08can_play\x18\x01\x20\x01(\x08R\
    \x07canPlay\x12\x16\n\x06volume\x18\x02\x20\x01(\rR\x06volume\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\x12F\n\x0ccapabilities\x18\x04\x20\
    \x01(\x0b2\".spotify.connectstate.CapabilitiesR\x0ccapabilities\x126\n\
    \x17device_software_version\x18\x06\x20\x01(\tR\x15deviceSoftwareVersion\
    \x12I\n\x0bdevice_type\x18\x07\x20\x01(\x0e2(.spotify.connectstate.devic\
    es.DeviceTypeR\ndeviceType\x12#\n\rspirc_version\x18\t\x20\x01(\tR\x0csp\
    ircVersion\x12\x1b\n\tdevice_id\x18\n\x20\x01(\tR\x08deviceId\x12,\n\x12\
    is_private_session\x18\x0b\x20\x01(\x08R\x10isPrivateSession\x12*\n\x11i\
    s_social_connect\x18\x0c\x20\x01(\x08R\x0fisSocialConnect\x12\x1b\n\tcli\
    ent_id\x18\r\x20\x01(\tR\x08clientId\x12\x14\n\x05brand\x18\x0e\x20\x01(\
    \tR\x05brand\x12\x14\n\x05model\x18\x0f\x20\x01(\tR\x05model\x12T\n\x0cm\
    etadata_map\x18\x10\x20\x03(\x0b21.spotify.connectstate.DeviceInfo.Metad\
    ataMapEntryR\x0bmetadataMap\x12\x1d\n\nproduct_id\x18\x11\x20\x01(\tR\tp\
    roductId\x12)\n\x10deduplication_id\x18\x12\x20\x01(\tR\x0fdeduplication\
    Id\x12*\n\x11selected_alias_id\x18\x13\x20\x01(\rR\x0fselectedAliasId\
    \x12Z\n\x0edevice_aliases\x18\x14\x20\x03(\x0b23.spotify.connectstate.De\
    viceInfo.DeviceAliasesEntryR\rdeviceAliases\x12\x1d\n\nis_offline\x18\
    \x15\x20\x01(\x08R\tisOffline\x12\x1b\n\tpublic_ip\x18\x16\x20\x01(\tR\
    \x08publicIp\x12\x18\n\x07license\x18\x17\x20\x01(\tR\x07license\x12\x19\
    \n\x08is_group\x18\x19\x20\x01(\x08R\x07isGroup\x12*\n\x11is_dynamic_dev\
    ice\x18\x1a\x20\x01(\x08R\x0fisDynamicDevice\x12:\n\x19disallow_playback\
    _reasons\x18\x1b\x20\x03(\tR\x17disallowPlaybackReasons\x12:\n\x19disall\
    ow_transfer_reasons\x18\x1c\x20\x03(\tR\x17disallowTransferReasons\x12i\
    \n\x18audio_output_device_info\x18\x18\x20\x01(\x0b2+.spotify.connectsta\
    te.AudioOutputDeviceInfoH\0R\x15audioOutputDeviceInfo\x88\x01\x01\x1a>\n\
    \x10MetadataMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1ak\n\x12DeviceAlias\
    esEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12?\n\x05value\x18\
    \x02\x20\x01(\x0b2).spotify.connectstate.devices.DeviceAliasR\x05value:\
    \x028\x01B\x1b\n\x19_audio_output_device_infoJ\x04\x08\x05\x10\x06\"\xd5\
    \x01\n\x15AudioOutputDeviceInfo\x12i\n\x18audio_output_device_type\x18\
    \x01\x20\x01(\x0e2+.spotify.connectstate.AudioOutputDeviceTypeH\0R\x15au\
    dioOutputDeviceType\x88\x01\x01\x12$\n\x0bdevice_name\x18\x02\x20\x01(\t\
    H\x01R\ndeviceName\x88\x01\x01B\x1b\n\x19_audio_output_device_typeB\x0e\
    \n\x0c_device_name\"\xec\n\n\x0cCapabilities\x12\"\n\rcan_be_player\x18\
    \x02\x20\x01(\x08R\x0bcanBePlayer\x12*\n\x11restrict_to_local\x18\x03\
    \x20\x01(\x08R\x0frestrictToLocal\x12+\n\x12gaia_eq_connect_id\x18\x05\
    \x20\x01(\x08R\x0fgaiaEqConnectId\x12'\n\x0fsupports_logout\x18\x06\x20\
    \x01(\x08R\x0esupportsLogout\x12#\n\ris_observable\x18\x07\x20\x01(\x08R\
    \x0cisObservable\x12!\n\x0cvolume_steps\x18\x08\x20\x01(\x05R\x0bvolumeS\
    teps\x12'\n\x0fsupported_types\x18\t\x20\x03(\tR\x0esupportedTypes\x12!\
    \n\x0ccommand_acks\x18\n\x20\x01(\x08R\x0bcommandAcks\x12'\n\x0fsupports\
    _rename\x18\x0b\x20\x01(\x08R\x0esupportsRename\x12\x16\n\x06hidden\x18\
    \x0c\x20\x01(\x08R\x06hidden\x12%\n\x0edisable_volume\x18\r\x20\x01(\x08\
    R\rdisableVolume\x12)\n\x10connect_disabled\x18\x0e\x20\x01(\x08R\x0fcon\
    nectDisabled\x120\n\x14supports_playlist_v2\x18\x0f\x20\x01(\x08R\x12sup\
    portsPlaylistV2\x12'\n\x0fis_controllable\x18\x10\x20\x01(\x08R\x0eisCon\
    trollable\x12<\n\x1asupports_external_episodes\x18\x11\x20\x01(\x08R\x18\
    supportsExternalEpisodes\x12A\n\x1dsupports_set_backend_metadata\x18\x12\
    \x20\x01(\x08R\x1asupportsSetBackendMetadata\x12:\n\x19supports_transfer\
    _command\x18\x13\x20\x01(\x08R\x17supportsTransferCommand\x128\n\x18supp\
    orts_command_request\x18\x14\x20\x01(\x08R\x16supportsCommandRequest\x12\
    (\n\x10is_voice_enabled\x18\x15\x20\x01(\x08R\x0eisVoiceEnabled\x125\n\
    \x17needs_full_player_state\x18\x16\x20\x01(\x08R\x14needsFullPlayerStat\
    e\x120\n\x14supports_gzip_pushes\x18\x17\x20\x01(\x08R\x12supportsGzipPu\
    shes\x12?\n\x1csupports_set_options_command\x18\x19\x20\x01(\x08R\x19sup\
    portsSetOptionsCommand\x12S\n\rsupports_hifi\x18\x1a\x20\x01(\x0b2..spot\
    ify.connectstate.CapabilitySupportDetailsR\x0csupportsHifi\x121\n\x14con\
    nect_capabilities\x18\x1b\x20\x01(\tR\x13connectCapabilities\x12%\n\x0es\
    upports_rooms\x18\x1c\x20\x01(\x08R\rsupportsRooms\x12\x1f\n\x0bsupports\
    _dj\x18\x1d\x20\x01(\x08R\nsupportsDj\x12Z\n\x17supported_audio_quality\
    \x18\x1e\x20\x01(\x0e2\".spotify.common.media.AudioQualityR\x15supported\
    AudioQualityJ\x04\x08\x01\x10\x02J\x04\x08\x04\x10\x05J\x04\x08\x18\x10\
    \x19R\x12supported_contextsR\x17supports_lossless_audio\"\x93\x01\n\x18C\
    apabilitySupportDetails\x12'\n\x0ffully_supported\x18\x01\x20\x01(\x08R\
    \x0efullySupported\x12#\n\ruser_eligible\x18\x02\x20\x01(\x08R\x0cuserEl\
    igible\x12)\n\x10device_supported\x18\x03\x20\x01(\x08R\x0fdeviceSupport\
    ed\"^\n\x15ConnectCommandOptions\x12\x1d\n\nmessage_id\x18\x01\x20\x01(\
    \x05R\tmessageId\x12&\n\x0ftarget_alias_id\x18\x03\x20\x01(\rR\rtargetAl\
    iasId\"k\n\x14ConnectLoggingParams\x12'\n\x0finteraction_ids\x18\x01\x20\
    \x03(\tR\x0einteractionIds\x12*\n\x11page_instance_ids\x18\x02\x20\x03(\
    \tR\x0fpageInstanceIds\"e\n\rLogoutCommand\x12T\n\x0fcommand_options\x18\
    \x01\x20\x01(\x0b2+.spotify.connectstate.ConnectCommandOptionsR\x0ecomma\
    ndOptions\"\xfc\x01\n\x10SetVolumeCommand\x12\x16\n\x06volume\x18\x01\
    \x20\x01(\x05R\x06volume\x12T\n\x0fcommand_options\x18\x02\x20\x01(\x0b2\
    +.spotify.connectstate.ConnectCommandOptionsR\x0ecommandOptions\x12Q\n\
    \x0elogging_params\x18\x03\x20\x01(\x0b2*.spotify.connectstate.ConnectLo\
    ggingParamsR\rloggingParams\x12'\n\x0fconnection_type\x18\x04\x20\x01(\t\
    R\x0econnectionType\"\x82\x01\n\rRenameCommand\x12\x1b\n\trename_to\x18\
    \x01\x20\x01(\tR\x08renameTo\x12T\n\x0fcommand_options\x18\x02\x20\x01(\
    \x0b2+.spotify.connectstate.ConnectCommandOptionsR\x0ecommandOptions\"\
    \xb3\x01\n\x19SetBackendMetadataCommand\x12Y\n\x08metadata\x18\x01\x20\
    \x03(\x0b2=.spotify.connectstate.SetBackendMetadataCommand.MetadataEntry\
    R\x08metadata\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01*\xa0\
    \x01\n\x15AudioOutputDeviceType\x12$\n\x20UNKNOWN_AUDIO_OUTPUT_DEVICE_TY\
    PE\x10\0\x12\x14\n\x10BUILT_IN_SPEAKER\x10\x01\x12\x0c\n\x08LINE_OUT\x10\
    \x02\x12\r\n\tBLUETOOTH\x10\x03\x12\x0b\n\x07AIRPLAY\x10\x04\x12\x0e\n\n\
    AUTOMOTIVE\x10\x05\x12\x11\n\rCAR_PROJECTED\x10\x06*\xca\x02\n\x0ePutSta\
    teReason\x12\x1c\n\x18UNKNOWN_PUT_STATE_REASON\x10\0\x12\x0f\n\x0bSPIRC_\
    HELLO\x10\x01\x12\x10\n\x0cSPIRC_NOTIFY\x10\x02\x12\x0e\n\nNEW_DEVICE\
    \x10\x03\x12\x18\n\x14PLAYER_STATE_CHANGED\x10\x04\x12\x12\n\x0eVOLUME_C\
    HANGED\x10\x05\x12\x11\n\rPICKER_OPENED\x10\x06\x12\x13\n\x0fBECAME_INAC\
    TIVE\x10\x07\x12\x11\n\rALIAS_CHANGED\x10\x08\x12\x12\n\x0eNEW_CONNECTIO\
    N\x10\t\x12\x11\n\rPULL_PLAYBACK\x10\n\x12\x1d\n\x19AUDIO_DRIVER_INFO_CH\
    ANGED\x10\x0b\x12\x1a\n\x16PUT_STATE_RATE_LIMITED\x10\x0c\x12\x1c\n\x18B\
    ACKEND_METADATA_APPLIED\x10\r*\x82\x01\n\nMemberType\x12\x0c\n\x08SPIRC_\
    V2\x10\0\x12\x0c\n\x08SPIRC_V3\x10\x01\x12\x11\n\rCONNECT_STATE\x10\x02\
    \x12\x1a\n\x16CONNECT_STATE_EXTENDED\x10\x05\x12\x19\n\x15ACTIVE_DEVICE_\
    TRACKER\x10\x06\x12\x0e\n\nPLAY_TOKEN\x10\x07*\xd4\x01\n\x13ClusterUpdat\
    eReason\x12!\n\x1dUNKNOWN_CLUSTER_UPDATE_REASON\x10\0\x12\x17\n\x13DEVIC\
    ES_DISAPPEARED\x10\x01\x12\x18\n\x14DEVICE_STATE_CHANGED\x10\x02\x12\x17\
    \n\x13NEW_DEVICE_APPEARED\x10\x03\x12\x19\n\x15DEVICE_VOLUME_CHANGED\x10\
    \x04\x12\x18\n\x14DEVICE_ALIAS_CHANGED\x10\x05\x12\x19\n\x15DEVICE_NEW_C\
    ONNECTION\x10\x06B\"\n\x1ecom.spotify.connectstate.modelH\x02b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::player::file_descriptor().clone());
            deps.push(super::devices::file_descriptor().clone());
            deps.push(super::media::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(ClusterUpdate::generated_message_descriptor_data());
            messages.push(Device::generated_message_descriptor_data());
            messages.push(Cluster::generated_message_descriptor_data());
            messages.push(PutStateRequest::generated_message_descriptor_data());
            messages.push(PrivateDeviceInfo::generated_message_descriptor_data());
            messages.push(DeviceInfo::generated_message_descriptor_data());
            messages.push(AudioOutputDeviceInfo::generated_message_descriptor_data());
            messages.push(Capabilities::generated_message_descriptor_data());
            messages.push(CapabilitySupportDetails::generated_message_descriptor_data());
            messages.push(ConnectCommandOptions::generated_message_descriptor_data());
            messages.push(ConnectLoggingParams::generated_message_descriptor_data());
            messages.push(LogoutCommand::generated_message_descriptor_data());
            messages.push(SetVolumeCommand::generated_message_descriptor_data());
            messages.push(RenameCommand::generated_message_descriptor_data());
            messages.push(SetBackendMetadataCommand::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(AudioOutputDeviceType::generated_enum_descriptor_data());
            enums.push(PutStateReason::generated_enum_descriptor_data());
            enums.push(MemberType::generated_enum_descriptor_data());
            enums.push(ClusterUpdateReason::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
