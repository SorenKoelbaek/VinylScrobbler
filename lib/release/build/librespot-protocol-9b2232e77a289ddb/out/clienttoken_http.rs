// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `spotify/clienttoken/v0/clienttoken_http.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ClientTokenRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientTokenRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ClientTokenRequest.request_type)
    pub request_type: ::protobuf::EnumOrUnknown<ClientTokenRequestType>,
    // message oneof groups
    pub request: ::std::option::Option<client_token_request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ClientTokenRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientTokenRequest {
    fn default() -> &'a ClientTokenRequest {
        <ClientTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClientTokenRequest {
    pub fn new() -> ClientTokenRequest {
        ::std::default::Default::default()
    }

    // .spotify.clienttoken.http.v0.ClientDataRequest client_data = 2;

    pub fn client_data(&self) -> &ClientDataRequest {
        match self.request {
            ::std::option::Option::Some(client_token_request::Request::ClientData(ref v)) => v,
            _ => <ClientDataRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_client_data(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_client_data(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(client_token_request::Request::ClientData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_client_data(&mut self, v: ClientDataRequest) {
        self.request = ::std::option::Option::Some(client_token_request::Request::ClientData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_client_data(&mut self) -> &mut ClientDataRequest {
        if let ::std::option::Option::Some(client_token_request::Request::ClientData(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(client_token_request::Request::ClientData(ClientDataRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(client_token_request::Request::ClientData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_client_data(&mut self) -> ClientDataRequest {
        if self.has_client_data() {
            match self.request.take() {
                ::std::option::Option::Some(client_token_request::Request::ClientData(v)) => v,
                _ => panic!(),
            }
        } else {
            ClientDataRequest::new()
        }
    }

    // .spotify.clienttoken.http.v0.ChallengeAnswersRequest challenge_answers = 3;

    pub fn challenge_answers(&self) -> &ChallengeAnswersRequest {
        match self.request {
            ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(ref v)) => v,
            _ => <ChallengeAnswersRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_challenge_answers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_challenge_answers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_challenge_answers(&mut self, v: ChallengeAnswersRequest) {
        self.request = ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_challenge_answers(&mut self) -> &mut ChallengeAnswersRequest {
        if let ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(ChallengeAnswersRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_challenge_answers(&mut self) -> ChallengeAnswersRequest {
        if self.has_challenge_answers() {
            match self.request.take() {
                ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(v)) => v,
                _ => panic!(),
            }
        } else {
            ChallengeAnswersRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_type",
            |m: &ClientTokenRequest| { &m.request_type },
            |m: &mut ClientTokenRequest| { &mut m.request_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ClientDataRequest>(
            "client_data",
            ClientTokenRequest::has_client_data,
            ClientTokenRequest::client_data,
            ClientTokenRequest::mut_client_data,
            ClientTokenRequest::set_client_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ChallengeAnswersRequest>(
            "challenge_answers",
            ClientTokenRequest::has_challenge_answers,
            ClientTokenRequest::challenge_answers,
            ClientTokenRequest::mut_challenge_answers,
            ClientTokenRequest::set_challenge_answers,
        ));
        oneofs.push(client_token_request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientTokenRequest>(
            "ClientTokenRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientTokenRequest {
    const NAME: &'static str = "ClientTokenRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.request = ::std::option::Option::Some(client_token_request::Request::ClientData(is.read_message()?));
                },
                26 => {
                    self.request = ::std::option::Option::Some(client_token_request::Request::ChallengeAnswers(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.request_type != ::protobuf::EnumOrUnknown::new(ClientTokenRequestType::REQUEST_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.request_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &client_token_request::Request::ClientData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_token_request::Request::ChallengeAnswers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.request_type != ::protobuf::EnumOrUnknown::new(ClientTokenRequestType::REQUEST_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.request_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &client_token_request::Request::ClientData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &client_token_request::Request::ChallengeAnswers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientTokenRequest {
        ClientTokenRequest::new()
    }

    fn clear(&mut self) {
        self.request_type = ::protobuf::EnumOrUnknown::new(ClientTokenRequestType::REQUEST_UNKNOWN);
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientTokenRequest {
        static instance: ClientTokenRequest = ClientTokenRequest {
            request_type: ::protobuf::EnumOrUnknown::from_i32(0),
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientTokenRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientTokenRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientTokenRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClientTokenRequest`
pub mod client_token_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.clienttoken.http.v0.ClientTokenRequest.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ClientTokenRequest.client_data)
        ClientData(super::ClientDataRequest),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ClientTokenRequest.challenge_answers)
        ChallengeAnswers(super::ChallengeAnswersRequest),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ClientTokenRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ClientDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientDataRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ClientDataRequest.client_version)
    pub client_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ClientDataRequest.client_id)
    pub client_id: ::std::string::String,
    // message oneof groups
    pub data: ::std::option::Option<client_data_request::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ClientDataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientDataRequest {
    fn default() -> &'a ClientDataRequest {
        <ClientDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClientDataRequest {
    pub fn new() -> ClientDataRequest {
        ::std::default::Default::default()
    }

    // .spotify.clienttoken.data.v0.ConnectivitySdkData connectivity_sdk_data = 3;

    pub fn connectivity_sdk_data(&self) -> &super::connectivity::ConnectivitySdkData {
        match self.data {
            ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(ref v)) => v,
            _ => <super::connectivity::ConnectivitySdkData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_connectivity_sdk_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_connectivity_sdk_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connectivity_sdk_data(&mut self, v: super::connectivity::ConnectivitySdkData) {
        self.data = ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connectivity_sdk_data(&mut self) -> &mut super::connectivity::ConnectivitySdkData {
        if let ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(super::connectivity::ConnectivitySdkData::new()));
        }
        match self.data {
            ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connectivity_sdk_data(&mut self) -> super::connectivity::ConnectivitySdkData {
        if self.has_connectivity_sdk_data() {
            match self.data.take() {
                ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::connectivity::ConnectivitySdkData::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_version",
            |m: &ClientDataRequest| { &m.client_version },
            |m: &mut ClientDataRequest| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &ClientDataRequest| { &m.client_id },
            |m: &mut ClientDataRequest| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::connectivity::ConnectivitySdkData>(
            "connectivity_sdk_data",
            ClientDataRequest::has_connectivity_sdk_data,
            ClientDataRequest::connectivity_sdk_data,
            ClientDataRequest::mut_connectivity_sdk_data,
            ClientDataRequest::set_connectivity_sdk_data,
        ));
        oneofs.push(client_data_request::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientDataRequest>(
            "ClientDataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientDataRequest {
    const NAME: &'static str = "ClientDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_version = is.read_string()?;
                },
                18 => {
                    self.client_id = is.read_string()?;
                },
                26 => {
                    self.data = ::std::option::Option::Some(client_data_request::Data::ConnectivitySdkData(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_version);
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_id);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &client_data_request::Data::ConnectivitySdkData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_version.is_empty() {
            os.write_string(1, &self.client_version)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(2, &self.client_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &client_data_request::Data::ConnectivitySdkData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientDataRequest {
        ClientDataRequest::new()
    }

    fn clear(&mut self) {
        self.client_version.clear();
        self.client_id.clear();
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientDataRequest {
        static instance: ClientDataRequest = ClientDataRequest {
            client_version: ::std::string::String::new(),
            client_id: ::std::string::String::new(),
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientDataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientDataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClientDataRequest`
pub mod client_data_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.clienttoken.http.v0.ClientDataRequest.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ClientDataRequest.connectivity_sdk_data)
        ConnectivitySdkData(super::super::connectivity::ConnectivitySdkData),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ClientDataRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ChallengeAnswersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChallengeAnswersRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ChallengeAnswersRequest.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ChallengeAnswersRequest.answers)
    pub answers: ::std::vec::Vec<ChallengeAnswer>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ChallengeAnswersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChallengeAnswersRequest {
    fn default() -> &'a ChallengeAnswersRequest {
        <ChallengeAnswersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeAnswersRequest {
    pub fn new() -> ChallengeAnswersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &ChallengeAnswersRequest| { &m.state },
            |m: &mut ChallengeAnswersRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "answers",
            |m: &ChallengeAnswersRequest| { &m.answers },
            |m: &mut ChallengeAnswersRequest| { &mut m.answers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChallengeAnswersRequest>(
            "ChallengeAnswersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChallengeAnswersRequest {
    const NAME: &'static str = "ChallengeAnswersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state = is.read_string()?;
                },
                18 => {
                    self.answers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.state);
        }
        for value in &self.answers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state.is_empty() {
            os.write_string(1, &self.state)?;
        }
        for v in &self.answers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChallengeAnswersRequest {
        ChallengeAnswersRequest::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.answers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChallengeAnswersRequest {
        static instance: ChallengeAnswersRequest = ChallengeAnswersRequest {
            state: ::std::string::String::new(),
            answers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChallengeAnswersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChallengeAnswersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChallengeAnswersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeAnswersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ClientTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ClientTokenResponse.response_type)
    pub response_type: ::protobuf::EnumOrUnknown<ClientTokenResponseType>,
    // message oneof groups
    pub response: ::std::option::Option<client_token_response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ClientTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientTokenResponse {
    fn default() -> &'a ClientTokenResponse {
        <ClientTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClientTokenResponse {
    pub fn new() -> ClientTokenResponse {
        ::std::default::Default::default()
    }

    // .spotify.clienttoken.http.v0.GrantedTokenResponse granted_token = 2;

    pub fn granted_token(&self) -> &GrantedTokenResponse {
        match self.response {
            ::std::option::Option::Some(client_token_response::Response::GrantedToken(ref v)) => v,
            _ => <GrantedTokenResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_granted_token(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_granted_token(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(client_token_response::Response::GrantedToken(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_granted_token(&mut self, v: GrantedTokenResponse) {
        self.response = ::std::option::Option::Some(client_token_response::Response::GrantedToken(v))
    }

    // Mutable pointer to the field.
    pub fn mut_granted_token(&mut self) -> &mut GrantedTokenResponse {
        if let ::std::option::Option::Some(client_token_response::Response::GrantedToken(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(client_token_response::Response::GrantedToken(GrantedTokenResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(client_token_response::Response::GrantedToken(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_granted_token(&mut self) -> GrantedTokenResponse {
        if self.has_granted_token() {
            match self.response.take() {
                ::std::option::Option::Some(client_token_response::Response::GrantedToken(v)) => v,
                _ => panic!(),
            }
        } else {
            GrantedTokenResponse::new()
        }
    }

    // .spotify.clienttoken.http.v0.ChallengesResponse challenges = 3;

    pub fn challenges(&self) -> &ChallengesResponse {
        match self.response {
            ::std::option::Option::Some(client_token_response::Response::Challenges(ref v)) => v,
            _ => <ChallengesResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_challenges(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_challenges(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(client_token_response::Response::Challenges(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_challenges(&mut self, v: ChallengesResponse) {
        self.response = ::std::option::Option::Some(client_token_response::Response::Challenges(v))
    }

    // Mutable pointer to the field.
    pub fn mut_challenges(&mut self) -> &mut ChallengesResponse {
        if let ::std::option::Option::Some(client_token_response::Response::Challenges(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(client_token_response::Response::Challenges(ChallengesResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(client_token_response::Response::Challenges(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_challenges(&mut self) -> ChallengesResponse {
        if self.has_challenges() {
            match self.response.take() {
                ::std::option::Option::Some(client_token_response::Response::Challenges(v)) => v,
                _ => panic!(),
            }
        } else {
            ChallengesResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_type",
            |m: &ClientTokenResponse| { &m.response_type },
            |m: &mut ClientTokenResponse| { &mut m.response_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GrantedTokenResponse>(
            "granted_token",
            ClientTokenResponse::has_granted_token,
            ClientTokenResponse::granted_token,
            ClientTokenResponse::mut_granted_token,
            ClientTokenResponse::set_granted_token,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ChallengesResponse>(
            "challenges",
            ClientTokenResponse::has_challenges,
            ClientTokenResponse::challenges,
            ClientTokenResponse::mut_challenges,
            ClientTokenResponse::set_challenges,
        ));
        oneofs.push(client_token_response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientTokenResponse>(
            "ClientTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientTokenResponse {
    const NAME: &'static str = "ClientTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.response = ::std::option::Option::Some(client_token_response::Response::GrantedToken(is.read_message()?));
                },
                26 => {
                    self.response = ::std::option::Option::Some(client_token_response::Response::Challenges(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.response_type != ::protobuf::EnumOrUnknown::new(ClientTokenResponseType::RESPONSE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.response_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &client_token_response::Response::GrantedToken(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_token_response::Response::Challenges(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.response_type != ::protobuf::EnumOrUnknown::new(ClientTokenResponseType::RESPONSE_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.response_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &client_token_response::Response::GrantedToken(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &client_token_response::Response::Challenges(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientTokenResponse {
        ClientTokenResponse::new()
    }

    fn clear(&mut self) {
        self.response_type = ::protobuf::EnumOrUnknown::new(ClientTokenResponseType::RESPONSE_UNKNOWN);
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientTokenResponse {
        static instance: ClientTokenResponse = ClientTokenResponse {
            response_type: ::protobuf::EnumOrUnknown::from_i32(0),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientTokenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientTokenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClientTokenResponse`
pub mod client_token_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.clienttoken.http.v0.ClientTokenResponse.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ClientTokenResponse.granted_token)
        GrantedToken(super::GrantedTokenResponse),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ClientTokenResponse.challenges)
        Challenges(super::ChallengesResponse),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ClientTokenResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.TokenDomain)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenDomain {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.TokenDomain.domain)
    pub domain: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.TokenDomain.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenDomain {
    fn default() -> &'a TokenDomain {
        <TokenDomain as ::protobuf::Message>::default_instance()
    }
}

impl TokenDomain {
    pub fn new() -> TokenDomain {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "domain",
            |m: &TokenDomain| { &m.domain },
            |m: &mut TokenDomain| { &mut m.domain },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenDomain>(
            "TokenDomain",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenDomain {
    const NAME: &'static str = "TokenDomain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenDomain {
        TokenDomain::new()
    }

    fn clear(&mut self) {
        self.domain.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenDomain {
        static instance: TokenDomain = TokenDomain {
            domain: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenDomain {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenDomain").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenDomain {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.GrantedTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GrantedTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.GrantedTokenResponse.token)
    pub token: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.GrantedTokenResponse.expires_after_seconds)
    pub expires_after_seconds: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.GrantedTokenResponse.refresh_after_seconds)
    pub refresh_after_seconds: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.GrantedTokenResponse.domains)
    pub domains: ::std::vec::Vec<TokenDomain>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.GrantedTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GrantedTokenResponse {
    fn default() -> &'a GrantedTokenResponse {
        <GrantedTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl GrantedTokenResponse {
    pub fn new() -> GrantedTokenResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &GrantedTokenResponse| { &m.token },
            |m: &mut GrantedTokenResponse| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expires_after_seconds",
            |m: &GrantedTokenResponse| { &m.expires_after_seconds },
            |m: &mut GrantedTokenResponse| { &mut m.expires_after_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refresh_after_seconds",
            |m: &GrantedTokenResponse| { &m.refresh_after_seconds },
            |m: &mut GrantedTokenResponse| { &mut m.refresh_after_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "domains",
            |m: &GrantedTokenResponse| { &m.domains },
            |m: &mut GrantedTokenResponse| { &mut m.domains },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GrantedTokenResponse>(
            "GrantedTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GrantedTokenResponse {
    const NAME: &'static str = "GrantedTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = is.read_string()?;
                },
                16 => {
                    self.expires_after_seconds = is.read_int32()?;
                },
                24 => {
                    self.refresh_after_seconds = is.read_int32()?;
                },
                34 => {
                    self.domains.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        if self.expires_after_seconds != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.expires_after_seconds);
        }
        if self.refresh_after_seconds != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.refresh_after_seconds);
        }
        for value in &self.domains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        if self.expires_after_seconds != 0 {
            os.write_int32(2, self.expires_after_seconds)?;
        }
        if self.refresh_after_seconds != 0 {
            os.write_int32(3, self.refresh_after_seconds)?;
        }
        for v in &self.domains {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GrantedTokenResponse {
        GrantedTokenResponse::new()
    }

    fn clear(&mut self) {
        self.token.clear();
        self.expires_after_seconds = 0;
        self.refresh_after_seconds = 0;
        self.domains.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GrantedTokenResponse {
        static instance: GrantedTokenResponse = GrantedTokenResponse {
            token: ::std::string::String::new(),
            expires_after_seconds: 0,
            refresh_after_seconds: 0,
            domains: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GrantedTokenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GrantedTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GrantedTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GrantedTokenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ChallengesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChallengesResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ChallengesResponse.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ChallengesResponse.challenges)
    pub challenges: ::std::vec::Vec<Challenge>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ChallengesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChallengesResponse {
    fn default() -> &'a ChallengesResponse {
        <ChallengesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChallengesResponse {
    pub fn new() -> ChallengesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &ChallengesResponse| { &m.state },
            |m: &mut ChallengesResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "challenges",
            |m: &ChallengesResponse| { &m.challenges },
            |m: &mut ChallengesResponse| { &mut m.challenges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChallengesResponse>(
            "ChallengesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChallengesResponse {
    const NAME: &'static str = "ChallengesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state = is.read_string()?;
                },
                18 => {
                    self.challenges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.state);
        }
        for value in &self.challenges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state.is_empty() {
            os.write_string(1, &self.state)?;
        }
        for v in &self.challenges {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChallengesResponse {
        ChallengesResponse::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.challenges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChallengesResponse {
        static instance: ChallengesResponse = ChallengesResponse {
            state: ::std::string::String::new(),
            challenges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChallengesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChallengesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChallengesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ClientSecretParameters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientSecretParameters {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ClientSecretParameters.salt)
    pub salt: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ClientSecretParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientSecretParameters {
    fn default() -> &'a ClientSecretParameters {
        <ClientSecretParameters as ::protobuf::Message>::default_instance()
    }
}

impl ClientSecretParameters {
    pub fn new() -> ClientSecretParameters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "salt",
            |m: &ClientSecretParameters| { &m.salt },
            |m: &mut ClientSecretParameters| { &mut m.salt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientSecretParameters>(
            "ClientSecretParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientSecretParameters {
    const NAME: &'static str = "ClientSecretParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.salt = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.salt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.salt.is_empty() {
            os.write_string(1, &self.salt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientSecretParameters {
        ClientSecretParameters::new()
    }

    fn clear(&mut self) {
        self.salt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientSecretParameters {
        static instance: ClientSecretParameters = ClientSecretParameters {
            salt: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientSecretParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientSecretParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientSecretParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientSecretParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.EvaluateJSParameters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvaluateJSParameters {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.EvaluateJSParameters.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.EvaluateJSParameters.libraries)
    pub libraries: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.EvaluateJSParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvaluateJSParameters {
    fn default() -> &'a EvaluateJSParameters {
        <EvaluateJSParameters as ::protobuf::Message>::default_instance()
    }
}

impl EvaluateJSParameters {
    pub fn new() -> EvaluateJSParameters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &EvaluateJSParameters| { &m.code },
            |m: &mut EvaluateJSParameters| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "libraries",
            |m: &EvaluateJSParameters| { &m.libraries },
            |m: &mut EvaluateJSParameters| { &mut m.libraries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvaluateJSParameters>(
            "EvaluateJSParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvaluateJSParameters {
    const NAME: &'static str = "EvaluateJSParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = is.read_string()?;
                },
                18 => {
                    self.libraries.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        for value in &self.libraries {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        for v in &self.libraries {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvaluateJSParameters {
        EvaluateJSParameters::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.libraries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvaluateJSParameters {
        static instance: EvaluateJSParameters = EvaluateJSParameters {
            code: ::std::string::String::new(),
            libraries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvaluateJSParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvaluateJSParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvaluateJSParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvaluateJSParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.HashCashParameters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HashCashParameters {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.HashCashParameters.length)
    pub length: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.HashCashParameters.prefix)
    pub prefix: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.HashCashParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HashCashParameters {
    fn default() -> &'a HashCashParameters {
        <HashCashParameters as ::protobuf::Message>::default_instance()
    }
}

impl HashCashParameters {
    pub fn new() -> HashCashParameters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &HashCashParameters| { &m.length },
            |m: &mut HashCashParameters| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &HashCashParameters| { &m.prefix },
            |m: &mut HashCashParameters| { &mut m.prefix },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HashCashParameters>(
            "HashCashParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HashCashParameters {
    const NAME: &'static str = "HashCashParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.length = is.read_int32()?;
                },
                18 => {
                    self.prefix = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.length != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.length);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.length != 0 {
            os.write_int32(1, self.length)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(2, &self.prefix)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HashCashParameters {
        HashCashParameters::new()
    }

    fn clear(&mut self) {
        self.length = 0;
        self.prefix.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HashCashParameters {
        static instance: HashCashParameters = HashCashParameters {
            length: 0,
            prefix: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HashCashParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HashCashParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HashCashParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashCashParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.Challenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Challenge {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.Challenge.type)
    pub type_: ::protobuf::EnumOrUnknown<ChallengeType>,
    // message oneof groups
    pub parameters: ::std::option::Option<challenge::Parameters>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.Challenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Challenge {
    fn default() -> &'a Challenge {
        <Challenge as ::protobuf::Message>::default_instance()
    }
}

impl Challenge {
    pub fn new() -> Challenge {
        ::std::default::Default::default()
    }

    // .spotify.clienttoken.http.v0.ClientSecretParameters client_secret_parameters = 2;

    pub fn client_secret_parameters(&self) -> &ClientSecretParameters {
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(ref v)) => v,
            _ => <ClientSecretParameters as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_client_secret_parameters(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_client_secret_parameters(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_client_secret_parameters(&mut self, v: ClientSecretParameters) {
        self.parameters = ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(v))
    }

    // Mutable pointer to the field.
    pub fn mut_client_secret_parameters(&mut self) -> &mut ClientSecretParameters {
        if let ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(ClientSecretParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_client_secret_parameters(&mut self) -> ClientSecretParameters {
        if self.has_client_secret_parameters() {
            match self.parameters.take() {
                ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(v)) => v,
                _ => panic!(),
            }
        } else {
            ClientSecretParameters::new()
        }
    }

    // .spotify.clienttoken.http.v0.EvaluateJSParameters evaluate_js_parameters = 3;

    pub fn evaluate_js_parameters(&self) -> &EvaluateJSParameters {
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(ref v)) => v,
            _ => <EvaluateJSParameters as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_evaluate_js_parameters(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_evaluate_js_parameters(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_evaluate_js_parameters(&mut self, v: EvaluateJSParameters) {
        self.parameters = ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(v))
    }

    // Mutable pointer to the field.
    pub fn mut_evaluate_js_parameters(&mut self) -> &mut EvaluateJSParameters {
        if let ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(EvaluateJSParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_evaluate_js_parameters(&mut self) -> EvaluateJSParameters {
        if self.has_evaluate_js_parameters() {
            match self.parameters.take() {
                ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(v)) => v,
                _ => panic!(),
            }
        } else {
            EvaluateJSParameters::new()
        }
    }

    // .spotify.clienttoken.http.v0.HashCashParameters evaluate_hashcash_parameters = 4;

    pub fn evaluate_hashcash_parameters(&self) -> &HashCashParameters {
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(ref v)) => v,
            _ => <HashCashParameters as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_evaluate_hashcash_parameters(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_evaluate_hashcash_parameters(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_evaluate_hashcash_parameters(&mut self, v: HashCashParameters) {
        self.parameters = ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(v))
    }

    // Mutable pointer to the field.
    pub fn mut_evaluate_hashcash_parameters(&mut self) -> &mut HashCashParameters {
        if let ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(HashCashParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_evaluate_hashcash_parameters(&mut self) -> HashCashParameters {
        if self.has_evaluate_hashcash_parameters() {
            match self.parameters.take() {
                ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(v)) => v,
                _ => panic!(),
            }
        } else {
            HashCashParameters::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Challenge| { &m.type_ },
            |m: &mut Challenge| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ClientSecretParameters>(
            "client_secret_parameters",
            Challenge::has_client_secret_parameters,
            Challenge::client_secret_parameters,
            Challenge::mut_client_secret_parameters,
            Challenge::set_client_secret_parameters,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EvaluateJSParameters>(
            "evaluate_js_parameters",
            Challenge::has_evaluate_js_parameters,
            Challenge::evaluate_js_parameters,
            Challenge::mut_evaluate_js_parameters,
            Challenge::set_evaluate_js_parameters,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HashCashParameters>(
            "evaluate_hashcash_parameters",
            Challenge::has_evaluate_hashcash_parameters,
            Challenge::evaluate_hashcash_parameters,
            Challenge::mut_evaluate_hashcash_parameters,
            Challenge::set_evaluate_hashcash_parameters,
        ));
        oneofs.push(challenge::Parameters::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Challenge>(
            "Challenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Challenge {
    const NAME: &'static str = "Challenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.parameters = ::std::option::Option::Some(challenge::Parameters::ClientSecretParameters(is.read_message()?));
                },
                26 => {
                    self.parameters = ::std::option::Option::Some(challenge::Parameters::EvaluateJsParameters(is.read_message()?));
                },
                34 => {
                    self.parameters = ::std::option::Option::Some(challenge::Parameters::EvaluateHashcashParameters(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(ChallengeType::CHALLENGE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.parameters {
            match v {
                &challenge::Parameters::ClientSecretParameters(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &challenge::Parameters::EvaluateJsParameters(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &challenge::Parameters::EvaluateHashcashParameters(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(ChallengeType::CHALLENGE_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.parameters {
            match v {
                &challenge::Parameters::ClientSecretParameters(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &challenge::Parameters::EvaluateJsParameters(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &challenge::Parameters::EvaluateHashcashParameters(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Challenge {
        Challenge::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(ChallengeType::CHALLENGE_UNKNOWN);
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Challenge {
        static instance: Challenge = Challenge {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            parameters: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Challenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Challenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Challenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Challenge`
pub mod challenge {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.clienttoken.http.v0.Challenge.parameters)
    pub enum Parameters {
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.Challenge.client_secret_parameters)
        ClientSecretParameters(super::ClientSecretParameters),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.Challenge.evaluate_js_parameters)
        EvaluateJsParameters(super::EvaluateJSParameters),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.Challenge.evaluate_hashcash_parameters)
        EvaluateHashcashParameters(super::HashCashParameters),
    }

    impl ::protobuf::Oneof for Parameters {
    }

    impl ::protobuf::OneofFull for Parameters {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Challenge as ::protobuf::MessageFull>::descriptor().oneof_by_name("parameters").unwrap()).clone()
        }
    }

    impl Parameters {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Parameters>("parameters")
        }
    }
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ClientSecretHMACAnswer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientSecretHMACAnswer {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ClientSecretHMACAnswer.hmac)
    pub hmac: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ClientSecretHMACAnswer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientSecretHMACAnswer {
    fn default() -> &'a ClientSecretHMACAnswer {
        <ClientSecretHMACAnswer as ::protobuf::Message>::default_instance()
    }
}

impl ClientSecretHMACAnswer {
    pub fn new() -> ClientSecretHMACAnswer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hmac",
            |m: &ClientSecretHMACAnswer| { &m.hmac },
            |m: &mut ClientSecretHMACAnswer| { &mut m.hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientSecretHMACAnswer>(
            "ClientSecretHMACAnswer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientSecretHMACAnswer {
    const NAME: &'static str = "ClientSecretHMACAnswer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hmac = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hmac.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hmac);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hmac.is_empty() {
            os.write_string(1, &self.hmac)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientSecretHMACAnswer {
        ClientSecretHMACAnswer::new()
    }

    fn clear(&mut self) {
        self.hmac.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientSecretHMACAnswer {
        static instance: ClientSecretHMACAnswer = ClientSecretHMACAnswer {
            hmac: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientSecretHMACAnswer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientSecretHMACAnswer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientSecretHMACAnswer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientSecretHMACAnswer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.EvaluateJSAnswer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvaluateJSAnswer {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.EvaluateJSAnswer.result)
    pub result: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.EvaluateJSAnswer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvaluateJSAnswer {
    fn default() -> &'a EvaluateJSAnswer {
        <EvaluateJSAnswer as ::protobuf::Message>::default_instance()
    }
}

impl EvaluateJSAnswer {
    pub fn new() -> EvaluateJSAnswer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &EvaluateJSAnswer| { &m.result },
            |m: &mut EvaluateJSAnswer| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvaluateJSAnswer>(
            "EvaluateJSAnswer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvaluateJSAnswer {
    const NAME: &'static str = "EvaluateJSAnswer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.result = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.result.is_empty() {
            os.write_string(1, &self.result)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvaluateJSAnswer {
        EvaluateJSAnswer::new()
    }

    fn clear(&mut self) {
        self.result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvaluateJSAnswer {
        static instance: EvaluateJSAnswer = EvaluateJSAnswer {
            result: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvaluateJSAnswer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvaluateJSAnswer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvaluateJSAnswer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvaluateJSAnswer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.HashCashAnswer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HashCashAnswer {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.HashCashAnswer.suffix)
    pub suffix: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.HashCashAnswer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HashCashAnswer {
    fn default() -> &'a HashCashAnswer {
        <HashCashAnswer as ::protobuf::Message>::default_instance()
    }
}

impl HashCashAnswer {
    pub fn new() -> HashCashAnswer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "suffix",
            |m: &HashCashAnswer| { &m.suffix },
            |m: &mut HashCashAnswer| { &mut m.suffix },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HashCashAnswer>(
            "HashCashAnswer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HashCashAnswer {
    const NAME: &'static str = "HashCashAnswer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.suffix = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.suffix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.suffix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.suffix.is_empty() {
            os.write_string(1, &self.suffix)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HashCashAnswer {
        HashCashAnswer::new()
    }

    fn clear(&mut self) {
        self.suffix.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HashCashAnswer {
        static instance: HashCashAnswer = HashCashAnswer {
            suffix: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HashCashAnswer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HashCashAnswer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HashCashAnswer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashCashAnswer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ChallengeAnswer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChallengeAnswer {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ChallengeAnswer.ChallengeType)
    pub ChallengeType: ::protobuf::EnumOrUnknown<ChallengeType>,
    // message oneof groups
    pub answer: ::std::option::Option<challenge_answer::Answer>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ChallengeAnswer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChallengeAnswer {
    fn default() -> &'a ChallengeAnswer {
        <ChallengeAnswer as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeAnswer {
    pub fn new() -> ChallengeAnswer {
        ::std::default::Default::default()
    }

    // .spotify.clienttoken.http.v0.ClientSecretHMACAnswer client_secret = 2;

    pub fn client_secret(&self) -> &ClientSecretHMACAnswer {
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(ref v)) => v,
            _ => <ClientSecretHMACAnswer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_client_secret(&mut self) {
        self.answer = ::std::option::Option::None;
    }

    pub fn has_client_secret(&self) -> bool {
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ClientSecretHMACAnswer) {
        self.answer = ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(v))
    }

    // Mutable pointer to the field.
    pub fn mut_client_secret(&mut self) -> &mut ClientSecretHMACAnswer {
        if let ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(_)) = self.answer {
        } else {
            self.answer = ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(ClientSecretHMACAnswer::new()));
        }
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ClientSecretHMACAnswer {
        if self.has_client_secret() {
            match self.answer.take() {
                ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(v)) => v,
                _ => panic!(),
            }
        } else {
            ClientSecretHMACAnswer::new()
        }
    }

    // .spotify.clienttoken.http.v0.EvaluateJSAnswer evaluate_js = 3;

    pub fn evaluate_js(&self) -> &EvaluateJSAnswer {
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(ref v)) => v,
            _ => <EvaluateJSAnswer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_evaluate_js(&mut self) {
        self.answer = ::std::option::Option::None;
    }

    pub fn has_evaluate_js(&self) -> bool {
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_evaluate_js(&mut self, v: EvaluateJSAnswer) {
        self.answer = ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_evaluate_js(&mut self) -> &mut EvaluateJSAnswer {
        if let ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(_)) = self.answer {
        } else {
            self.answer = ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(EvaluateJSAnswer::new()));
        }
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_evaluate_js(&mut self) -> EvaluateJSAnswer {
        if self.has_evaluate_js() {
            match self.answer.take() {
                ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(v)) => v,
                _ => panic!(),
            }
        } else {
            EvaluateJSAnswer::new()
        }
    }

    // .spotify.clienttoken.http.v0.HashCashAnswer hash_cash = 4;

    pub fn hash_cash(&self) -> &HashCashAnswer {
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::HashCash(ref v)) => v,
            _ => <HashCashAnswer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hash_cash(&mut self) {
        self.answer = ::std::option::Option::None;
    }

    pub fn has_hash_cash(&self) -> bool {
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::HashCash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hash_cash(&mut self, v: HashCashAnswer) {
        self.answer = ::std::option::Option::Some(challenge_answer::Answer::HashCash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hash_cash(&mut self) -> &mut HashCashAnswer {
        if let ::std::option::Option::Some(challenge_answer::Answer::HashCash(_)) = self.answer {
        } else {
            self.answer = ::std::option::Option::Some(challenge_answer::Answer::HashCash(HashCashAnswer::new()));
        }
        match self.answer {
            ::std::option::Option::Some(challenge_answer::Answer::HashCash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hash_cash(&mut self) -> HashCashAnswer {
        if self.has_hash_cash() {
            match self.answer.take() {
                ::std::option::Option::Some(challenge_answer::Answer::HashCash(v)) => v,
                _ => panic!(),
            }
        } else {
            HashCashAnswer::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ChallengeType",
            |m: &ChallengeAnswer| { &m.ChallengeType },
            |m: &mut ChallengeAnswer| { &mut m.ChallengeType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ClientSecretHMACAnswer>(
            "client_secret",
            ChallengeAnswer::has_client_secret,
            ChallengeAnswer::client_secret,
            ChallengeAnswer::mut_client_secret,
            ChallengeAnswer::set_client_secret,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EvaluateJSAnswer>(
            "evaluate_js",
            ChallengeAnswer::has_evaluate_js,
            ChallengeAnswer::evaluate_js,
            ChallengeAnswer::mut_evaluate_js,
            ChallengeAnswer::set_evaluate_js,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HashCashAnswer>(
            "hash_cash",
            ChallengeAnswer::has_hash_cash,
            ChallengeAnswer::hash_cash,
            ChallengeAnswer::mut_hash_cash,
            ChallengeAnswer::set_hash_cash,
        ));
        oneofs.push(challenge_answer::Answer::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChallengeAnswer>(
            "ChallengeAnswer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChallengeAnswer {
    const NAME: &'static str = "ChallengeAnswer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ChallengeType = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.answer = ::std::option::Option::Some(challenge_answer::Answer::ClientSecret(is.read_message()?));
                },
                26 => {
                    self.answer = ::std::option::Option::Some(challenge_answer::Answer::EvaluateJs(is.read_message()?));
                },
                34 => {
                    self.answer = ::std::option::Option::Some(challenge_answer::Answer::HashCash(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ChallengeType != ::protobuf::EnumOrUnknown::new(ChallengeType::CHALLENGE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.ChallengeType.value());
        }
        if let ::std::option::Option::Some(ref v) = self.answer {
            match v {
                &challenge_answer::Answer::ClientSecret(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &challenge_answer::Answer::EvaluateJs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &challenge_answer::Answer::HashCash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ChallengeType != ::protobuf::EnumOrUnknown::new(ChallengeType::CHALLENGE_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.ChallengeType))?;
        }
        if let ::std::option::Option::Some(ref v) = self.answer {
            match v {
                &challenge_answer::Answer::ClientSecret(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &challenge_answer::Answer::EvaluateJs(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &challenge_answer::Answer::HashCash(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChallengeAnswer {
        ChallengeAnswer::new()
    }

    fn clear(&mut self) {
        self.ChallengeType = ::protobuf::EnumOrUnknown::new(ChallengeType::CHALLENGE_UNKNOWN);
        self.answer = ::std::option::Option::None;
        self.answer = ::std::option::Option::None;
        self.answer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChallengeAnswer {
        static instance: ChallengeAnswer = ChallengeAnswer {
            ChallengeType: ::protobuf::EnumOrUnknown::from_i32(0),
            answer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChallengeAnswer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChallengeAnswer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChallengeAnswer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeAnswer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ChallengeAnswer`
pub mod challenge_answer {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.clienttoken.http.v0.ChallengeAnswer.answer)
    pub enum Answer {
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ChallengeAnswer.client_secret)
        ClientSecret(super::ClientSecretHMACAnswer),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ChallengeAnswer.evaluate_js)
        EvaluateJs(super::EvaluateJSAnswer),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.http.v0.ChallengeAnswer.hash_cash)
        HashCash(super::HashCashAnswer),
    }

    impl ::protobuf::Oneof for Answer {
    }

    impl ::protobuf::OneofFull for Answer {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ChallengeAnswer as ::protobuf::MessageFull>::descriptor().oneof_by_name("answer").unwrap()).clone()
        }
    }

    impl Answer {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Answer>("answer")
        }
    }
}

// @@protoc_insertion_point(message:spotify.clienttoken.http.v0.ClientTokenBadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientTokenBadRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.http.v0.ClientTokenBadRequest.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.http.v0.ClientTokenBadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientTokenBadRequest {
    fn default() -> &'a ClientTokenBadRequest {
        <ClientTokenBadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClientTokenBadRequest {
    pub fn new() -> ClientTokenBadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &ClientTokenBadRequest| { &m.message },
            |m: &mut ClientTokenBadRequest| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientTokenBadRequest>(
            "ClientTokenBadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientTokenBadRequest {
    const NAME: &'static str = "ClientTokenBadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientTokenBadRequest {
        ClientTokenBadRequest::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientTokenBadRequest {
        static instance: ClientTokenBadRequest = ClientTokenBadRequest {
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientTokenBadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientTokenBadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientTokenBadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientTokenBadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.clienttoken.http.v0.ClientTokenRequestType)
pub enum ClientTokenRequestType {
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ClientTokenRequestType.REQUEST_UNKNOWN)
    REQUEST_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ClientTokenRequestType.REQUEST_CLIENT_DATA_REQUEST)
    REQUEST_CLIENT_DATA_REQUEST = 1,
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ClientTokenRequestType.REQUEST_CHALLENGE_ANSWERS_REQUEST)
    REQUEST_CHALLENGE_ANSWERS_REQUEST = 2,
}

impl ::protobuf::Enum for ClientTokenRequestType {
    const NAME: &'static str = "ClientTokenRequestType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientTokenRequestType> {
        match value {
            0 => ::std::option::Option::Some(ClientTokenRequestType::REQUEST_UNKNOWN),
            1 => ::std::option::Option::Some(ClientTokenRequestType::REQUEST_CLIENT_DATA_REQUEST),
            2 => ::std::option::Option::Some(ClientTokenRequestType::REQUEST_CHALLENGE_ANSWERS_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClientTokenRequestType> {
        match str {
            "REQUEST_UNKNOWN" => ::std::option::Option::Some(ClientTokenRequestType::REQUEST_UNKNOWN),
            "REQUEST_CLIENT_DATA_REQUEST" => ::std::option::Option::Some(ClientTokenRequestType::REQUEST_CLIENT_DATA_REQUEST),
            "REQUEST_CHALLENGE_ANSWERS_REQUEST" => ::std::option::Option::Some(ClientTokenRequestType::REQUEST_CHALLENGE_ANSWERS_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClientTokenRequestType] = &[
        ClientTokenRequestType::REQUEST_UNKNOWN,
        ClientTokenRequestType::REQUEST_CLIENT_DATA_REQUEST,
        ClientTokenRequestType::REQUEST_CHALLENGE_ANSWERS_REQUEST,
    ];
}

impl ::protobuf::EnumFull for ClientTokenRequestType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClientTokenRequestType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClientTokenRequestType {
    fn default() -> Self {
        ClientTokenRequestType::REQUEST_UNKNOWN
    }
}

impl ClientTokenRequestType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClientTokenRequestType>("ClientTokenRequestType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.clienttoken.http.v0.ClientTokenResponseType)
pub enum ClientTokenResponseType {
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ClientTokenResponseType.RESPONSE_UNKNOWN)
    RESPONSE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ClientTokenResponseType.RESPONSE_GRANTED_TOKEN_RESPONSE)
    RESPONSE_GRANTED_TOKEN_RESPONSE = 1,
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ClientTokenResponseType.RESPONSE_CHALLENGES_RESPONSE)
    RESPONSE_CHALLENGES_RESPONSE = 2,
}

impl ::protobuf::Enum for ClientTokenResponseType {
    const NAME: &'static str = "ClientTokenResponseType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientTokenResponseType> {
        match value {
            0 => ::std::option::Option::Some(ClientTokenResponseType::RESPONSE_UNKNOWN),
            1 => ::std::option::Option::Some(ClientTokenResponseType::RESPONSE_GRANTED_TOKEN_RESPONSE),
            2 => ::std::option::Option::Some(ClientTokenResponseType::RESPONSE_CHALLENGES_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClientTokenResponseType> {
        match str {
            "RESPONSE_UNKNOWN" => ::std::option::Option::Some(ClientTokenResponseType::RESPONSE_UNKNOWN),
            "RESPONSE_GRANTED_TOKEN_RESPONSE" => ::std::option::Option::Some(ClientTokenResponseType::RESPONSE_GRANTED_TOKEN_RESPONSE),
            "RESPONSE_CHALLENGES_RESPONSE" => ::std::option::Option::Some(ClientTokenResponseType::RESPONSE_CHALLENGES_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClientTokenResponseType] = &[
        ClientTokenResponseType::RESPONSE_UNKNOWN,
        ClientTokenResponseType::RESPONSE_GRANTED_TOKEN_RESPONSE,
        ClientTokenResponseType::RESPONSE_CHALLENGES_RESPONSE,
    ];
}

impl ::protobuf::EnumFull for ClientTokenResponseType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClientTokenResponseType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClientTokenResponseType {
    fn default() -> Self {
        ClientTokenResponseType::RESPONSE_UNKNOWN
    }
}

impl ClientTokenResponseType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClientTokenResponseType>("ClientTokenResponseType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.clienttoken.http.v0.ChallengeType)
pub enum ChallengeType {
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ChallengeType.CHALLENGE_UNKNOWN)
    CHALLENGE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ChallengeType.CHALLENGE_CLIENT_SECRET_HMAC)
    CHALLENGE_CLIENT_SECRET_HMAC = 1,
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ChallengeType.CHALLENGE_EVALUATE_JS)
    CHALLENGE_EVALUATE_JS = 2,
    // @@protoc_insertion_point(enum_value:spotify.clienttoken.http.v0.ChallengeType.CHALLENGE_HASH_CASH)
    CHALLENGE_HASH_CASH = 3,
}

impl ::protobuf::Enum for ChallengeType {
    const NAME: &'static str = "ChallengeType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChallengeType> {
        match value {
            0 => ::std::option::Option::Some(ChallengeType::CHALLENGE_UNKNOWN),
            1 => ::std::option::Option::Some(ChallengeType::CHALLENGE_CLIENT_SECRET_HMAC),
            2 => ::std::option::Option::Some(ChallengeType::CHALLENGE_EVALUATE_JS),
            3 => ::std::option::Option::Some(ChallengeType::CHALLENGE_HASH_CASH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ChallengeType> {
        match str {
            "CHALLENGE_UNKNOWN" => ::std::option::Option::Some(ChallengeType::CHALLENGE_UNKNOWN),
            "CHALLENGE_CLIENT_SECRET_HMAC" => ::std::option::Option::Some(ChallengeType::CHALLENGE_CLIENT_SECRET_HMAC),
            "CHALLENGE_EVALUATE_JS" => ::std::option::Option::Some(ChallengeType::CHALLENGE_EVALUATE_JS),
            "CHALLENGE_HASH_CASH" => ::std::option::Option::Some(ChallengeType::CHALLENGE_HASH_CASH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ChallengeType] = &[
        ChallengeType::CHALLENGE_UNKNOWN,
        ChallengeType::CHALLENGE_CLIENT_SECRET_HMAC,
        ChallengeType::CHALLENGE_EVALUATE_JS,
        ChallengeType::CHALLENGE_HASH_CASH,
    ];
}

impl ::protobuf::EnumFull for ChallengeType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ChallengeType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ChallengeType {
    fn default() -> Self {
        ChallengeType::CHALLENGE_UNKNOWN
    }
}

impl ChallengeType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ChallengeType>("ChallengeType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-spotify/clienttoken/v0/clienttoken_http.proto\x12\x1bspotify.clientto\
    ken.http.v0\x1a\x12connectivity.proto\"\xaf\x02\n\x12ClientTokenRequest\
    \x12V\n\x0crequest_type\x18\x01\x20\x01(\x0e23.spotify.clienttoken.http.\
    v0.ClientTokenRequestTypeR\x0brequestType\x12Q\n\x0bclient_data\x18\x02\
    \x20\x01(\x0b2..spotify.clienttoken.http.v0.ClientDataRequestH\0R\nclien\
    tData\x12c\n\x11challenge_answers\x18\x03\x20\x01(\x0b24.spotify.clientt\
    oken.http.v0.ChallengeAnswersRequestH\0R\x10challengeAnswersB\t\n\x07req\
    uest\"\xc7\x01\n\x11ClientDataRequest\x12%\n\x0eclient_version\x18\x01\
    \x20\x01(\tR\rclientVersion\x12\x1b\n\tclient_id\x18\x02\x20\x01(\tR\x08\
    clientId\x12f\n\x15connectivity_sdk_data\x18\x03\x20\x01(\x0b20.spotify.\
    clienttoken.data.v0.ConnectivitySdkDataH\0R\x13connectivitySdkDataB\x06\
    \n\x04data\"w\n\x17ChallengeAnswersRequest\x12\x14\n\x05state\x18\x01\
    \x20\x01(\tR\x05state\x12F\n\x07answers\x18\x02\x20\x03(\x0b2,.spotify.c\
    lienttoken.http.v0.ChallengeAnswerR\x07answers\"\xa9\x02\n\x13ClientToke\
    nResponse\x12Y\n\rresponse_type\x18\x01\x20\x01(\x0e24.spotify.clienttok\
    en.http.v0.ClientTokenResponseTypeR\x0cresponseType\x12X\n\rgranted_toke\
    n\x18\x02\x20\x01(\x0b21.spotify.clienttoken.http.v0.GrantedTokenRespons\
    eH\0R\x0cgrantedToken\x12Q\n\nchallenges\x18\x03\x20\x01(\x0b2/.spotify.\
    clienttoken.http.v0.ChallengesResponseH\0R\nchallengesB\n\n\x08response\
    \"%\n\x0bTokenDomain\x12\x16\n\x06domain\x18\x01\x20\x01(\tR\x06domain\"\
    \xd8\x01\n\x14GrantedTokenResponse\x12\x14\n\x05token\x18\x01\x20\x01(\t\
    R\x05token\x122\n\x15expires_after_seconds\x18\x02\x20\x01(\x05R\x13expi\
    resAfterSeconds\x122\n\x15refresh_after_seconds\x18\x03\x20\x01(\x05R\
    \x13refreshAfterSeconds\x12B\n\x07domains\x18\x04\x20\x03(\x0b2(.spotify\
    .clienttoken.http.v0.TokenDomainR\x07domains\"r\n\x12ChallengesResponse\
    \x12\x14\n\x05state\x18\x01\x20\x01(\tR\x05state\x12F\n\nchallenges\x18\
    \x02\x20\x03(\x0b2&.spotify.clienttoken.http.v0.ChallengeR\nchallenges\"\
    ,\n\x16ClientSecretParameters\x12\x12\n\x04salt\x18\x01\x20\x01(\tR\x04s\
    alt\"H\n\x14EvaluateJSParameters\x12\x12\n\x04code\x18\x01\x20\x01(\tR\
    \x04code\x12\x1c\n\tlibraries\x18\x02\x20\x03(\tR\tlibraries\"D\n\x12Has\
    hCashParameters\x12\x16\n\x06length\x18\x01\x20\x01(\x05R\x06length\x12\
    \x16\n\x06prefix\x18\x02\x20\x01(\tR\x06prefix\"\xaa\x03\n\tChallenge\
    \x12>\n\x04type\x18\x01\x20\x01(\x0e2*.spotify.clienttoken.http.v0.Chall\
    engeTypeR\x04type\x12o\n\x18client_secret_parameters\x18\x02\x20\x01(\
    \x0b23.spotify.clienttoken.http.v0.ClientSecretParametersH\0R\x16clientS\
    ecretParameters\x12i\n\x16evaluate_js_parameters\x18\x03\x20\x01(\x0b21.\
    spotify.clienttoken.http.v0.EvaluateJSParametersH\0R\x14evaluateJsParame\
    ters\x12s\n\x1cevaluate_hashcash_parameters\x18\x04\x20\x01(\x0b2/.spoti\
    fy.clienttoken.http.v0.HashCashParametersH\0R\x1aevaluateHashcashParamet\
    ersB\x0c\n\nparameters\",\n\x16ClientSecretHMACAnswer\x12\x12\n\x04hmac\
    \x18\x01\x20\x01(\tR\x04hmac\"*\n\x10EvaluateJSAnswer\x12\x16\n\x06resul\
    t\x18\x01\x20\x01(\tR\x06result\"(\n\x0eHashCashAnswer\x12\x16\n\x06suff\
    ix\x18\x01\x20\x01(\tR\x06suffix\"\xe7\x02\n\x0fChallengeAnswer\x12P\n\r\
    ChallengeType\x18\x01\x20\x01(\x0e2*.spotify.clienttoken.http.v0.Challen\
    geTypeR\rChallengeType\x12Z\n\rclient_secret\x18\x02\x20\x01(\x0b23.spot\
    ify.clienttoken.http.v0.ClientSecretHMACAnswerH\0R\x0cclientSecret\x12P\
    \n\x0bevaluate_js\x18\x03\x20\x01(\x0b2-.spotify.clienttoken.http.v0.Eva\
    luateJSAnswerH\0R\nevaluateJs\x12J\n\thash_cash\x18\x04\x20\x01(\x0b2+.s\
    potify.clienttoken.http.v0.HashCashAnswerH\0R\x08hashCashB\x08\n\x06answ\
    er\"1\n\x15ClientTokenBadRequest\x12\x18\n\x07message\x18\x01\x20\x01(\t\
    R\x07message*u\n\x16ClientTokenRequestType\x12\x13\n\x0fREQUEST_UNKNOWN\
    \x10\0\x12\x1f\n\x1bREQUEST_CLIENT_DATA_REQUEST\x10\x01\x12%\n!REQUEST_C\
    HALLENGE_ANSWERS_REQUEST\x10\x02*v\n\x17ClientTokenResponseType\x12\x14\
    \n\x10RESPONSE_UNKNOWN\x10\0\x12#\n\x1fRESPONSE_GRANTED_TOKEN_RESPONSE\
    \x10\x01\x12\x20\n\x1cRESPONSE_CHALLENGES_RESPONSE\x10\x02*|\n\rChalleng\
    eType\x12\x15\n\x11CHALLENGE_UNKNOWN\x10\0\x12\x20\n\x1cCHALLENGE_CLIENT\
    _SECRET_HMAC\x10\x01\x12\x19\n\x15CHALLENGE_EVALUATE_JS\x10\x02\x12\x17\
    \n\x13CHALLENGE_HASH_CASH\x10\x03B!\n\x1bspotify.clienttoken.http.v0P\
    \x01H\x02b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::connectivity::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(ClientTokenRequest::generated_message_descriptor_data());
            messages.push(ClientDataRequest::generated_message_descriptor_data());
            messages.push(ChallengeAnswersRequest::generated_message_descriptor_data());
            messages.push(ClientTokenResponse::generated_message_descriptor_data());
            messages.push(TokenDomain::generated_message_descriptor_data());
            messages.push(GrantedTokenResponse::generated_message_descriptor_data());
            messages.push(ChallengesResponse::generated_message_descriptor_data());
            messages.push(ClientSecretParameters::generated_message_descriptor_data());
            messages.push(EvaluateJSParameters::generated_message_descriptor_data());
            messages.push(HashCashParameters::generated_message_descriptor_data());
            messages.push(Challenge::generated_message_descriptor_data());
            messages.push(ClientSecretHMACAnswer::generated_message_descriptor_data());
            messages.push(EvaluateJSAnswer::generated_message_descriptor_data());
            messages.push(HashCashAnswer::generated_message_descriptor_data());
            messages.push(ChallengeAnswer::generated_message_descriptor_data());
            messages.push(ClientTokenBadRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(ClientTokenRequestType::generated_enum_descriptor_data());
            enums.push(ClientTokenResponseType::generated_enum_descriptor_data());
            enums.push(ChallengeType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
