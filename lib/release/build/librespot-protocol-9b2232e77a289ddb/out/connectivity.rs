// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `connectivity.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.ConnectivitySdkData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectivitySdkData {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.ConnectivitySdkData.platform_specific_data)
    pub platform_specific_data: ::protobuf::MessageField<PlatformSpecificData>,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.ConnectivitySdkData.device_id)
    pub device_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.ConnectivitySdkData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectivitySdkData {
    fn default() -> &'a ConnectivitySdkData {
        <ConnectivitySdkData as ::protobuf::Message>::default_instance()
    }
}

impl ConnectivitySdkData {
    pub fn new() -> ConnectivitySdkData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlatformSpecificData>(
            "platform_specific_data",
            |m: &ConnectivitySdkData| { &m.platform_specific_data },
            |m: &mut ConnectivitySdkData| { &mut m.platform_specific_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ConnectivitySdkData| { &m.device_id },
            |m: &mut ConnectivitySdkData| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectivitySdkData>(
            "ConnectivitySdkData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectivitySdkData {
    const NAME: &'static str = "ConnectivitySdkData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.platform_specific_data)?;
                },
                18 => {
                    self.device_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.platform_specific_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.platform_specific_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.device_id.is_empty() {
            os.write_string(2, &self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectivitySdkData {
        ConnectivitySdkData::new()
    }

    fn clear(&mut self) {
        self.platform_specific_data.clear();
        self.device_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectivitySdkData {
        static instance: ConnectivitySdkData = ConnectivitySdkData {
            platform_specific_data: ::protobuf::MessageField::none(),
            device_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectivitySdkData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectivitySdkData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectivitySdkData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectivitySdkData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.PlatformSpecificData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlatformSpecificData {
    // message oneof groups
    pub data: ::std::option::Option<platform_specific_data::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.PlatformSpecificData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlatformSpecificData {
    fn default() -> &'a PlatformSpecificData {
        <PlatformSpecificData as ::protobuf::Message>::default_instance()
    }
}

impl PlatformSpecificData {
    pub fn new() -> PlatformSpecificData {
        ::std::default::Default::default()
    }

    // .spotify.clienttoken.data.v0.NativeAndroidData android = 1;

    pub fn android(&self) -> &NativeAndroidData {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::Android(ref v)) => v,
            _ => <NativeAndroidData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_android(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_android(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::Android(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_android(&mut self, v: NativeAndroidData) {
        self.data = ::std::option::Option::Some(platform_specific_data::Data::Android(v))
    }

    // Mutable pointer to the field.
    pub fn mut_android(&mut self) -> &mut NativeAndroidData {
        if let ::std::option::Option::Some(platform_specific_data::Data::Android(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(platform_specific_data::Data::Android(NativeAndroidData::new()));
        }
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::Android(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_android(&mut self) -> NativeAndroidData {
        if self.has_android() {
            match self.data.take() {
                ::std::option::Option::Some(platform_specific_data::Data::Android(v)) => v,
                _ => panic!(),
            }
        } else {
            NativeAndroidData::new()
        }
    }

    // .spotify.clienttoken.data.v0.NativeIOSData ios = 2;

    pub fn ios(&self) -> &NativeIOSData {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::Ios(ref v)) => v,
            _ => <NativeIOSData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ios(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_ios(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::Ios(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ios(&mut self, v: NativeIOSData) {
        self.data = ::std::option::Option::Some(platform_specific_data::Data::Ios(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ios(&mut self) -> &mut NativeIOSData {
        if let ::std::option::Option::Some(platform_specific_data::Data::Ios(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(platform_specific_data::Data::Ios(NativeIOSData::new()));
        }
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::Ios(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ios(&mut self) -> NativeIOSData {
        if self.has_ios() {
            match self.data.take() {
                ::std::option::Option::Some(platform_specific_data::Data::Ios(v)) => v,
                _ => panic!(),
            }
        } else {
            NativeIOSData::new()
        }
    }

    // .spotify.clienttoken.data.v0.NativeDesktopMacOSData desktop_macos = 3;

    pub fn desktop_macos(&self) -> &NativeDesktopMacOSData {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(ref v)) => v,
            _ => <NativeDesktopMacOSData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_desktop_macos(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_desktop_macos(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_desktop_macos(&mut self, v: NativeDesktopMacOSData) {
        self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_desktop_macos(&mut self) -> &mut NativeDesktopMacOSData {
        if let ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(NativeDesktopMacOSData::new()));
        }
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_desktop_macos(&mut self) -> NativeDesktopMacOSData {
        if self.has_desktop_macos() {
            match self.data.take() {
                ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(v)) => v,
                _ => panic!(),
            }
        } else {
            NativeDesktopMacOSData::new()
        }
    }

    // .spotify.clienttoken.data.v0.NativeDesktopWindowsData desktop_windows = 4;

    pub fn desktop_windows(&self) -> &NativeDesktopWindowsData {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(ref v)) => v,
            _ => <NativeDesktopWindowsData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_desktop_windows(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_desktop_windows(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_desktop_windows(&mut self, v: NativeDesktopWindowsData) {
        self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(v))
    }

    // Mutable pointer to the field.
    pub fn mut_desktop_windows(&mut self) -> &mut NativeDesktopWindowsData {
        if let ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(NativeDesktopWindowsData::new()));
        }
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_desktop_windows(&mut self) -> NativeDesktopWindowsData {
        if self.has_desktop_windows() {
            match self.data.take() {
                ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(v)) => v,
                _ => panic!(),
            }
        } else {
            NativeDesktopWindowsData::new()
        }
    }

    // .spotify.clienttoken.data.v0.NativeDesktopLinuxData desktop_linux = 5;

    pub fn desktop_linux(&self) -> &NativeDesktopLinuxData {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(ref v)) => v,
            _ => <NativeDesktopLinuxData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_desktop_linux(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_desktop_linux(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_desktop_linux(&mut self, v: NativeDesktopLinuxData) {
        self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(v))
    }

    // Mutable pointer to the field.
    pub fn mut_desktop_linux(&mut self) -> &mut NativeDesktopLinuxData {
        if let ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(NativeDesktopLinuxData::new()));
        }
        match self.data {
            ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_desktop_linux(&mut self) -> NativeDesktopLinuxData {
        if self.has_desktop_linux() {
            match self.data.take() {
                ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(v)) => v,
                _ => panic!(),
            }
        } else {
            NativeDesktopLinuxData::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NativeAndroidData>(
            "android",
            PlatformSpecificData::has_android,
            PlatformSpecificData::android,
            PlatformSpecificData::mut_android,
            PlatformSpecificData::set_android,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NativeIOSData>(
            "ios",
            PlatformSpecificData::has_ios,
            PlatformSpecificData::ios,
            PlatformSpecificData::mut_ios,
            PlatformSpecificData::set_ios,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NativeDesktopMacOSData>(
            "desktop_macos",
            PlatformSpecificData::has_desktop_macos,
            PlatformSpecificData::desktop_macos,
            PlatformSpecificData::mut_desktop_macos,
            PlatformSpecificData::set_desktop_macos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NativeDesktopWindowsData>(
            "desktop_windows",
            PlatformSpecificData::has_desktop_windows,
            PlatformSpecificData::desktop_windows,
            PlatformSpecificData::mut_desktop_windows,
            PlatformSpecificData::set_desktop_windows,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NativeDesktopLinuxData>(
            "desktop_linux",
            PlatformSpecificData::has_desktop_linux,
            PlatformSpecificData::desktop_linux,
            PlatformSpecificData::mut_desktop_linux,
            PlatformSpecificData::set_desktop_linux,
        ));
        oneofs.push(platform_specific_data::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlatformSpecificData>(
            "PlatformSpecificData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlatformSpecificData {
    const NAME: &'static str = "PlatformSpecificData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(platform_specific_data::Data::Android(is.read_message()?));
                },
                18 => {
                    self.data = ::std::option::Option::Some(platform_specific_data::Data::Ios(is.read_message()?));
                },
                26 => {
                    self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopMacos(is.read_message()?));
                },
                34 => {
                    self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopWindows(is.read_message()?));
                },
                42 => {
                    self.data = ::std::option::Option::Some(platform_specific_data::Data::DesktopLinux(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &platform_specific_data::Data::Android(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &platform_specific_data::Data::Ios(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &platform_specific_data::Data::DesktopMacos(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &platform_specific_data::Data::DesktopWindows(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &platform_specific_data::Data::DesktopLinux(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &platform_specific_data::Data::Android(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &platform_specific_data::Data::Ios(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &platform_specific_data::Data::DesktopMacos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &platform_specific_data::Data::DesktopWindows(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &platform_specific_data::Data::DesktopLinux(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlatformSpecificData {
        PlatformSpecificData::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlatformSpecificData {
        static instance: PlatformSpecificData = PlatformSpecificData {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlatformSpecificData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlatformSpecificData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlatformSpecificData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlatformSpecificData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PlatformSpecificData`
pub mod platform_specific_data {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.clienttoken.data.v0.PlatformSpecificData.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.data.v0.PlatformSpecificData.android)
        Android(super::NativeAndroidData),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.data.v0.PlatformSpecificData.ios)
        Ios(super::NativeIOSData),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.data.v0.PlatformSpecificData.desktop_macos)
        DesktopMacos(super::NativeDesktopMacOSData),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.data.v0.PlatformSpecificData.desktop_windows)
        DesktopWindows(super::NativeDesktopWindowsData),
        // @@protoc_insertion_point(oneof_field:spotify.clienttoken.data.v0.PlatformSpecificData.desktop_linux)
        DesktopLinux(super::NativeDesktopLinuxData),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PlatformSpecificData as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.NativeAndroidData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NativeAndroidData {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.screen_dimensions)
    pub screen_dimensions: ::protobuf::MessageField<Screen>,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.android_version)
    pub android_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.api_version)
    pub api_version: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.device_name)
    pub device_name: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.model_str)
    pub model_str: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.vendor)
    pub vendor: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.vendor_2)
    pub vendor_2: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeAndroidData.unknown_value_8)
    pub unknown_value_8: i32,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.NativeAndroidData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeAndroidData {
    fn default() -> &'a NativeAndroidData {
        <NativeAndroidData as ::protobuf::Message>::default_instance()
    }
}

impl NativeAndroidData {
    pub fn new() -> NativeAndroidData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Screen>(
            "screen_dimensions",
            |m: &NativeAndroidData| { &m.screen_dimensions },
            |m: &mut NativeAndroidData| { &mut m.screen_dimensions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "android_version",
            |m: &NativeAndroidData| { &m.android_version },
            |m: &mut NativeAndroidData| { &mut m.android_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version",
            |m: &NativeAndroidData| { &m.api_version },
            |m: &mut NativeAndroidData| { &mut m.api_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_name",
            |m: &NativeAndroidData| { &m.device_name },
            |m: &mut NativeAndroidData| { &mut m.device_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_str",
            |m: &NativeAndroidData| { &m.model_str },
            |m: &mut NativeAndroidData| { &mut m.model_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vendor",
            |m: &NativeAndroidData| { &m.vendor },
            |m: &mut NativeAndroidData| { &mut m.vendor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vendor_2",
            |m: &NativeAndroidData| { &m.vendor_2 },
            |m: &mut NativeAndroidData| { &mut m.vendor_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unknown_value_8",
            |m: &NativeAndroidData| { &m.unknown_value_8 },
            |m: &mut NativeAndroidData| { &mut m.unknown_value_8 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeAndroidData>(
            "NativeAndroidData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeAndroidData {
    const NAME: &'static str = "NativeAndroidData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.screen_dimensions)?;
                },
                18 => {
                    self.android_version = is.read_string()?;
                },
                24 => {
                    self.api_version = is.read_int32()?;
                },
                34 => {
                    self.device_name = is.read_string()?;
                },
                42 => {
                    self.model_str = is.read_string()?;
                },
                50 => {
                    self.vendor = is.read_string()?;
                },
                58 => {
                    self.vendor_2 = is.read_string()?;
                },
                64 => {
                    self.unknown_value_8 = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screen_dimensions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.android_version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.android_version);
        }
        if self.api_version != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.api_version);
        }
        if !self.device_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.device_name);
        }
        if !self.model_str.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.model_str);
        }
        if !self.vendor.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.vendor);
        }
        if !self.vendor_2.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.vendor_2);
        }
        if self.unknown_value_8 != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.unknown_value_8);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screen_dimensions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.android_version.is_empty() {
            os.write_string(2, &self.android_version)?;
        }
        if self.api_version != 0 {
            os.write_int32(3, self.api_version)?;
        }
        if !self.device_name.is_empty() {
            os.write_string(4, &self.device_name)?;
        }
        if !self.model_str.is_empty() {
            os.write_string(5, &self.model_str)?;
        }
        if !self.vendor.is_empty() {
            os.write_string(6, &self.vendor)?;
        }
        if !self.vendor_2.is_empty() {
            os.write_string(7, &self.vendor_2)?;
        }
        if self.unknown_value_8 != 0 {
            os.write_int32(8, self.unknown_value_8)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeAndroidData {
        NativeAndroidData::new()
    }

    fn clear(&mut self) {
        self.screen_dimensions.clear();
        self.android_version.clear();
        self.api_version = 0;
        self.device_name.clear();
        self.model_str.clear();
        self.vendor.clear();
        self.vendor_2.clear();
        self.unknown_value_8 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeAndroidData {
        static instance: NativeAndroidData = NativeAndroidData {
            screen_dimensions: ::protobuf::MessageField::none(),
            android_version: ::std::string::String::new(),
            api_version: 0,
            device_name: ::std::string::String::new(),
            model_str: ::std::string::String::new(),
            vendor: ::std::string::String::new(),
            vendor_2: ::std::string::String::new(),
            unknown_value_8: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeAndroidData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeAndroidData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeAndroidData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeAndroidData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.NativeIOSData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NativeIOSData {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeIOSData.user_interface_idiom)
    pub user_interface_idiom: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeIOSData.target_iphone_simulator)
    pub target_iphone_simulator: bool,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeIOSData.hw_machine)
    pub hw_machine: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeIOSData.system_version)
    pub system_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeIOSData.simulator_model_identifier)
    pub simulator_model_identifier: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.NativeIOSData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeIOSData {
    fn default() -> &'a NativeIOSData {
        <NativeIOSData as ::protobuf::Message>::default_instance()
    }
}

impl NativeIOSData {
    pub fn new() -> NativeIOSData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_interface_idiom",
            |m: &NativeIOSData| { &m.user_interface_idiom },
            |m: &mut NativeIOSData| { &mut m.user_interface_idiom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_iphone_simulator",
            |m: &NativeIOSData| { &m.target_iphone_simulator },
            |m: &mut NativeIOSData| { &mut m.target_iphone_simulator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hw_machine",
            |m: &NativeIOSData| { &m.hw_machine },
            |m: &mut NativeIOSData| { &mut m.hw_machine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "system_version",
            |m: &NativeIOSData| { &m.system_version },
            |m: &mut NativeIOSData| { &mut m.system_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "simulator_model_identifier",
            |m: &NativeIOSData| { &m.simulator_model_identifier },
            |m: &mut NativeIOSData| { &mut m.simulator_model_identifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeIOSData>(
            "NativeIOSData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeIOSData {
    const NAME: &'static str = "NativeIOSData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_interface_idiom = is.read_int32()?;
                },
                16 => {
                    self.target_iphone_simulator = is.read_bool()?;
                },
                26 => {
                    self.hw_machine = is.read_string()?;
                },
                34 => {
                    self.system_version = is.read_string()?;
                },
                42 => {
                    self.simulator_model_identifier = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.user_interface_idiom != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.user_interface_idiom);
        }
        if self.target_iphone_simulator != false {
            my_size += 1 + 1;
        }
        if !self.hw_machine.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hw_machine);
        }
        if !self.system_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.system_version);
        }
        if !self.simulator_model_identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.simulator_model_identifier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.user_interface_idiom != 0 {
            os.write_int32(1, self.user_interface_idiom)?;
        }
        if self.target_iphone_simulator != false {
            os.write_bool(2, self.target_iphone_simulator)?;
        }
        if !self.hw_machine.is_empty() {
            os.write_string(3, &self.hw_machine)?;
        }
        if !self.system_version.is_empty() {
            os.write_string(4, &self.system_version)?;
        }
        if !self.simulator_model_identifier.is_empty() {
            os.write_string(5, &self.simulator_model_identifier)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeIOSData {
        NativeIOSData::new()
    }

    fn clear(&mut self) {
        self.user_interface_idiom = 0;
        self.target_iphone_simulator = false;
        self.hw_machine.clear();
        self.system_version.clear();
        self.simulator_model_identifier.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeIOSData {
        static instance: NativeIOSData = NativeIOSData {
            user_interface_idiom: 0,
            target_iphone_simulator: false,
            hw_machine: ::std::string::String::new(),
            system_version: ::std::string::String::new(),
            simulator_model_identifier: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeIOSData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeIOSData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeIOSData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeIOSData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.NativeDesktopWindowsData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NativeDesktopWindowsData {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.os_version)
    pub os_version: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.os_build)
    pub os_build: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.platform_id)
    pub platform_id: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.unknown_value_5)
    pub unknown_value_5: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.unknown_value_6)
    pub unknown_value_6: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.image_file_machine)
    pub image_file_machine: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.pe_machine)
    pub pe_machine: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.unknown_value_10)
    pub unknown_value_10: bool,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.NativeDesktopWindowsData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeDesktopWindowsData {
    fn default() -> &'a NativeDesktopWindowsData {
        <NativeDesktopWindowsData as ::protobuf::Message>::default_instance()
    }
}

impl NativeDesktopWindowsData {
    pub fn new() -> NativeDesktopWindowsData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "os_version",
            |m: &NativeDesktopWindowsData| { &m.os_version },
            |m: &mut NativeDesktopWindowsData| { &mut m.os_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "os_build",
            |m: &NativeDesktopWindowsData| { &m.os_build },
            |m: &mut NativeDesktopWindowsData| { &mut m.os_build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform_id",
            |m: &NativeDesktopWindowsData| { &m.platform_id },
            |m: &mut NativeDesktopWindowsData| { &mut m.platform_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unknown_value_5",
            |m: &NativeDesktopWindowsData| { &m.unknown_value_5 },
            |m: &mut NativeDesktopWindowsData| { &mut m.unknown_value_5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unknown_value_6",
            |m: &NativeDesktopWindowsData| { &m.unknown_value_6 },
            |m: &mut NativeDesktopWindowsData| { &mut m.unknown_value_6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_file_machine",
            |m: &NativeDesktopWindowsData| { &m.image_file_machine },
            |m: &mut NativeDesktopWindowsData| { &mut m.image_file_machine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pe_machine",
            |m: &NativeDesktopWindowsData| { &m.pe_machine },
            |m: &mut NativeDesktopWindowsData| { &mut m.pe_machine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unknown_value_10",
            |m: &NativeDesktopWindowsData| { &m.unknown_value_10 },
            |m: &mut NativeDesktopWindowsData| { &mut m.unknown_value_10 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeDesktopWindowsData>(
            "NativeDesktopWindowsData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeDesktopWindowsData {
    const NAME: &'static str = "NativeDesktopWindowsData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.os_version = is.read_int32()?;
                },
                24 => {
                    self.os_build = is.read_int32()?;
                },
                32 => {
                    self.platform_id = is.read_int32()?;
                },
                40 => {
                    self.unknown_value_5 = is.read_int32()?;
                },
                48 => {
                    self.unknown_value_6 = is.read_int32()?;
                },
                56 => {
                    self.image_file_machine = is.read_int32()?;
                },
                64 => {
                    self.pe_machine = is.read_int32()?;
                },
                80 => {
                    self.unknown_value_10 = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.os_version != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.os_version);
        }
        if self.os_build != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.os_build);
        }
        if self.platform_id != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.platform_id);
        }
        if self.unknown_value_5 != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.unknown_value_5);
        }
        if self.unknown_value_6 != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.unknown_value_6);
        }
        if self.image_file_machine != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.image_file_machine);
        }
        if self.pe_machine != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.pe_machine);
        }
        if self.unknown_value_10 != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.os_version != 0 {
            os.write_int32(1, self.os_version)?;
        }
        if self.os_build != 0 {
            os.write_int32(3, self.os_build)?;
        }
        if self.platform_id != 0 {
            os.write_int32(4, self.platform_id)?;
        }
        if self.unknown_value_5 != 0 {
            os.write_int32(5, self.unknown_value_5)?;
        }
        if self.unknown_value_6 != 0 {
            os.write_int32(6, self.unknown_value_6)?;
        }
        if self.image_file_machine != 0 {
            os.write_int32(7, self.image_file_machine)?;
        }
        if self.pe_machine != 0 {
            os.write_int32(8, self.pe_machine)?;
        }
        if self.unknown_value_10 != false {
            os.write_bool(10, self.unknown_value_10)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeDesktopWindowsData {
        NativeDesktopWindowsData::new()
    }

    fn clear(&mut self) {
        self.os_version = 0;
        self.os_build = 0;
        self.platform_id = 0;
        self.unknown_value_5 = 0;
        self.unknown_value_6 = 0;
        self.image_file_machine = 0;
        self.pe_machine = 0;
        self.unknown_value_10 = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeDesktopWindowsData {
        static instance: NativeDesktopWindowsData = NativeDesktopWindowsData {
            os_version: 0,
            os_build: 0,
            platform_id: 0,
            unknown_value_5: 0,
            unknown_value_6: 0,
            image_file_machine: 0,
            pe_machine: 0,
            unknown_value_10: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeDesktopWindowsData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeDesktopWindowsData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeDesktopWindowsData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeDesktopWindowsData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.NativeDesktopLinuxData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NativeDesktopLinuxData {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopLinuxData.system_name)
    pub system_name: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopLinuxData.system_release)
    pub system_release: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopLinuxData.system_version)
    pub system_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopLinuxData.hardware)
    pub hardware: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.NativeDesktopLinuxData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeDesktopLinuxData {
    fn default() -> &'a NativeDesktopLinuxData {
        <NativeDesktopLinuxData as ::protobuf::Message>::default_instance()
    }
}

impl NativeDesktopLinuxData {
    pub fn new() -> NativeDesktopLinuxData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "system_name",
            |m: &NativeDesktopLinuxData| { &m.system_name },
            |m: &mut NativeDesktopLinuxData| { &mut m.system_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "system_release",
            |m: &NativeDesktopLinuxData| { &m.system_release },
            |m: &mut NativeDesktopLinuxData| { &mut m.system_release },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "system_version",
            |m: &NativeDesktopLinuxData| { &m.system_version },
            |m: &mut NativeDesktopLinuxData| { &mut m.system_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hardware",
            |m: &NativeDesktopLinuxData| { &m.hardware },
            |m: &mut NativeDesktopLinuxData| { &mut m.hardware },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeDesktopLinuxData>(
            "NativeDesktopLinuxData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeDesktopLinuxData {
    const NAME: &'static str = "NativeDesktopLinuxData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.system_name = is.read_string()?;
                },
                18 => {
                    self.system_release = is.read_string()?;
                },
                26 => {
                    self.system_version = is.read_string()?;
                },
                34 => {
                    self.hardware = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.system_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.system_name);
        }
        if !self.system_release.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.system_release);
        }
        if !self.system_version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.system_version);
        }
        if !self.hardware.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.hardware);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.system_name.is_empty() {
            os.write_string(1, &self.system_name)?;
        }
        if !self.system_release.is_empty() {
            os.write_string(2, &self.system_release)?;
        }
        if !self.system_version.is_empty() {
            os.write_string(3, &self.system_version)?;
        }
        if !self.hardware.is_empty() {
            os.write_string(4, &self.hardware)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeDesktopLinuxData {
        NativeDesktopLinuxData::new()
    }

    fn clear(&mut self) {
        self.system_name.clear();
        self.system_release.clear();
        self.system_version.clear();
        self.hardware.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeDesktopLinuxData {
        static instance: NativeDesktopLinuxData = NativeDesktopLinuxData {
            system_name: ::std::string::String::new(),
            system_release: ::std::string::String::new(),
            system_version: ::std::string::String::new(),
            hardware: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeDesktopLinuxData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeDesktopLinuxData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeDesktopLinuxData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeDesktopLinuxData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.NativeDesktopMacOSData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NativeDesktopMacOSData {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopMacOSData.system_version)
    pub system_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopMacOSData.hw_model)
    pub hw_model: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.NativeDesktopMacOSData.compiled_cpu_type)
    pub compiled_cpu_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.NativeDesktopMacOSData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeDesktopMacOSData {
    fn default() -> &'a NativeDesktopMacOSData {
        <NativeDesktopMacOSData as ::protobuf::Message>::default_instance()
    }
}

impl NativeDesktopMacOSData {
    pub fn new() -> NativeDesktopMacOSData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "system_version",
            |m: &NativeDesktopMacOSData| { &m.system_version },
            |m: &mut NativeDesktopMacOSData| { &mut m.system_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hw_model",
            |m: &NativeDesktopMacOSData| { &m.hw_model },
            |m: &mut NativeDesktopMacOSData| { &mut m.hw_model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compiled_cpu_type",
            |m: &NativeDesktopMacOSData| { &m.compiled_cpu_type },
            |m: &mut NativeDesktopMacOSData| { &mut m.compiled_cpu_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeDesktopMacOSData>(
            "NativeDesktopMacOSData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeDesktopMacOSData {
    const NAME: &'static str = "NativeDesktopMacOSData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.system_version = is.read_string()?;
                },
                18 => {
                    self.hw_model = is.read_string()?;
                },
                26 => {
                    self.compiled_cpu_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.system_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.system_version);
        }
        if !self.hw_model.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hw_model);
        }
        if !self.compiled_cpu_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.compiled_cpu_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.system_version.is_empty() {
            os.write_string(1, &self.system_version)?;
        }
        if !self.hw_model.is_empty() {
            os.write_string(2, &self.hw_model)?;
        }
        if !self.compiled_cpu_type.is_empty() {
            os.write_string(3, &self.compiled_cpu_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeDesktopMacOSData {
        NativeDesktopMacOSData::new()
    }

    fn clear(&mut self) {
        self.system_version.clear();
        self.hw_model.clear();
        self.compiled_cpu_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeDesktopMacOSData {
        static instance: NativeDesktopMacOSData = NativeDesktopMacOSData {
            system_version: ::std::string::String::new(),
            hw_model: ::std::string::String::new(),
            compiled_cpu_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeDesktopMacOSData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeDesktopMacOSData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeDesktopMacOSData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeDesktopMacOSData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.clienttoken.data.v0.Screen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Screen {
    // message fields
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.Screen.width)
    pub width: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.Screen.height)
    pub height: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.Screen.density)
    pub density: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.Screen.unknown_value_4)
    pub unknown_value_4: i32,
    // @@protoc_insertion_point(field:spotify.clienttoken.data.v0.Screen.unknown_value_5)
    pub unknown_value_5: i32,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.clienttoken.data.v0.Screen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Screen {
    fn default() -> &'a Screen {
        <Screen as ::protobuf::Message>::default_instance()
    }
}

impl Screen {
    pub fn new() -> Screen {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &Screen| { &m.width },
            |m: &mut Screen| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Screen| { &m.height },
            |m: &mut Screen| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "density",
            |m: &Screen| { &m.density },
            |m: &mut Screen| { &mut m.density },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unknown_value_4",
            |m: &Screen| { &m.unknown_value_4 },
            |m: &mut Screen| { &mut m.unknown_value_4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unknown_value_5",
            |m: &Screen| { &m.unknown_value_5 },
            |m: &mut Screen| { &mut m.unknown_value_5 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Screen>(
            "Screen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Screen {
    const NAME: &'static str = "Screen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = is.read_int32()?;
                },
                16 => {
                    self.height = is.read_int32()?;
                },
                24 => {
                    self.density = is.read_int32()?;
                },
                32 => {
                    self.unknown_value_4 = is.read_int32()?;
                },
                40 => {
                    self.unknown_value_5 = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.height);
        }
        if self.density != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.density);
        }
        if self.unknown_value_4 != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.unknown_value_4);
        }
        if self.unknown_value_5 != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.unknown_value_5);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        if self.density != 0 {
            os.write_int32(3, self.density)?;
        }
        if self.unknown_value_4 != 0 {
            os.write_int32(4, self.unknown_value_4)?;
        }
        if self.unknown_value_5 != 0 {
            os.write_int32(5, self.unknown_value_5)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Screen {
        Screen::new()
    }

    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.density = 0;
        self.unknown_value_4 = 0;
        self.unknown_value_5 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Screen {
        static instance: Screen = Screen {
            width: 0,
            height: 0,
            density: 0,
            unknown_value_4: 0,
            unknown_value_5: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Screen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Screen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Screen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Screen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12connectivity.proto\x12\x1bspotify.clienttoken.data.v0\"\x9b\x01\n\
    \x13ConnectivitySdkData\x12g\n\x16platform_specific_data\x18\x01\x20\x01\
    (\x0b21.spotify.clienttoken.data.v0.PlatformSpecificDataR\x14platformSpe\
    cificData\x12\x1b\n\tdevice_id\x18\x02\x20\x01(\tR\x08deviceId\"\xc4\x03\
    \n\x14PlatformSpecificData\x12J\n\x07android\x18\x01\x20\x01(\x0b2..spot\
    ify.clienttoken.data.v0.NativeAndroidDataH\0R\x07android\x12>\n\x03ios\
    \x18\x02\x20\x01(\x0b2*.spotify.clienttoken.data.v0.NativeIOSDataH\0R\
    \x03ios\x12Z\n\rdesktop_macos\x18\x03\x20\x01(\x0b23.spotify.clienttoken\
    .data.v0.NativeDesktopMacOSDataH\0R\x0cdesktopMacos\x12`\n\x0fdesktop_wi\
    ndows\x18\x04\x20\x01(\x0b25.spotify.clienttoken.data.v0.NativeDesktopWi\
    ndowsDataH\0R\x0edesktopWindows\x12Z\n\rdesktop_linux\x18\x05\x20\x01(\
    \x0b23.spotify.clienttoken.data.v0.NativeDesktopLinuxDataH\0R\x0cdesktop\
    LinuxB\x06\n\x04data\"\xc8\x02\n\x11NativeAndroidData\x12P\n\x11screen_d\
    imensions\x18\x01\x20\x01(\x0b2#.spotify.clienttoken.data.v0.ScreenR\x10\
    screenDimensions\x12'\n\x0fandroid_version\x18\x02\x20\x01(\tR\x0eandroi\
    dVersion\x12\x1f\n\x0bapi_version\x18\x03\x20\x01(\x05R\napiVersion\x12\
    \x1f\n\x0bdevice_name\x18\x04\x20\x01(\tR\ndeviceName\x12\x1b\n\tmodel_s\
    tr\x18\x05\x20\x01(\tR\x08modelStr\x12\x16\n\x06vendor\x18\x06\x20\x01(\
    \tR\x06vendor\x12\x19\n\x08vendor_2\x18\x07\x20\x01(\tR\x07vendor2\x12&\
    \n\x0funknown_value_8\x18\x08\x20\x01(\x05R\runknownValue8\"\xfd\x01\n\r\
    NativeIOSData\x120\n\x14user_interface_idiom\x18\x01\x20\x01(\x05R\x12us\
    erInterfaceIdiom\x126\n\x17target_iphone_simulator\x18\x02\x20\x01(\x08R\
    \x15targetIphoneSimulator\x12\x1d\n\nhw_machine\x18\x03\x20\x01(\tR\thwM\
    achine\x12%\n\x0esystem_version\x18\x04\x20\x01(\tR\rsystemVersion\x12<\
    \n\x1asimulator_model_identifier\x18\x05\x20\x01(\tR\x18simulatorModelId\
    entifier\"\xbc\x02\n\x18NativeDesktopWindowsData\x12\x1d\n\nos_version\
    \x18\x01\x20\x01(\x05R\tosVersion\x12\x19\n\x08os_build\x18\x03\x20\x01(\
    \x05R\x07osBuild\x12\x1f\n\x0bplatform_id\x18\x04\x20\x01(\x05R\nplatfor\
    mId\x12&\n\x0funknown_value_5\x18\x05\x20\x01(\x05R\runknownValue5\x12&\
    \n\x0funknown_value_6\x18\x06\x20\x01(\x05R\runknownValue6\x12,\n\x12ima\
    ge_file_machine\x18\x07\x20\x01(\x05R\x10imageFileMachine\x12\x1d\n\npe_\
    machine\x18\x08\x20\x01(\x05R\tpeMachine\x12(\n\x10unknown_value_10\x18\
    \n\x20\x01(\x08R\x0eunknownValue10\"\xa3\x01\n\x16NativeDesktopLinuxData\
    \x12\x1f\n\x0bsystem_name\x18\x01\x20\x01(\tR\nsystemName\x12%\n\x0esyst\
    em_release\x18\x02\x20\x01(\tR\rsystemRelease\x12%\n\x0esystem_version\
    \x18\x03\x20\x01(\tR\rsystemVersion\x12\x1a\n\x08hardware\x18\x04\x20\
    \x01(\tR\x08hardware\"\x86\x01\n\x16NativeDesktopMacOSData\x12%\n\x0esys\
    tem_version\x18\x01\x20\x01(\tR\rsystemVersion\x12\x19\n\x08hw_model\x18\
    \x02\x20\x01(\tR\x07hwModel\x12*\n\x11compiled_cpu_type\x18\x03\x20\x01(\
    \tR\x0fcompiledCpuType\"\xa0\x01\n\x06Screen\x12\x14\n\x05width\x18\x01\
    \x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06hei\
    ght\x12\x18\n\x07density\x18\x03\x20\x01(\x05R\x07density\x12&\n\x0funkn\
    own_value_4\x18\x04\x20\x01(\x05R\runknownValue4\x12&\n\x0funknown_value\
    _5\x18\x05\x20\x01(\x05R\runknownValue5B!\n\x1bspotify.clienttoken.data.\
    v0P\x01H\x02b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(ConnectivitySdkData::generated_message_descriptor_data());
            messages.push(PlatformSpecificData::generated_message_descriptor_data());
            messages.push(NativeAndroidData::generated_message_descriptor_data());
            messages.push(NativeIOSData::generated_message_descriptor_data());
            messages.push(NativeDesktopWindowsData::generated_message_descriptor_data());
            messages.push(NativeDesktopLinuxData::generated_message_descriptor_data());
            messages.push(NativeDesktopMacOSData::generated_message_descriptor_data());
            messages.push(Screen::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
