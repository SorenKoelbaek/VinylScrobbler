// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `playlist4_external.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.playlist4.proto.Item)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Item {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Item.uri)
    pub uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Item.attributes)
    pub attributes: ::protobuf::MessageField<ItemAttributes>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.Item.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Item {
    fn default() -> &'a Item {
        <Item as ::protobuf::Message>::default_instance()
    }
}

impl Item {
    pub fn new() -> Item {
        ::std::default::Default::default()
    }

    // required string uri = 1;

    pub fn uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        self.uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &Item| { &m.uri },
            |m: &mut Item| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ItemAttributes>(
            "attributes",
            |m: &Item| { &m.attributes },
            |m: &mut Item| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Item>(
            "Item",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Item {
    const NAME: &'static str = "Item";

    fn is_initialized(&self) -> bool {
        if self.uri.is_none() {
            return false;
        }
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attributes)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uri.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Item {
        Item::new()
    }

    fn clear(&mut self) {
        self.uri = ::std::option::Option::None;
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Item {
        static instance: Item = Item {
            uri: ::std::option::Option::None,
            attributes: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Item {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Item").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Item {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.MetaItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MetaItem {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.revision)
    pub revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.attributes)
    pub attributes: ::protobuf::MessageField<ListAttributes>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.length)
    pub length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.owner_username)
    pub owner_username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.abuse_reporting_enabled)
    pub abuse_reporting_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.capabilities)
    pub capabilities: ::protobuf::MessageField<super::playlist_permission::Capabilities>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.geoblock)
    pub geoblock: ::std::vec::Vec<::protobuf::EnumOrUnknown<GeoblockBlockingType>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.MetaItem.status_code)
    pub status_code: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.MetaItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetaItem {
    fn default() -> &'a MetaItem {
        <MetaItem as ::protobuf::Message>::default_instance()
    }
}

impl MetaItem {
    pub fn new() -> MetaItem {
        ::std::default::Default::default()
    }

    // optional bytes revision = 1;

    pub fn revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 length = 3;

    pub fn length(&self) -> i32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional int64 timestamp = 4;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string owner_username = 5;

    pub fn owner_username(&self) -> &str {
        match self.owner_username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_owner_username(&mut self) {
        self.owner_username = ::std::option::Option::None;
    }

    pub fn has_owner_username(&self) -> bool {
        self.owner_username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_username(&mut self, v: ::std::string::String) {
        self.owner_username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_username(&mut self) -> &mut ::std::string::String {
        if self.owner_username.is_none() {
            self.owner_username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.owner_username.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_username(&mut self) -> ::std::string::String {
        self.owner_username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool abuse_reporting_enabled = 6;

    pub fn abuse_reporting_enabled(&self) -> bool {
        self.abuse_reporting_enabled.unwrap_or(false)
    }

    pub fn clear_abuse_reporting_enabled(&mut self) {
        self.abuse_reporting_enabled = ::std::option::Option::None;
    }

    pub fn has_abuse_reporting_enabled(&self) -> bool {
        self.abuse_reporting_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abuse_reporting_enabled(&mut self, v: bool) {
        self.abuse_reporting_enabled = ::std::option::Option::Some(v);
    }

    // optional sint32 status_code = 9;

    pub fn status_code(&self) -> i32 {
        self.status_code.unwrap_or(0)
    }

    pub fn clear_status_code(&mut self) {
        self.status_code = ::std::option::Option::None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &MetaItem| { &m.revision },
            |m: &mut MetaItem| { &mut m.revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListAttributes>(
            "attributes",
            |m: &MetaItem| { &m.attributes },
            |m: &mut MetaItem| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &MetaItem| { &m.length },
            |m: &mut MetaItem| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &MetaItem| { &m.timestamp },
            |m: &mut MetaItem| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_username",
            |m: &MetaItem| { &m.owner_username },
            |m: &mut MetaItem| { &mut m.owner_username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abuse_reporting_enabled",
            |m: &MetaItem| { &m.abuse_reporting_enabled },
            |m: &mut MetaItem| { &mut m.abuse_reporting_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::playlist_permission::Capabilities>(
            "capabilities",
            |m: &MetaItem| { &m.capabilities },
            |m: &mut MetaItem| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "geoblock",
            |m: &MetaItem| { &m.geoblock },
            |m: &mut MetaItem| { &mut m.geoblock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_code",
            |m: &MetaItem| { &m.status_code },
            |m: &mut MetaItem| { &mut m.status_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetaItem>(
            "MetaItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetaItem {
    const NAME: &'static str = "MetaItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attributes)?;
                },
                24 => {
                    self.length = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.owner_username = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.abuse_reporting_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                64 => {
                    self.geoblock.push(is.read_enum_or_unknown()?);
                },
                66 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.geoblock)?
                },
                72 => {
                    self.status_code = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.owner_username.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.abuse_reporting_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.geoblock {
            my_size += ::protobuf::rt::int32_size(8, value.value());
        };
        if let Some(v) = self.status_code {
            my_size += ::protobuf::rt::sint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.length {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.owner_username.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.abuse_reporting_enabled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.geoblock {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.status_code {
            os.write_sint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetaItem {
        MetaItem::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.attributes.clear();
        self.length = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.owner_username = ::std::option::Option::None;
        self.abuse_reporting_enabled = ::std::option::Option::None;
        self.capabilities.clear();
        self.geoblock.clear();
        self.status_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetaItem {
        static instance: MetaItem = MetaItem {
            revision: ::std::option::Option::None,
            attributes: ::protobuf::MessageField::none(),
            length: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            owner_username: ::std::option::Option::None,
            abuse_reporting_enabled: ::std::option::Option::None,
            capabilities: ::protobuf::MessageField::none(),
            geoblock: ::std::vec::Vec::new(),
            status_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetaItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetaItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetaItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ListItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListItems {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListItems.pos)
    pub pos: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListItems.truncated)
    pub truncated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListItems.items)
    pub items: ::std::vec::Vec<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListItems.meta_items)
    pub meta_items: ::std::vec::Vec<MetaItem>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListItems.available_signals)
    pub available_signals: ::std::vec::Vec<super::signal_model::Signal>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListItems.continuation_token)
    pub continuation_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ListItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListItems {
    fn default() -> &'a ListItems {
        <ListItems as ::protobuf::Message>::default_instance()
    }
}

impl ListItems {
    pub fn new() -> ListItems {
        ::std::default::Default::default()
    }

    // required int32 pos = 1;

    pub fn pos(&self) -> i32 {
        self.pos.unwrap_or(0)
    }

    pub fn clear_pos(&mut self) {
        self.pos = ::std::option::Option::None;
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: i32) {
        self.pos = ::std::option::Option::Some(v);
    }

    // required bool truncated = 2;

    pub fn truncated(&self) -> bool {
        self.truncated.unwrap_or(false)
    }

    pub fn clear_truncated(&mut self) {
        self.truncated = ::std::option::Option::None;
    }

    pub fn has_truncated(&self) -> bool {
        self.truncated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_truncated(&mut self, v: bool) {
        self.truncated = ::std::option::Option::Some(v);
    }

    // optional string continuation_token = 6;

    pub fn continuation_token(&self) -> &str {
        match self.continuation_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_continuation_token(&mut self) {
        self.continuation_token = ::std::option::Option::None;
    }

    pub fn has_continuation_token(&self) -> bool {
        self.continuation_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continuation_token(&mut self, v: ::std::string::String) {
        self.continuation_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_continuation_token(&mut self) -> &mut ::std::string::String {
        if self.continuation_token.is_none() {
            self.continuation_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.continuation_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_continuation_token(&mut self) -> ::std::string::String {
        self.continuation_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos",
            |m: &ListItems| { &m.pos },
            |m: &mut ListItems| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "truncated",
            |m: &ListItems| { &m.truncated },
            |m: &mut ListItems| { &mut m.truncated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ListItems| { &m.items },
            |m: &mut ListItems| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "meta_items",
            |m: &ListItems| { &m.meta_items },
            |m: &mut ListItems| { &mut m.meta_items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "available_signals",
            |m: &ListItems| { &m.available_signals },
            |m: &mut ListItems| { &mut m.available_signals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "continuation_token",
            |m: &ListItems| { &m.continuation_token },
            |m: &mut ListItems| { &mut m.continuation_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListItems>(
            "ListItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListItems {
    const NAME: &'static str = "ListItems";

    fn is_initialized(&self) -> bool {
        if self.pos.is_none() {
            return false;
        }
        if self.truncated.is_none() {
            return false;
        }
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.meta_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.available_signals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pos = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.truncated = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.items.push(is.read_message()?);
                },
                34 => {
                    self.meta_items.push(is.read_message()?);
                },
                42 => {
                    self.available_signals.push(is.read_message()?);
                },
                50 => {
                    self.continuation_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.truncated {
            my_size += 1 + 1;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.meta_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.available_signals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.continuation_token.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.truncated {
            os.write_bool(2, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.meta_items {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.available_signals {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.continuation_token.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListItems {
        ListItems::new()
    }

    fn clear(&mut self) {
        self.pos = ::std::option::Option::None;
        self.truncated = ::std::option::Option::None;
        self.items.clear();
        self.meta_items.clear();
        self.available_signals.clear();
        self.continuation_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListItems {
        static instance: ListItems = ListItems {
            pos: ::std::option::Option::None,
            truncated: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            meta_items: ::std::vec::Vec::new(),
            available_signals: ::std::vec::Vec::new(),
            continuation_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.PaginatedUnfollowedListItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PaginatedUnfollowedListItems {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PaginatedUnfollowedListItems.limit)
    pub limit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PaginatedUnfollowedListItems.offset)
    pub offset: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PaginatedUnfollowedListItems.nextPageIndex)
    pub nextPageIndex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PaginatedUnfollowedListItems.previousPageIndex)
    pub previousPageIndex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PaginatedUnfollowedListItems.totalPages)
    pub totalPages: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PaginatedUnfollowedListItems.items)
    pub items: ::std::vec::Vec<UnfollowedListItem>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.PaginatedUnfollowedListItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaginatedUnfollowedListItems {
    fn default() -> &'a PaginatedUnfollowedListItems {
        <PaginatedUnfollowedListItems as ::protobuf::Message>::default_instance()
    }
}

impl PaginatedUnfollowedListItems {
    pub fn new() -> PaginatedUnfollowedListItems {
        ::std::default::Default::default()
    }

    // optional int32 limit = 1;

    pub fn limit(&self) -> i32 {
        self.limit.unwrap_or(0)
    }

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = ::std::option::Option::Some(v);
    }

    // optional int32 offset = 2;

    pub fn offset(&self) -> i32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional int32 nextPageIndex = 3;

    pub fn nextPageIndex(&self) -> i32 {
        self.nextPageIndex.unwrap_or(0)
    }

    pub fn clear_nextPageIndex(&mut self) {
        self.nextPageIndex = ::std::option::Option::None;
    }

    pub fn has_nextPageIndex(&self) -> bool {
        self.nextPageIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextPageIndex(&mut self, v: i32) {
        self.nextPageIndex = ::std::option::Option::Some(v);
    }

    // optional int32 previousPageIndex = 4;

    pub fn previousPageIndex(&self) -> i32 {
        self.previousPageIndex.unwrap_or(0)
    }

    pub fn clear_previousPageIndex(&mut self) {
        self.previousPageIndex = ::std::option::Option::None;
    }

    pub fn has_previousPageIndex(&self) -> bool {
        self.previousPageIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previousPageIndex(&mut self, v: i32) {
        self.previousPageIndex = ::std::option::Option::Some(v);
    }

    // optional int32 totalPages = 5;

    pub fn totalPages(&self) -> i32 {
        self.totalPages.unwrap_or(0)
    }

    pub fn clear_totalPages(&mut self) {
        self.totalPages = ::std::option::Option::None;
    }

    pub fn has_totalPages(&self) -> bool {
        self.totalPages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalPages(&mut self, v: i32) {
        self.totalPages = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limit",
            |m: &PaginatedUnfollowedListItems| { &m.limit },
            |m: &mut PaginatedUnfollowedListItems| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &PaginatedUnfollowedListItems| { &m.offset },
            |m: &mut PaginatedUnfollowedListItems| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nextPageIndex",
            |m: &PaginatedUnfollowedListItems| { &m.nextPageIndex },
            |m: &mut PaginatedUnfollowedListItems| { &mut m.nextPageIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previousPageIndex",
            |m: &PaginatedUnfollowedListItems| { &m.previousPageIndex },
            |m: &mut PaginatedUnfollowedListItems| { &mut m.previousPageIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "totalPages",
            |m: &PaginatedUnfollowedListItems| { &m.totalPages },
            |m: &mut PaginatedUnfollowedListItems| { &mut m.totalPages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PaginatedUnfollowedListItems| { &m.items },
            |m: &mut PaginatedUnfollowedListItems| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaginatedUnfollowedListItems>(
            "PaginatedUnfollowedListItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaginatedUnfollowedListItems {
    const NAME: &'static str = "PaginatedUnfollowedListItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limit = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.nextPageIndex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.previousPageIndex = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.totalPages = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.nextPageIndex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.previousPageIndex {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.totalPages {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.limit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.nextPageIndex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.previousPageIndex {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.totalPages {
            os.write_int32(5, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaginatedUnfollowedListItems {
        PaginatedUnfollowedListItems::new()
    }

    fn clear(&mut self) {
        self.limit = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.nextPageIndex = ::std::option::Option::None;
        self.previousPageIndex = ::std::option::Option::None;
        self.totalPages = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaginatedUnfollowedListItems {
        static instance: PaginatedUnfollowedListItems = PaginatedUnfollowedListItems {
            limit: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            nextPageIndex: ::std::option::Option::None,
            previousPageIndex: ::std::option::Option::None,
            totalPages: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaginatedUnfollowedListItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaginatedUnfollowedListItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaginatedUnfollowedListItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaginatedUnfollowedListItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.UnfollowedListItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnfollowedListItem {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UnfollowedListItem.uri)
    pub uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UnfollowedListItem.recoverable)
    pub recoverable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UnfollowedListItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UnfollowedListItem.deleted_at)
    pub deleted_at: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UnfollowedListItem.length)
    pub length: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.UnfollowedListItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnfollowedListItem {
    fn default() -> &'a UnfollowedListItem {
        <UnfollowedListItem as ::protobuf::Message>::default_instance()
    }
}

impl UnfollowedListItem {
    pub fn new() -> UnfollowedListItem {
        ::std::default::Default::default()
    }

    // optional string uri = 1;

    pub fn uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        self.uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool recoverable = 2;

    pub fn recoverable(&self) -> bool {
        self.recoverable.unwrap_or(false)
    }

    pub fn clear_recoverable(&mut self) {
        self.recoverable = ::std::option::Option::None;
    }

    pub fn has_recoverable(&self) -> bool {
        self.recoverable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recoverable(&mut self, v: bool) {
        self.recoverable = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 deleted_at = 4;

    pub fn deleted_at(&self) -> i64 {
        self.deleted_at.unwrap_or(0)
    }

    pub fn clear_deleted_at(&mut self) {
        self.deleted_at = ::std::option::Option::None;
    }

    pub fn has_deleted_at(&self) -> bool {
        self.deleted_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted_at(&mut self, v: i64) {
        self.deleted_at = ::std::option::Option::Some(v);
    }

    // optional int32 length = 5;

    pub fn length(&self) -> i32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &UnfollowedListItem| { &m.uri },
            |m: &mut UnfollowedListItem| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recoverable",
            |m: &UnfollowedListItem| { &m.recoverable },
            |m: &mut UnfollowedListItem| { &mut m.recoverable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &UnfollowedListItem| { &m.name },
            |m: &mut UnfollowedListItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted_at",
            |m: &UnfollowedListItem| { &m.deleted_at },
            |m: &mut UnfollowedListItem| { &mut m.deleted_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &UnfollowedListItem| { &m.length },
            |m: &mut UnfollowedListItem| { &mut m.length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnfollowedListItem>(
            "UnfollowedListItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnfollowedListItem {
    const NAME: &'static str = "UnfollowedListItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.recoverable = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.deleted_at = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.length = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.recoverable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.deleted_at {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uri.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.recoverable {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.deleted_at {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnfollowedListItem {
        UnfollowedListItem::new()
    }

    fn clear(&mut self) {
        self.uri = ::std::option::Option::None;
        self.recoverable = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.deleted_at = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnfollowedListItem {
        static instance: UnfollowedListItem = UnfollowedListItem {
            uri: ::std::option::Option::None,
            recoverable: ::std::option::Option::None,
            name: ::std::option::Option::None,
            deleted_at: ::std::option::Option::None,
            length: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnfollowedListItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnfollowedListItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnfollowedListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnfollowedListItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.FormatListAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FormatListAttribute {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.FormatListAttribute.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.FormatListAttribute.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.FormatListAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FormatListAttribute {
    fn default() -> &'a FormatListAttribute {
        <FormatListAttribute as ::protobuf::Message>::default_instance()
    }
}

impl FormatListAttribute {
    pub fn new() -> FormatListAttribute {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &FormatListAttribute| { &m.key },
            |m: &mut FormatListAttribute| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &FormatListAttribute| { &m.value },
            |m: &mut FormatListAttribute| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormatListAttribute>(
            "FormatListAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FormatListAttribute {
    const NAME: &'static str = "FormatListAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FormatListAttribute {
        FormatListAttribute::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FormatListAttribute {
        static instance: FormatListAttribute = FormatListAttribute {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FormatListAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FormatListAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FormatListAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatListAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.PictureSize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PictureSize {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PictureSize.target_name)
    pub target_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PictureSize.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.PictureSize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PictureSize {
    fn default() -> &'a PictureSize {
        <PictureSize as ::protobuf::Message>::default_instance()
    }
}

impl PictureSize {
    pub fn new() -> PictureSize {
        ::std::default::Default::default()
    }

    // optional string target_name = 1;

    pub fn target_name(&self) -> &str {
        match self.target_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target_name(&mut self) {
        self.target_name = ::std::option::Option::None;
    }

    pub fn has_target_name(&self) -> bool {
        self.target_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_name(&mut self, v: ::std::string::String) {
        self.target_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_name(&mut self) -> &mut ::std::string::String {
        if self.target_name.is_none() {
            self.target_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_name(&mut self) -> ::std::string::String {
        self.target_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_name",
            |m: &PictureSize| { &m.target_name },
            |m: &mut PictureSize| { &mut m.target_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &PictureSize| { &m.url },
            |m: &mut PictureSize| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PictureSize>(
            "PictureSize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PictureSize {
    const NAME: &'static str = "PictureSize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PictureSize {
        PictureSize::new()
    }

    fn clear(&mut self) {
        self.target_name = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PictureSize {
        static instance: PictureSize = PictureSize {
            target_name: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PictureSize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PictureSize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PictureSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PictureSize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.RecommendationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RecommendationInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.RecommendationInfo.is_recommendation)
    pub is_recommendation: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.RecommendationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecommendationInfo {
    fn default() -> &'a RecommendationInfo {
        <RecommendationInfo as ::protobuf::Message>::default_instance()
    }
}

impl RecommendationInfo {
    pub fn new() -> RecommendationInfo {
        ::std::default::Default::default()
    }

    // optional bool is_recommendation = 1;

    pub fn is_recommendation(&self) -> bool {
        self.is_recommendation.unwrap_or(false)
    }

    pub fn clear_is_recommendation(&mut self) {
        self.is_recommendation = ::std::option::Option::None;
    }

    pub fn has_is_recommendation(&self) -> bool {
        self.is_recommendation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_recommendation(&mut self, v: bool) {
        self.is_recommendation = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_recommendation",
            |m: &RecommendationInfo| { &m.is_recommendation },
            |m: &mut RecommendationInfo| { &mut m.is_recommendation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecommendationInfo>(
            "RecommendationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecommendationInfo {
    const NAME: &'static str = "RecommendationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_recommendation = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_recommendation {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_recommendation {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecommendationInfo {
        RecommendationInfo::new()
    }

    fn clear(&mut self) {
        self.is_recommendation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecommendationInfo {
        static instance: RecommendationInfo = RecommendationInfo {
            is_recommendation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecommendationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecommendationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecommendationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecommendationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ListAttributes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAttributes {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.picture)
    pub picture: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.collaborative)
    pub collaborative: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.pl3_version)
    pub pl3_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.deleted_by_owner)
    pub deleted_by_owner: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.client_id)
    pub client_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.format)
    pub format: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.format_attributes)
    pub format_attributes: ::std::vec::Vec<FormatListAttribute>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.picture_size)
    pub picture_size: ::std::vec::Vec<PictureSize>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.sequence_context_template)
    pub sequence_context_template: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributes.ai_curation_reference_id)
    pub ai_curation_reference_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ListAttributes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAttributes {
    fn default() -> &'a ListAttributes {
        <ListAttributes as ::protobuf::Message>::default_instance()
    }
}

impl ListAttributes {
    pub fn new() -> ListAttributes {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 2;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes picture = 3;

    pub fn picture(&self) -> &[u8] {
        match self.picture.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_picture(&mut self) {
        self.picture = ::std::option::Option::None;
    }

    pub fn has_picture(&self) -> bool {
        self.picture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picture(&mut self, v: ::std::vec::Vec<u8>) {
        self.picture = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_picture(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.picture.is_none() {
            self.picture = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.picture.as_mut().unwrap()
    }

    // Take field
    pub fn take_picture(&mut self) -> ::std::vec::Vec<u8> {
        self.picture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool collaborative = 4;

    pub fn collaborative(&self) -> bool {
        self.collaborative.unwrap_or(false)
    }

    pub fn clear_collaborative(&mut self) {
        self.collaborative = ::std::option::Option::None;
    }

    pub fn has_collaborative(&self) -> bool {
        self.collaborative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collaborative(&mut self, v: bool) {
        self.collaborative = ::std::option::Option::Some(v);
    }

    // optional string pl3_version = 5;

    pub fn pl3_version(&self) -> &str {
        match self.pl3_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pl3_version(&mut self) {
        self.pl3_version = ::std::option::Option::None;
    }

    pub fn has_pl3_version(&self) -> bool {
        self.pl3_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pl3_version(&mut self, v: ::std::string::String) {
        self.pl3_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pl3_version(&mut self) -> &mut ::std::string::String {
        if self.pl3_version.is_none() {
            self.pl3_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pl3_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_pl3_version(&mut self) -> ::std::string::String {
        self.pl3_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool deleted_by_owner = 6;

    pub fn deleted_by_owner(&self) -> bool {
        self.deleted_by_owner.unwrap_or(false)
    }

    pub fn clear_deleted_by_owner(&mut self) {
        self.deleted_by_owner = ::std::option::Option::None;
    }

    pub fn has_deleted_by_owner(&self) -> bool {
        self.deleted_by_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted_by_owner(&mut self, v: bool) {
        self.deleted_by_owner = ::std::option::Option::Some(v);
    }

    // optional string client_id = 10;

    pub fn client_id(&self) -> &str {
        match self.client_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        if self.client_id.is_none() {
            self.client_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.client_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        self.client_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string format = 11;

    pub fn format(&self) -> &str {
        match self.format.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        if self.format.is_none() {
            self.format = ::std::option::Option::Some(::std::string::String::new());
        }
        self.format.as_mut().unwrap()
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        self.format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sequence_context_template = 14;

    pub fn sequence_context_template(&self) -> &[u8] {
        match self.sequence_context_template.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sequence_context_template(&mut self) {
        self.sequence_context_template = ::std::option::Option::None;
    }

    pub fn has_sequence_context_template(&self) -> bool {
        self.sequence_context_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_context_template(&mut self, v: ::std::vec::Vec<u8>) {
        self.sequence_context_template = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_context_template(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sequence_context_template.is_none() {
            self.sequence_context_template = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sequence_context_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_context_template(&mut self) -> ::std::vec::Vec<u8> {
        self.sequence_context_template.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ai_curation_reference_id = 15;

    pub fn ai_curation_reference_id(&self) -> &[u8] {
        match self.ai_curation_reference_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ai_curation_reference_id(&mut self) {
        self.ai_curation_reference_id = ::std::option::Option::None;
    }

    pub fn has_ai_curation_reference_id(&self) -> bool {
        self.ai_curation_reference_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ai_curation_reference_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.ai_curation_reference_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ai_curation_reference_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ai_curation_reference_id.is_none() {
            self.ai_curation_reference_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ai_curation_reference_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_ai_curation_reference_id(&mut self) -> ::std::vec::Vec<u8> {
        self.ai_curation_reference_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ListAttributes| { &m.name },
            |m: &mut ListAttributes| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ListAttributes| { &m.description },
            |m: &mut ListAttributes| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "picture",
            |m: &ListAttributes| { &m.picture },
            |m: &mut ListAttributes| { &mut m.picture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collaborative",
            |m: &ListAttributes| { &m.collaborative },
            |m: &mut ListAttributes| { &mut m.collaborative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pl3_version",
            |m: &ListAttributes| { &m.pl3_version },
            |m: &mut ListAttributes| { &mut m.pl3_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted_by_owner",
            |m: &ListAttributes| { &m.deleted_by_owner },
            |m: &mut ListAttributes| { &mut m.deleted_by_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_id",
            |m: &ListAttributes| { &m.client_id },
            |m: &mut ListAttributes| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &ListAttributes| { &m.format },
            |m: &mut ListAttributes| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "format_attributes",
            |m: &ListAttributes| { &m.format_attributes },
            |m: &mut ListAttributes| { &mut m.format_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "picture_size",
            |m: &ListAttributes| { &m.picture_size },
            |m: &mut ListAttributes| { &mut m.picture_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_context_template",
            |m: &ListAttributes| { &m.sequence_context_template },
            |m: &mut ListAttributes| { &mut m.sequence_context_template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ai_curation_reference_id",
            |m: &ListAttributes| { &m.ai_curation_reference_id },
            |m: &mut ListAttributes| { &mut m.ai_curation_reference_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAttributes>(
            "ListAttributes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAttributes {
    const NAME: &'static str = "ListAttributes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.picture = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.collaborative = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.pl3_version = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.deleted_by_owner = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.client_id = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.format = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.format_attributes.push(is.read_message()?);
                },
                106 => {
                    self.picture_size.push(is.read_message()?);
                },
                114 => {
                    self.sequence_context_template = ::std::option::Option::Some(is.read_bytes()?);
                },
                122 => {
                    self.ai_curation_reference_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.picture.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.collaborative {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pl3_version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.deleted_by_owner {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_id.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.format.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.format_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.picture_size {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.sequence_context_template.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.ai_curation_reference_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.picture.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.collaborative {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.pl3_version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.deleted_by_owner {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.client_id.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.format_attributes {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.picture_size {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.sequence_context_template.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.ai_curation_reference_id.as_ref() {
            os.write_bytes(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAttributes {
        ListAttributes::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.picture = ::std::option::Option::None;
        self.collaborative = ::std::option::Option::None;
        self.pl3_version = ::std::option::Option::None;
        self.deleted_by_owner = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.format_attributes.clear();
        self.picture_size.clear();
        self.sequence_context_template = ::std::option::Option::None;
        self.ai_curation_reference_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAttributes {
        static instance: ListAttributes = ListAttributes {
            name: ::std::option::Option::None,
            description: ::std::option::Option::None,
            picture: ::std::option::Option::None,
            collaborative: ::std::option::Option::None,
            pl3_version: ::std::option::Option::None,
            deleted_by_owner: ::std::option::Option::None,
            client_id: ::std::option::Option::None,
            format: ::std::option::Option::None,
            format_attributes: ::std::vec::Vec::new(),
            picture_size: ::std::vec::Vec::new(),
            sequence_context_template: ::std::option::Option::None,
            ai_curation_reference_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAttributes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAttributes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAttributes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ItemAttributes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ItemAttributes {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.added_by)
    pub added_by: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.seen_at)
    pub seen_at: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.public)
    pub public: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.format_attributes)
    pub format_attributes: ::std::vec::Vec<FormatListAttribute>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.item_id)
    pub item_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.source_lens)
    pub source_lens: ::protobuf::MessageField<super::lens_model::Lens>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.available_signals)
    pub available_signals: ::std::vec::Vec<super::signal_model::Signal>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.recommendation_info)
    pub recommendation_info: ::protobuf::MessageField<RecommendationInfo>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributes.sequence_child_template)
    pub sequence_child_template: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ItemAttributes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ItemAttributes {
    fn default() -> &'a ItemAttributes {
        <ItemAttributes as ::protobuf::Message>::default_instance()
    }
}

impl ItemAttributes {
    pub fn new() -> ItemAttributes {
        ::std::default::Default::default()
    }

    // optional string added_by = 1;

    pub fn added_by(&self) -> &str {
        match self.added_by.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_added_by(&mut self) {
        self.added_by = ::std::option::Option::None;
    }

    pub fn has_added_by(&self) -> bool {
        self.added_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_added_by(&mut self, v: ::std::string::String) {
        self.added_by = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_added_by(&mut self) -> &mut ::std::string::String {
        if self.added_by.is_none() {
            self.added_by = ::std::option::Option::Some(::std::string::String::new());
        }
        self.added_by.as_mut().unwrap()
    }

    // Take field
    pub fn take_added_by(&mut self) -> ::std::string::String {
        self.added_by.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 seen_at = 9;

    pub fn seen_at(&self) -> i64 {
        self.seen_at.unwrap_or(0)
    }

    pub fn clear_seen_at(&mut self) {
        self.seen_at = ::std::option::Option::None;
    }

    pub fn has_seen_at(&self) -> bool {
        self.seen_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seen_at(&mut self, v: i64) {
        self.seen_at = ::std::option::Option::Some(v);
    }

    // optional bool public = 10;

    pub fn public(&self) -> bool {
        self.public.unwrap_or(false)
    }

    pub fn clear_public(&mut self) {
        self.public = ::std::option::Option::None;
    }

    pub fn has_public(&self) -> bool {
        self.public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public(&mut self, v: bool) {
        self.public = ::std::option::Option::Some(v);
    }

    // optional bytes item_id = 12;

    pub fn item_id(&self) -> &[u8] {
        match self.item_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.item_id.is_none() {
            self.item_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.item_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_id(&mut self) -> ::std::vec::Vec<u8> {
        self.item_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes sequence_child_template = 16;

    pub fn sequence_child_template(&self) -> &[u8] {
        match self.sequence_child_template.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sequence_child_template(&mut self) {
        self.sequence_child_template = ::std::option::Option::None;
    }

    pub fn has_sequence_child_template(&self) -> bool {
        self.sequence_child_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_child_template(&mut self, v: ::std::vec::Vec<u8>) {
        self.sequence_child_template = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_child_template(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sequence_child_template.is_none() {
            self.sequence_child_template = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sequence_child_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_child_template(&mut self) -> ::std::vec::Vec<u8> {
        self.sequence_child_template.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "added_by",
            |m: &ItemAttributes| { &m.added_by },
            |m: &mut ItemAttributes| { &mut m.added_by },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ItemAttributes| { &m.timestamp },
            |m: &mut ItemAttributes| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seen_at",
            |m: &ItemAttributes| { &m.seen_at },
            |m: &mut ItemAttributes| { &mut m.seen_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public",
            |m: &ItemAttributes| { &m.public },
            |m: &mut ItemAttributes| { &mut m.public },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "format_attributes",
            |m: &ItemAttributes| { &m.format_attributes },
            |m: &mut ItemAttributes| { &mut m.format_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &ItemAttributes| { &m.item_id },
            |m: &mut ItemAttributes| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::lens_model::Lens>(
            "source_lens",
            |m: &ItemAttributes| { &m.source_lens },
            |m: &mut ItemAttributes| { &mut m.source_lens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "available_signals",
            |m: &ItemAttributes| { &m.available_signals },
            |m: &mut ItemAttributes| { &mut m.available_signals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecommendationInfo>(
            "recommendation_info",
            |m: &ItemAttributes| { &m.recommendation_info },
            |m: &mut ItemAttributes| { &mut m.recommendation_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_child_template",
            |m: &ItemAttributes| { &m.sequence_child_template },
            |m: &mut ItemAttributes| { &mut m.sequence_child_template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemAttributes>(
            "ItemAttributes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ItemAttributes {
    const NAME: &'static str = "ItemAttributes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.added_by = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.seen_at = ::std::option::Option::Some(is.read_int64()?);
                },
                80 => {
                    self.public = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.format_attributes.push(is.read_message()?);
                },
                98 => {
                    self.item_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_lens)?;
                },
                114 => {
                    self.available_signals.push(is.read_message()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recommendation_info)?;
                },
                130 => {
                    self.sequence_child_template = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.added_by.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.seen_at {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.public {
            my_size += 1 + 1;
        }
        for value in &self.format_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.item_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.source_lens.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.available_signals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.recommendation_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sequence_child_template.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.added_by.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.seen_at {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.public {
            os.write_bool(10, v)?;
        }
        for v in &self.format_attributes {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.item_id.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.source_lens.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        for v in &self.available_signals {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.recommendation_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.sequence_child_template.as_ref() {
            os.write_bytes(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ItemAttributes {
        ItemAttributes::new()
    }

    fn clear(&mut self) {
        self.added_by = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.seen_at = ::std::option::Option::None;
        self.public = ::std::option::Option::None;
        self.format_attributes.clear();
        self.item_id = ::std::option::Option::None;
        self.source_lens.clear();
        self.available_signals.clear();
        self.recommendation_info.clear();
        self.sequence_child_template = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ItemAttributes {
        static instance: ItemAttributes = ItemAttributes {
            added_by: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            seen_at: ::std::option::Option::None,
            public: ::std::option::Option::None,
            format_attributes: ::std::vec::Vec::new(),
            item_id: ::std::option::Option::None,
            source_lens: ::protobuf::MessageField::none(),
            available_signals: ::std::vec::Vec::new(),
            recommendation_info: ::protobuf::MessageField::none(),
            sequence_child_template: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ItemAttributes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ItemAttributes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ItemAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemAttributes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.Add)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Add {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Add.from_index)
    pub from_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Add.items)
    pub items: ::std::vec::Vec<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Add.add_last)
    pub add_last: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Add.add_first)
    pub add_first: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Add.add_before_item)
    pub add_before_item: ::protobuf::MessageField<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Add.add_after_item)
    pub add_after_item: ::protobuf::MessageField<Item>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.Add.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Add {
    fn default() -> &'a Add {
        <Add as ::protobuf::Message>::default_instance()
    }
}

impl Add {
    pub fn new() -> Add {
        ::std::default::Default::default()
    }

    // optional int32 from_index = 1;

    pub fn from_index(&self) -> i32 {
        self.from_index.unwrap_or(0)
    }

    pub fn clear_from_index(&mut self) {
        self.from_index = ::std::option::Option::None;
    }

    pub fn has_from_index(&self) -> bool {
        self.from_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_index(&mut self, v: i32) {
        self.from_index = ::std::option::Option::Some(v);
    }

    // optional bool add_last = 4;

    pub fn add_last(&self) -> bool {
        self.add_last.unwrap_or(false)
    }

    pub fn clear_add_last(&mut self) {
        self.add_last = ::std::option::Option::None;
    }

    pub fn has_add_last(&self) -> bool {
        self.add_last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_last(&mut self, v: bool) {
        self.add_last = ::std::option::Option::Some(v);
    }

    // optional bool add_first = 5;

    pub fn add_first(&self) -> bool {
        self.add_first.unwrap_or(false)
    }

    pub fn clear_add_first(&mut self) {
        self.add_first = ::std::option::Option::None;
    }

    pub fn has_add_first(&self) -> bool {
        self.add_first.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_first(&mut self, v: bool) {
        self.add_first = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_index",
            |m: &Add| { &m.from_index },
            |m: &mut Add| { &mut m.from_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &Add| { &m.items },
            |m: &mut Add| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_last",
            |m: &Add| { &m.add_last },
            |m: &mut Add| { &mut m.add_last },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_first",
            |m: &Add| { &m.add_first },
            |m: &mut Add| { &mut m.add_first },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "add_before_item",
            |m: &Add| { &m.add_before_item },
            |m: &mut Add| { &mut m.add_before_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "add_after_item",
            |m: &Add| { &m.add_after_item },
            |m: &mut Add| { &mut m.add_after_item },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Add>(
            "Add",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Add {
    const NAME: &'static str = "Add";

    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_before_item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_after_item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.from_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                32 => {
                    self.add_last = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.add_first = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add_before_item)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add_after_item)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.from_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.add_last {
            my_size += 1 + 1;
        }
        if let Some(v) = self.add_first {
            my_size += 1 + 1;
        }
        if let Some(v) = self.add_before_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.add_after_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.from_index {
            os.write_int32(1, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.add_last {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.add_first {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.add_before_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.add_after_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Add {
        Add::new()
    }

    fn clear(&mut self) {
        self.from_index = ::std::option::Option::None;
        self.items.clear();
        self.add_last = ::std::option::Option::None;
        self.add_first = ::std::option::Option::None;
        self.add_before_item.clear();
        self.add_after_item.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Add {
        static instance: Add = Add {
            from_index: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            add_last: ::std::option::Option::None,
            add_first: ::std::option::Option::None,
            add_before_item: ::protobuf::MessageField::none(),
            add_after_item: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Add {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Add").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Add {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Add {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.Rem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rem {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Rem.from_index)
    pub from_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Rem.length)
    pub length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Rem.items)
    pub items: ::std::vec::Vec<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Rem.items_as_key)
    pub items_as_key: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.Rem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rem {
    fn default() -> &'a Rem {
        <Rem as ::protobuf::Message>::default_instance()
    }
}

impl Rem {
    pub fn new() -> Rem {
        ::std::default::Default::default()
    }

    // optional int32 from_index = 1;

    pub fn from_index(&self) -> i32 {
        self.from_index.unwrap_or(0)
    }

    pub fn clear_from_index(&mut self) {
        self.from_index = ::std::option::Option::None;
    }

    pub fn has_from_index(&self) -> bool {
        self.from_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_index(&mut self, v: i32) {
        self.from_index = ::std::option::Option::Some(v);
    }

    // optional int32 length = 2;

    pub fn length(&self) -> i32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional bool items_as_key = 7;

    pub fn items_as_key(&self) -> bool {
        self.items_as_key.unwrap_or(false)
    }

    pub fn clear_items_as_key(&mut self) {
        self.items_as_key = ::std::option::Option::None;
    }

    pub fn has_items_as_key(&self) -> bool {
        self.items_as_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_as_key(&mut self, v: bool) {
        self.items_as_key = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_index",
            |m: &Rem| { &m.from_index },
            |m: &mut Rem| { &mut m.from_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &Rem| { &m.length },
            |m: &mut Rem| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &Rem| { &m.items },
            |m: &mut Rem| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "items_as_key",
            |m: &Rem| { &m.items_as_key },
            |m: &mut Rem| { &mut m.items_as_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rem>(
            "Rem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rem {
    const NAME: &'static str = "Rem";

    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.from_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.length = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.items.push(is.read_message()?);
                },
                56 => {
                    self.items_as_key = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.from_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.items_as_key {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.from_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.items_as_key {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rem {
        Rem::new()
    }

    fn clear(&mut self) {
        self.from_index = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.items.clear();
        self.items_as_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rem {
        static instance: Rem = Rem {
            from_index: ::std::option::Option::None,
            length: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            items_as_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.Mov)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Mov {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.from_index)
    pub from_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.length)
    pub length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.to_index)
    pub to_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.items)
    pub items: ::std::vec::Vec<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.add_before_item)
    pub add_before_item: ::protobuf::MessageField<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.add_after_item)
    pub add_after_item: ::protobuf::MessageField<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.add_first)
    pub add_first: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Mov.add_last)
    pub add_last: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.Mov.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Mov {
    fn default() -> &'a Mov {
        <Mov as ::protobuf::Message>::default_instance()
    }
}

impl Mov {
    pub fn new() -> Mov {
        ::std::default::Default::default()
    }

    // optional int32 from_index = 1;

    pub fn from_index(&self) -> i32 {
        self.from_index.unwrap_or(0)
    }

    pub fn clear_from_index(&mut self) {
        self.from_index = ::std::option::Option::None;
    }

    pub fn has_from_index(&self) -> bool {
        self.from_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_index(&mut self, v: i32) {
        self.from_index = ::std::option::Option::Some(v);
    }

    // optional int32 length = 2;

    pub fn length(&self) -> i32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional int32 to_index = 3;

    pub fn to_index(&self) -> i32 {
        self.to_index.unwrap_or(0)
    }

    pub fn clear_to_index(&mut self) {
        self.to_index = ::std::option::Option::None;
    }

    pub fn has_to_index(&self) -> bool {
        self.to_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_index(&mut self, v: i32) {
        self.to_index = ::std::option::Option::Some(v);
    }

    // optional bool add_first = 7;

    pub fn add_first(&self) -> bool {
        self.add_first.unwrap_or(false)
    }

    pub fn clear_add_first(&mut self) {
        self.add_first = ::std::option::Option::None;
    }

    pub fn has_add_first(&self) -> bool {
        self.add_first.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_first(&mut self, v: bool) {
        self.add_first = ::std::option::Option::Some(v);
    }

    // optional bool add_last = 8;

    pub fn add_last(&self) -> bool {
        self.add_last.unwrap_or(false)
    }

    pub fn clear_add_last(&mut self) {
        self.add_last = ::std::option::Option::None;
    }

    pub fn has_add_last(&self) -> bool {
        self.add_last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_last(&mut self, v: bool) {
        self.add_last = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_index",
            |m: &Mov| { &m.from_index },
            |m: &mut Mov| { &mut m.from_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &Mov| { &m.length },
            |m: &mut Mov| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_index",
            |m: &Mov| { &m.to_index },
            |m: &mut Mov| { &mut m.to_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &Mov| { &m.items },
            |m: &mut Mov| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "add_before_item",
            |m: &Mov| { &m.add_before_item },
            |m: &mut Mov| { &mut m.add_before_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "add_after_item",
            |m: &Mov| { &m.add_after_item },
            |m: &mut Mov| { &mut m.add_after_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_first",
            |m: &Mov| { &m.add_first },
            |m: &mut Mov| { &mut m.add_first },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_last",
            |m: &Mov| { &m.add_last },
            |m: &mut Mov| { &mut m.add_last },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Mov>(
            "Mov",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Mov {
    const NAME: &'static str = "Mov";

    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_before_item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_after_item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.from_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.length = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.to_index = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.items.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add_before_item)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add_after_item)?;
                },
                56 => {
                    self.add_first = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.add_last = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.from_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.to_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.add_before_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.add_after_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.add_first {
            my_size += 1 + 1;
        }
        if let Some(v) = self.add_last {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.from_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.to_index {
            os.write_int32(3, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.add_before_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.add_after_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.add_first {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.add_last {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Mov {
        Mov::new()
    }

    fn clear(&mut self) {
        self.from_index = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.to_index = ::std::option::Option::None;
        self.items.clear();
        self.add_before_item.clear();
        self.add_after_item.clear();
        self.add_first = ::std::option::Option::None;
        self.add_last = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Mov {
        static instance: Mov = Mov {
            from_index: ::std::option::Option::None,
            length: ::std::option::Option::None,
            to_index: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            add_before_item: ::protobuf::MessageField::none(),
            add_after_item: ::protobuf::MessageField::none(),
            add_first: ::std::option::Option::None,
            add_last: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Mov {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Mov").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Mov {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mov {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ItemAttributesPartialState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ItemAttributesPartialState {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributesPartialState.values)
    pub values: ::protobuf::MessageField<ItemAttributes>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ItemAttributesPartialState.no_value)
    pub no_value: ::std::vec::Vec<::protobuf::EnumOrUnknown<ItemAttributeKind>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ItemAttributesPartialState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ItemAttributesPartialState {
    fn default() -> &'a ItemAttributesPartialState {
        <ItemAttributesPartialState as ::protobuf::Message>::default_instance()
    }
}

impl ItemAttributesPartialState {
    pub fn new() -> ItemAttributesPartialState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ItemAttributes>(
            "values",
            |m: &ItemAttributesPartialState| { &m.values },
            |m: &mut ItemAttributesPartialState| { &mut m.values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "no_value",
            |m: &ItemAttributesPartialState| { &m.no_value },
            |m: &mut ItemAttributesPartialState| { &mut m.no_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemAttributesPartialState>(
            "ItemAttributesPartialState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ItemAttributesPartialState {
    const NAME: &'static str = "ItemAttributesPartialState";

    fn is_initialized(&self) -> bool {
        if self.values.is_none() {
            return false;
        }
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.values)?;
                },
                16 => {
                    self.no_value.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.no_value)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.no_value {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.values.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.no_value {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ItemAttributesPartialState {
        ItemAttributesPartialState::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.no_value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ItemAttributesPartialState {
        static instance: ItemAttributesPartialState = ItemAttributesPartialState {
            values: ::protobuf::MessageField::none(),
            no_value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ItemAttributesPartialState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ItemAttributesPartialState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ItemAttributesPartialState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemAttributesPartialState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ListAttributesPartialState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAttributesPartialState {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributesPartialState.values)
    pub values: ::protobuf::MessageField<ListAttributes>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListAttributesPartialState.no_value)
    pub no_value: ::std::vec::Vec<::protobuf::EnumOrUnknown<ListAttributeKind>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ListAttributesPartialState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAttributesPartialState {
    fn default() -> &'a ListAttributesPartialState {
        <ListAttributesPartialState as ::protobuf::Message>::default_instance()
    }
}

impl ListAttributesPartialState {
    pub fn new() -> ListAttributesPartialState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListAttributes>(
            "values",
            |m: &ListAttributesPartialState| { &m.values },
            |m: &mut ListAttributesPartialState| { &mut m.values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "no_value",
            |m: &ListAttributesPartialState| { &m.no_value },
            |m: &mut ListAttributesPartialState| { &mut m.no_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAttributesPartialState>(
            "ListAttributesPartialState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAttributesPartialState {
    const NAME: &'static str = "ListAttributesPartialState";

    fn is_initialized(&self) -> bool {
        if self.values.is_none() {
            return false;
        }
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.values)?;
                },
                16 => {
                    self.no_value.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.no_value)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.no_value {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.values.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.no_value {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAttributesPartialState {
        ListAttributesPartialState::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.no_value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAttributesPartialState {
        static instance: ListAttributesPartialState = ListAttributesPartialState {
            values: ::protobuf::MessageField::none(),
            no_value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAttributesPartialState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAttributesPartialState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAttributesPartialState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAttributesPartialState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.UpdateItemAttributes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateItemAttributes {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UpdateItemAttributes.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UpdateItemAttributes.new_attributes)
    pub new_attributes: ::protobuf::MessageField<ItemAttributesPartialState>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UpdateItemAttributes.old_attributes)
    pub old_attributes: ::protobuf::MessageField<ItemAttributesPartialState>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UpdateItemAttributes.item)
    pub item: ::protobuf::MessageField<Item>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.UpdateItemAttributes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateItemAttributes {
    fn default() -> &'a UpdateItemAttributes {
        <UpdateItemAttributes as ::protobuf::Message>::default_instance()
    }
}

impl UpdateItemAttributes {
    pub fn new() -> UpdateItemAttributes {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &UpdateItemAttributes| { &m.index },
            |m: &mut UpdateItemAttributes| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ItemAttributesPartialState>(
            "new_attributes",
            |m: &UpdateItemAttributes| { &m.new_attributes },
            |m: &mut UpdateItemAttributes| { &mut m.new_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ItemAttributesPartialState>(
            "old_attributes",
            |m: &UpdateItemAttributes| { &m.old_attributes },
            |m: &mut UpdateItemAttributes| { &mut m.old_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "item",
            |m: &UpdateItemAttributes| { &m.item },
            |m: &mut UpdateItemAttributes| { &mut m.item },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateItemAttributes>(
            "UpdateItemAttributes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateItemAttributes {
    const NAME: &'static str = "UpdateItemAttributes";

    fn is_initialized(&self) -> bool {
        if self.new_attributes.is_none() {
            return false;
        }
        for v in &self.new_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.old_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_attributes)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.old_attributes)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.new_attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.old_attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.new_attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.old_attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateItemAttributes {
        UpdateItemAttributes::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.new_attributes.clear();
        self.old_attributes.clear();
        self.item.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateItemAttributes {
        static instance: UpdateItemAttributes = UpdateItemAttributes {
            index: ::std::option::Option::None,
            new_attributes: ::protobuf::MessageField::none(),
            old_attributes: ::protobuf::MessageField::none(),
            item: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateItemAttributes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateItemAttributes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateItemAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateItemAttributes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.UpdateListAttributes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateListAttributes {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UpdateListAttributes.new_attributes)
    pub new_attributes: ::protobuf::MessageField<ListAttributesPartialState>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UpdateListAttributes.old_attributes)
    pub old_attributes: ::protobuf::MessageField<ListAttributesPartialState>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.UpdateListAttributes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateListAttributes {
    fn default() -> &'a UpdateListAttributes {
        <UpdateListAttributes as ::protobuf::Message>::default_instance()
    }
}

impl UpdateListAttributes {
    pub fn new() -> UpdateListAttributes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListAttributesPartialState>(
            "new_attributes",
            |m: &UpdateListAttributes| { &m.new_attributes },
            |m: &mut UpdateListAttributes| { &mut m.new_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListAttributesPartialState>(
            "old_attributes",
            |m: &UpdateListAttributes| { &m.old_attributes },
            |m: &mut UpdateListAttributes| { &mut m.old_attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateListAttributes>(
            "UpdateListAttributes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateListAttributes {
    const NAME: &'static str = "UpdateListAttributes";

    fn is_initialized(&self) -> bool {
        if self.new_attributes.is_none() {
            return false;
        }
        for v in &self.new_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.old_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_attributes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.old_attributes)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.old_attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.old_attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateListAttributes {
        UpdateListAttributes::new()
    }

    fn clear(&mut self) {
        self.new_attributes.clear();
        self.old_attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateListAttributes {
        static instance: UpdateListAttributes = UpdateListAttributes {
            new_attributes: ::protobuf::MessageField::none(),
            old_attributes: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateListAttributes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateListAttributes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateListAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateListAttributes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.UpdateItemUris)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateItemUris {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UpdateItemUris.uri_replacements)
    pub uri_replacements: ::std::vec::Vec<UriReplacement>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.UpdateItemUris.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateItemUris {
    fn default() -> &'a UpdateItemUris {
        <UpdateItemUris as ::protobuf::Message>::default_instance()
    }
}

impl UpdateItemUris {
    pub fn new() -> UpdateItemUris {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uri_replacements",
            |m: &UpdateItemUris| { &m.uri_replacements },
            |m: &mut UpdateItemUris| { &mut m.uri_replacements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateItemUris>(
            "UpdateItemUris",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateItemUris {
    const NAME: &'static str = "UpdateItemUris";

    fn is_initialized(&self) -> bool {
        for v in &self.uri_replacements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri_replacements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uri_replacements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uri_replacements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateItemUris {
        UpdateItemUris::new()
    }

    fn clear(&mut self) {
        self.uri_replacements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateItemUris {
        static instance: UpdateItemUris = UpdateItemUris {
            uri_replacements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateItemUris {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateItemUris").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateItemUris {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateItemUris {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.UriReplacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UriReplacement {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UriReplacement.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UriReplacement.item)
    pub item: ::protobuf::MessageField<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UriReplacement.new_uri)
    pub new_uri: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.UriReplacement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UriReplacement {
    fn default() -> &'a UriReplacement {
        <UriReplacement as ::protobuf::Message>::default_instance()
    }
}

impl UriReplacement {
    pub fn new() -> UriReplacement {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string new_uri = 3;

    pub fn new_uri(&self) -> &str {
        match self.new_uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_new_uri(&mut self) {
        self.new_uri = ::std::option::Option::None;
    }

    pub fn has_new_uri(&self) -> bool {
        self.new_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_uri(&mut self, v: ::std::string::String) {
        self.new_uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_uri(&mut self) -> &mut ::std::string::String {
        if self.new_uri.is_none() {
            self.new_uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.new_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_uri(&mut self) -> ::std::string::String {
        self.new_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &UriReplacement| { &m.index },
            |m: &mut UriReplacement| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Item>(
            "item",
            |m: &UriReplacement| { &m.item },
            |m: &mut UriReplacement| { &mut m.item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_uri",
            |m: &UriReplacement| { &m.new_uri },
            |m: &mut UriReplacement| { &mut m.new_uri },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UriReplacement>(
            "UriReplacement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UriReplacement {
    const NAME: &'static str = "UriReplacement";

    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                26 => {
                    self.new_uri = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.new_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.new_uri.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UriReplacement {
        UriReplacement::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.item.clear();
        self.new_uri = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UriReplacement {
        static instance: UriReplacement = UriReplacement {
            index: ::std::option::Option::None,
            item: ::protobuf::MessageField::none(),
            new_uri: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UriReplacement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UriReplacement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UriReplacement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UriReplacement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.Op)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Op {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Op.kind)
    pub kind: ::std::option::Option<::protobuf::EnumOrUnknown<op::Kind>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Op.add)
    pub add: ::protobuf::MessageField<Add>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Op.rem)
    pub rem: ::protobuf::MessageField<Rem>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Op.mov)
    pub mov: ::protobuf::MessageField<Mov>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Op.update_item_attributes)
    pub update_item_attributes: ::protobuf::MessageField<UpdateItemAttributes>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Op.update_list_attributes)
    pub update_list_attributes: ::protobuf::MessageField<UpdateListAttributes>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Op.update_item_uris)
    pub update_item_uris: ::protobuf::MessageField<UpdateItemUris>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.Op.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Op {
    fn default() -> &'a Op {
        <Op as ::protobuf::Message>::default_instance()
    }
}

impl Op {
    pub fn new() -> Op {
        ::std::default::Default::default()
    }

    // required .spotify.playlist4.proto.Op.Kind kind = 1;

    pub fn kind(&self) -> op::Kind {
        match self.kind {
            Some(e) => e.enum_value_or(op::Kind::KIND_UNKNOWN),
            None => op::Kind::KIND_UNKNOWN,
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: op::Kind) {
        self.kind = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &Op| { &m.kind },
            |m: &mut Op| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Add>(
            "add",
            |m: &Op| { &m.add },
            |m: &mut Op| { &mut m.add },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rem>(
            "rem",
            |m: &Op| { &m.rem },
            |m: &mut Op| { &mut m.rem },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Mov>(
            "mov",
            |m: &Op| { &m.mov },
            |m: &mut Op| { &mut m.mov },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UpdateItemAttributes>(
            "update_item_attributes",
            |m: &Op| { &m.update_item_attributes },
            |m: &mut Op| { &mut m.update_item_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UpdateListAttributes>(
            "update_list_attributes",
            |m: &Op| { &m.update_list_attributes },
            |m: &mut Op| { &mut m.update_list_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UpdateItemUris>(
            "update_item_uris",
            |m: &Op| { &m.update_item_uris },
            |m: &mut Op| { &mut m.update_item_uris },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Op>(
            "Op",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Op {
    const NAME: &'static str = "Op";

    fn is_initialized(&self) -> bool {
        if self.kind.is_none() {
            return false;
        }
        for v in &self.add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mov {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_item_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_list_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_item_uris {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kind = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rem)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mov)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_item_attributes)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_list_attributes)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_item_uris)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.add.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mov.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_item_attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_list_attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_item_uris.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.add.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.rem.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.mov.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.update_item_attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.update_list_attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.update_item_uris.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Op {
        Op::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.add.clear();
        self.rem.clear();
        self.mov.clear();
        self.update_item_attributes.clear();
        self.update_list_attributes.clear();
        self.update_item_uris.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Op {
        static instance: Op = Op {
            kind: ::std::option::Option::None,
            add: ::protobuf::MessageField::none(),
            rem: ::protobuf::MessageField::none(),
            mov: ::protobuf::MessageField::none(),
            update_item_attributes: ::protobuf::MessageField::none(),
            update_list_attributes: ::protobuf::MessageField::none(),
            update_item_uris: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Op {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Op").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Op {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Op`
pub mod op {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.playlist4.proto.Op.Kind)
    pub enum Kind {
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.Op.Kind.KIND_UNKNOWN)
        KIND_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.Op.Kind.ADD)
        ADD = 2,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.Op.Kind.REM)
        REM = 3,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.Op.Kind.MOV)
        MOV = 4,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.Op.Kind.UPDATE_ITEM_ATTRIBUTES)
        UPDATE_ITEM_ATTRIBUTES = 5,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.Op.Kind.UPDATE_LIST_ATTRIBUTES)
        UPDATE_LIST_ATTRIBUTES = 6,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.Op.Kind.UPDATE_ITEM_URIS)
        UPDATE_ITEM_URIS = 7,
    }

    impl ::protobuf::Enum for Kind {
        const NAME: &'static str = "Kind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::KIND_UNKNOWN),
                2 => ::std::option::Option::Some(Kind::ADD),
                3 => ::std::option::Option::Some(Kind::REM),
                4 => ::std::option::Option::Some(Kind::MOV),
                5 => ::std::option::Option::Some(Kind::UPDATE_ITEM_ATTRIBUTES),
                6 => ::std::option::Option::Some(Kind::UPDATE_LIST_ATTRIBUTES),
                7 => ::std::option::Option::Some(Kind::UPDATE_ITEM_URIS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Kind> {
            match str {
                "KIND_UNKNOWN" => ::std::option::Option::Some(Kind::KIND_UNKNOWN),
                "ADD" => ::std::option::Option::Some(Kind::ADD),
                "REM" => ::std::option::Option::Some(Kind::REM),
                "MOV" => ::std::option::Option::Some(Kind::MOV),
                "UPDATE_ITEM_ATTRIBUTES" => ::std::option::Option::Some(Kind::UPDATE_ITEM_ATTRIBUTES),
                "UPDATE_LIST_ATTRIBUTES" => ::std::option::Option::Some(Kind::UPDATE_LIST_ATTRIBUTES),
                "UPDATE_ITEM_URIS" => ::std::option::Option::Some(Kind::UPDATE_ITEM_URIS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Kind] = &[
            Kind::KIND_UNKNOWN,
            Kind::ADD,
            Kind::REM,
            Kind::MOV,
            Kind::UPDATE_ITEM_ATTRIBUTES,
            Kind::UPDATE_LIST_ATTRIBUTES,
            Kind::UPDATE_ITEM_URIS,
        ];
    }

    impl ::protobuf::EnumFull for Kind {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Op.Kind").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Kind::KIND_UNKNOWN => 0,
                Kind::ADD => 1,
                Kind::REM => 2,
                Kind::MOV => 3,
                Kind::UPDATE_ITEM_ATTRIBUTES => 4,
                Kind::UPDATE_LIST_ATTRIBUTES => 5,
                Kind::UPDATE_ITEM_URIS => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::KIND_UNKNOWN
        }
    }

    impl Kind {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Kind>("Op.Kind")
        }
    }
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.OpList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OpList {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.OpList.ops)
    pub ops: ::std::vec::Vec<Op>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.OpList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpList {
    fn default() -> &'a OpList {
        <OpList as ::protobuf::Message>::default_instance()
    }
}

impl OpList {
    pub fn new() -> OpList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ops",
            |m: &OpList| { &m.ops },
            |m: &mut OpList| { &mut m.ops },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpList>(
            "OpList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpList {
    const NAME: &'static str = "OpList";

    fn is_initialized(&self) -> bool {
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ops.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ops {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpList {
        OpList::new()
    }

    fn clear(&mut self) {
        self.ops.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpList {
        static instance: OpList = OpList {
            ops: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ChangeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChangeInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.admin)
    pub admin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.undo)
    pub undo: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.redo)
    pub redo: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.merge)
    pub merge: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.compressed)
    pub compressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.migration)
    pub migration: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.split_id)
    pub split_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ChangeInfo.source)
    pub source: ::protobuf::MessageField<SourceInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ChangeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChangeInfo {
    fn default() -> &'a ChangeInfo {
        <ChangeInfo as ::protobuf::Message>::default_instance()
    }
}

impl ChangeInfo {
    pub fn new() -> ChangeInfo {
        ::std::default::Default::default()
    }

    // optional string user = 1;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool admin = 3;

    pub fn admin(&self) -> bool {
        self.admin.unwrap_or(false)
    }

    pub fn clear_admin(&mut self) {
        self.admin = ::std::option::Option::None;
    }

    pub fn has_admin(&self) -> bool {
        self.admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: bool) {
        self.admin = ::std::option::Option::Some(v);
    }

    // optional bool undo = 4;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }

    // optional bool redo = 5;

    pub fn redo(&self) -> bool {
        self.redo.unwrap_or(false)
    }

    pub fn clear_redo(&mut self) {
        self.redo = ::std::option::Option::None;
    }

    pub fn has_redo(&self) -> bool {
        self.redo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redo(&mut self, v: bool) {
        self.redo = ::std::option::Option::Some(v);
    }

    // optional bool merge = 6;

    pub fn merge(&self) -> bool {
        self.merge.unwrap_or(false)
    }

    pub fn clear_merge(&mut self) {
        self.merge = ::std::option::Option::None;
    }

    pub fn has_merge(&self) -> bool {
        self.merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge(&mut self, v: bool) {
        self.merge = ::std::option::Option::Some(v);
    }

    // optional bool compressed = 7;

    pub fn compressed(&self) -> bool {
        self.compressed.unwrap_or(false)
    }

    pub fn clear_compressed(&mut self) {
        self.compressed = ::std::option::Option::None;
    }

    pub fn has_compressed(&self) -> bool {
        self.compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed(&mut self, v: bool) {
        self.compressed = ::std::option::Option::Some(v);
    }

    // optional bool migration = 8;

    pub fn migration(&self) -> bool {
        self.migration.unwrap_or(false)
    }

    pub fn clear_migration(&mut self) {
        self.migration = ::std::option::Option::None;
    }

    pub fn has_migration(&self) -> bool {
        self.migration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migration(&mut self, v: bool) {
        self.migration = ::std::option::Option::Some(v);
    }

    // optional int32 split_id = 9;

    pub fn split_id(&self) -> i32 {
        self.split_id.unwrap_or(0)
    }

    pub fn clear_split_id(&mut self) {
        self.split_id = ::std::option::Option::None;
    }

    pub fn has_split_id(&self) -> bool {
        self.split_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_id(&mut self, v: i32) {
        self.split_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &ChangeInfo| { &m.user },
            |m: &mut ChangeInfo| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ChangeInfo| { &m.timestamp },
            |m: &mut ChangeInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "admin",
            |m: &ChangeInfo| { &m.admin },
            |m: &mut ChangeInfo| { &mut m.admin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "undo",
            |m: &ChangeInfo| { &m.undo },
            |m: &mut ChangeInfo| { &mut m.undo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redo",
            |m: &ChangeInfo| { &m.redo },
            |m: &mut ChangeInfo| { &mut m.redo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "merge",
            |m: &ChangeInfo| { &m.merge },
            |m: &mut ChangeInfo| { &mut m.merge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "compressed",
            |m: &ChangeInfo| { &m.compressed },
            |m: &mut ChangeInfo| { &mut m.compressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "migration",
            |m: &ChangeInfo| { &m.migration },
            |m: &mut ChangeInfo| { &mut m.migration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "split_id",
            |m: &ChangeInfo| { &m.split_id },
            |m: &mut ChangeInfo| { &mut m.split_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SourceInfo>(
            "source",
            |m: &ChangeInfo| { &m.source },
            |m: &mut ChangeInfo| { &mut m.source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangeInfo>(
            "ChangeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChangeInfo {
    const NAME: &'static str = "ChangeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.admin = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.redo = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.merge = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.compressed = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.migration = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.split_id = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.admin {
            my_size += 1 + 1;
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        if let Some(v) = self.redo {
            my_size += 1 + 1;
        }
        if let Some(v) = self.merge {
            my_size += 1 + 1;
        }
        if let Some(v) = self.compressed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.migration {
            my_size += 1 + 1;
        }
        if let Some(v) = self.split_id {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.admin {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.redo {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.merge {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.compressed {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.migration {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.split_id {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChangeInfo {
        ChangeInfo::new()
    }

    fn clear(&mut self) {
        self.user = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.admin = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.redo = ::std::option::Option::None;
        self.merge = ::std::option::Option::None;
        self.compressed = ::std::option::Option::None;
        self.migration = ::std::option::Option::None;
        self.split_id = ::std::option::Option::None;
        self.source.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChangeInfo {
        static instance: ChangeInfo = ChangeInfo {
            user: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            admin: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            redo: ::std::option::Option::None,
            merge: ::std::option::Option::None,
            compressed: ::std::option::Option::None,
            migration: ::std::option::Option::None,
            split_id: ::std::option::Option::None,
            source: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChangeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChangeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChangeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.SourceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourceInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SourceInfo.client)
    pub client: ::std::option::Option<::protobuf::EnumOrUnknown<source_info::Client>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SourceInfo.app)
    pub app: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SourceInfo.source)
    pub source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SourceInfo.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SourceInfo.server_domain)
    pub server_domain: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.SourceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceInfo {
    fn default() -> &'a SourceInfo {
        <SourceInfo as ::protobuf::Message>::default_instance()
    }
}

impl SourceInfo {
    pub fn new() -> SourceInfo {
        ::std::default::Default::default()
    }

    // optional .spotify.playlist4.proto.SourceInfo.Client client = 1;

    pub fn client(&self) -> source_info::Client {
        match self.client {
            Some(e) => e.enum_value_or(source_info::Client::CLIENT_UNKNOWN),
            None => source_info::Client::CLIENT_UNKNOWN,
        }
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: source_info::Client) {
        self.client = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string app = 3;

    pub fn app(&self) -> &str {
        match self.app.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_app(&mut self) {
        self.app = ::std::option::Option::None;
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: ::std::string::String) {
        self.app = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut ::std::string::String {
        if self.app.is_none() {
            self.app = ::std::option::Option::Some(::std::string::String::new());
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> ::std::string::String {
        self.app.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source = 4;

    pub fn source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 5;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_domain = 6;

    pub fn server_domain(&self) -> &str {
        match self.server_domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_domain(&mut self) {
        self.server_domain = ::std::option::Option::None;
    }

    pub fn has_server_domain(&self) -> bool {
        self.server_domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_domain(&mut self, v: ::std::string::String) {
        self.server_domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_domain(&mut self) -> &mut ::std::string::String {
        if self.server_domain.is_none() {
            self.server_domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_domain(&mut self) -> ::std::string::String {
        self.server_domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client",
            |m: &SourceInfo| { &m.client },
            |m: &mut SourceInfo| { &mut m.client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app",
            |m: &SourceInfo| { &m.app },
            |m: &mut SourceInfo| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &SourceInfo| { &m.source },
            |m: &mut SourceInfo| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &SourceInfo| { &m.version },
            |m: &mut SourceInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_domain",
            |m: &SourceInfo| { &m.server_domain },
            |m: &mut SourceInfo| { &mut m.server_domain },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SourceInfo>(
            "SourceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SourceInfo {
    const NAME: &'static str = "SourceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.app = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.source = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.server_domain = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.app.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.server_domain.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.app.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.server_domain.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceInfo {
        SourceInfo::new()
    }

    fn clear(&mut self) {
        self.client = ::std::option::Option::None;
        self.app = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.server_domain = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceInfo {
        static instance: SourceInfo = SourceInfo {
            client: ::std::option::Option::None,
            app: ::std::option::Option::None,
            source: ::std::option::Option::None,
            version: ::std::option::Option::None,
            server_domain: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SourceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SourceInfo`
pub mod source_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.playlist4.proto.SourceInfo.Client)
    pub enum Client {
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.SourceInfo.Client.CLIENT_UNKNOWN)
        CLIENT_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.SourceInfo.Client.NATIVE_HERMES)
        NATIVE_HERMES = 1,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.SourceInfo.Client.CLIENT)
        CLIENT = 2,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.SourceInfo.Client.PYTHON)
        PYTHON = 3,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.SourceInfo.Client.JAVA)
        JAVA = 4,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.SourceInfo.Client.WEBPLAYER)
        WEBPLAYER = 5,
        // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.SourceInfo.Client.LIBSPOTIFY)
        LIBSPOTIFY = 6,
    }

    impl ::protobuf::Enum for Client {
        const NAME: &'static str = "Client";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Client> {
            match value {
                0 => ::std::option::Option::Some(Client::CLIENT_UNKNOWN),
                1 => ::std::option::Option::Some(Client::NATIVE_HERMES),
                2 => ::std::option::Option::Some(Client::CLIENT),
                3 => ::std::option::Option::Some(Client::PYTHON),
                4 => ::std::option::Option::Some(Client::JAVA),
                5 => ::std::option::Option::Some(Client::WEBPLAYER),
                6 => ::std::option::Option::Some(Client::LIBSPOTIFY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Client> {
            match str {
                "CLIENT_UNKNOWN" => ::std::option::Option::Some(Client::CLIENT_UNKNOWN),
                "NATIVE_HERMES" => ::std::option::Option::Some(Client::NATIVE_HERMES),
                "CLIENT" => ::std::option::Option::Some(Client::CLIENT),
                "PYTHON" => ::std::option::Option::Some(Client::PYTHON),
                "JAVA" => ::std::option::Option::Some(Client::JAVA),
                "WEBPLAYER" => ::std::option::Option::Some(Client::WEBPLAYER),
                "LIBSPOTIFY" => ::std::option::Option::Some(Client::LIBSPOTIFY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Client] = &[
            Client::CLIENT_UNKNOWN,
            Client::NATIVE_HERMES,
            Client::CLIENT,
            Client::PYTHON,
            Client::JAVA,
            Client::WEBPLAYER,
            Client::LIBSPOTIFY,
        ];
    }

    impl ::protobuf::EnumFull for Client {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SourceInfo.Client").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Client {
        fn default() -> Self {
            Client::CLIENT_UNKNOWN
        }
    }

    impl Client {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Client>("SourceInfo.Client")
        }
    }
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.Delta)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Delta {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Delta.base_version)
    pub base_version: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Delta.ops)
    pub ops: ::std::vec::Vec<Op>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Delta.info)
    pub info: ::protobuf::MessageField<ChangeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.Delta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Delta {
    fn default() -> &'a Delta {
        <Delta as ::protobuf::Message>::default_instance()
    }
}

impl Delta {
    pub fn new() -> Delta {
        ::std::default::Default::default()
    }

    // optional bytes base_version = 1;

    pub fn base_version(&self) -> &[u8] {
        match self.base_version.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_base_version(&mut self) {
        self.base_version = ::std::option::Option::None;
    }

    pub fn has_base_version(&self) -> bool {
        self.base_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.base_version.is_none() {
            self.base_version = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.base_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_version(&mut self) -> ::std::vec::Vec<u8> {
        self.base_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_version",
            |m: &Delta| { &m.base_version },
            |m: &mut Delta| { &mut m.base_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ops",
            |m: &Delta| { &m.ops },
            |m: &mut Delta| { &mut m.ops },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ChangeInfo>(
            "info",
            |m: &Delta| { &m.info },
            |m: &mut Delta| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Delta>(
            "Delta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Delta {
    const NAME: &'static str = "Delta";

    fn is_initialized(&self) -> bool {
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.base_version = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.ops.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_version.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.ops {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Delta {
        Delta::new()
    }

    fn clear(&mut self) {
        self.base_version = ::std::option::Option::None;
        self.ops.clear();
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Delta {
        static instance: Delta = Delta {
            base_version: ::std::option::Option::None,
            ops: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Delta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Delta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Delta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Delta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.Diff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Diff {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Diff.from_revision)
    pub from_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Diff.ops)
    pub ops: ::std::vec::Vec<Op>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.Diff.to_revision)
    pub to_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.Diff.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Diff {
    fn default() -> &'a Diff {
        <Diff as ::protobuf::Message>::default_instance()
    }
}

impl Diff {
    pub fn new() -> Diff {
        ::std::default::Default::default()
    }

    // required bytes from_revision = 1;

    pub fn from_revision(&self) -> &[u8] {
        match self.from_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_from_revision(&mut self) {
        self.from_revision = ::std::option::Option::None;
    }

    pub fn has_from_revision(&self) -> bool {
        self.from_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.from_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.from_revision.is_none() {
            self.from_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.from_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.from_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes to_revision = 3;

    pub fn to_revision(&self) -> &[u8] {
        match self.to_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_to_revision(&mut self) {
        self.to_revision = ::std::option::Option::None;
    }

    pub fn has_to_revision(&self) -> bool {
        self.to_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.to_revision.is_none() {
            self.to_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.to_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.to_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_revision",
            |m: &Diff| { &m.from_revision },
            |m: &mut Diff| { &mut m.from_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ops",
            |m: &Diff| { &m.ops },
            |m: &mut Diff| { &mut m.ops },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_revision",
            |m: &Diff| { &m.to_revision },
            |m: &mut Diff| { &mut m.to_revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Diff>(
            "Diff",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Diff {
    const NAME: &'static str = "Diff";

    fn is_initialized(&self) -> bool {
        if self.from_revision.is_none() {
            return false;
        }
        if self.to_revision.is_none() {
            return false;
        }
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.from_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.ops.push(is.read_message()?);
                },
                26 => {
                    self.to_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.from_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.to_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.from_revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.ops {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.to_revision.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Diff {
        Diff::new()
    }

    fn clear(&mut self) {
        self.from_revision = ::std::option::Option::None;
        self.ops.clear();
        self.to_revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Diff {
        static instance: Diff = Diff {
            from_revision: ::std::option::Option::None,
            ops: ::std::vec::Vec::new(),
            to_revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Diff {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Diff").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Diff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Diff {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ListChanges)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListChanges {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListChanges.base_revision)
    pub base_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListChanges.deltas)
    pub deltas: ::std::vec::Vec<Delta>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListChanges.want_resulting_revisions)
    pub want_resulting_revisions: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListChanges.want_sync_result)
    pub want_sync_result: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListChanges.nonces)
    pub nonces: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ListChanges.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListChanges {
    fn default() -> &'a ListChanges {
        <ListChanges as ::protobuf::Message>::default_instance()
    }
}

impl ListChanges {
    pub fn new() -> ListChanges {
        ::std::default::Default::default()
    }

    // optional bytes base_revision = 1;

    pub fn base_revision(&self) -> &[u8] {
        match self.base_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_base_revision(&mut self) {
        self.base_revision = ::std::option::Option::None;
    }

    pub fn has_base_revision(&self) -> bool {
        self.base_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.base_revision.is_none() {
            self.base_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.base_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.base_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool want_resulting_revisions = 3;

    pub fn want_resulting_revisions(&self) -> bool {
        self.want_resulting_revisions.unwrap_or(false)
    }

    pub fn clear_want_resulting_revisions(&mut self) {
        self.want_resulting_revisions = ::std::option::Option::None;
    }

    pub fn has_want_resulting_revisions(&self) -> bool {
        self.want_resulting_revisions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_want_resulting_revisions(&mut self, v: bool) {
        self.want_resulting_revisions = ::std::option::Option::Some(v);
    }

    // optional bool want_sync_result = 4;

    pub fn want_sync_result(&self) -> bool {
        self.want_sync_result.unwrap_or(false)
    }

    pub fn clear_want_sync_result(&mut self) {
        self.want_sync_result = ::std::option::Option::None;
    }

    pub fn has_want_sync_result(&self) -> bool {
        self.want_sync_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_want_sync_result(&mut self, v: bool) {
        self.want_sync_result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_revision",
            |m: &ListChanges| { &m.base_revision },
            |m: &mut ListChanges| { &mut m.base_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deltas",
            |m: &ListChanges| { &m.deltas },
            |m: &mut ListChanges| { &mut m.deltas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "want_resulting_revisions",
            |m: &ListChanges| { &m.want_resulting_revisions },
            |m: &mut ListChanges| { &mut m.want_resulting_revisions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "want_sync_result",
            |m: &ListChanges| { &m.want_sync_result },
            |m: &mut ListChanges| { &mut m.want_sync_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonces",
            |m: &ListChanges| { &m.nonces },
            |m: &mut ListChanges| { &mut m.nonces },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListChanges>(
            "ListChanges",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListChanges {
    const NAME: &'static str = "ListChanges";

    fn is_initialized(&self) -> bool {
        for v in &self.deltas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.base_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.deltas.push(is.read_message()?);
                },
                24 => {
                    self.want_resulting_revisions = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.want_sync_result = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    is.read_repeated_packed_int64_into(&mut self.nonces)?;
                },
                48 => {
                    self.nonces.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.deltas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.want_resulting_revisions {
            my_size += 1 + 1;
        }
        if let Some(v) = self.want_sync_result {
            my_size += 1 + 1;
        }
        for value in &self.nonces {
            my_size += ::protobuf::rt::int64_size(6, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.deltas {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.want_resulting_revisions {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.want_sync_result {
            os.write_bool(4, v)?;
        }
        for v in &self.nonces {
            os.write_int64(6, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListChanges {
        ListChanges::new()
    }

    fn clear(&mut self) {
        self.base_revision = ::std::option::Option::None;
        self.deltas.clear();
        self.want_resulting_revisions = ::std::option::Option::None;
        self.want_sync_result = ::std::option::Option::None;
        self.nonces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListChanges {
        static instance: ListChanges = ListChanges {
            base_revision: ::std::option::Option::None,
            deltas: ::std::vec::Vec::new(),
            want_resulting_revisions: ::std::option::Option::None,
            want_sync_result: ::std::option::Option::None,
            nonces: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListChanges {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListChanges").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListChanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChanges {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ListSignals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSignals {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListSignals.base_revision)
    pub base_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListSignals.emitted_signals)
    pub emitted_signals: ::std::vec::Vec<super::signal_model::Signal>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ListSignals.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSignals {
    fn default() -> &'a ListSignals {
        <ListSignals as ::protobuf::Message>::default_instance()
    }
}

impl ListSignals {
    pub fn new() -> ListSignals {
        ::std::default::Default::default()
    }

    // optional bytes base_revision = 1;

    pub fn base_revision(&self) -> &[u8] {
        match self.base_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_base_revision(&mut self) {
        self.base_revision = ::std::option::Option::None;
    }

    pub fn has_base_revision(&self) -> bool {
        self.base_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.base_revision.is_none() {
            self.base_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.base_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.base_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_revision",
            |m: &ListSignals| { &m.base_revision },
            |m: &mut ListSignals| { &mut m.base_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "emitted_signals",
            |m: &ListSignals| { &m.emitted_signals },
            |m: &mut ListSignals| { &mut m.emitted_signals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSignals>(
            "ListSignals",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSignals {
    const NAME: &'static str = "ListSignals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.base_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.emitted_signals.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        for value in &self.emitted_signals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.emitted_signals {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSignals {
        ListSignals::new()
    }

    fn clear(&mut self) {
        self.base_revision = ::std::option::Option::None;
        self.emitted_signals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSignals {
        static instance: ListSignals = ListSignals {
            base_revision: ::std::option::Option::None,
            emitted_signals: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSignals {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSignals").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSignals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSignals {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.SelectedListContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectedListContent {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.revision)
    pub revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.length)
    pub length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.attributes)
    pub attributes: ::protobuf::MessageField<ListAttributes>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.contents)
    pub contents: ::protobuf::MessageField<ListItems>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.diff)
    pub diff: ::protobuf::MessageField<Diff>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.sync_result)
    pub sync_result: ::protobuf::MessageField<Diff>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.resulting_revisions)
    pub resulting_revisions: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.multiple_heads)
    pub multiple_heads: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.up_to_date)
    pub up_to_date: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.nonces)
    pub nonces: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.owner_username)
    pub owner_username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.abuse_reporting_enabled)
    pub abuse_reporting_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.capabilities)
    pub capabilities: ::protobuf::MessageField<super::playlist_permission::Capabilities>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.geoblock)
    pub geoblock: ::std::vec::Vec<::protobuf::EnumOrUnknown<GeoblockBlockingType>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.changes_require_resync)
    pub changes_require_resync: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.created_at)
    pub created_at: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SelectedListContent.applied_lenses)
    pub applied_lenses: ::protobuf::MessageField<AppliedLenses>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.SelectedListContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectedListContent {
    fn default() -> &'a SelectedListContent {
        <SelectedListContent as ::protobuf::Message>::default_instance()
    }
}

impl SelectedListContent {
    pub fn new() -> SelectedListContent {
        ::std::default::Default::default()
    }

    // optional bytes revision = 1;

    pub fn revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 length = 2;

    pub fn length(&self) -> i32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional bool multiple_heads = 9;

    pub fn multiple_heads(&self) -> bool {
        self.multiple_heads.unwrap_or(false)
    }

    pub fn clear_multiple_heads(&mut self) {
        self.multiple_heads = ::std::option::Option::None;
    }

    pub fn has_multiple_heads(&self) -> bool {
        self.multiple_heads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multiple_heads(&mut self, v: bool) {
        self.multiple_heads = ::std::option::Option::Some(v);
    }

    // optional bool up_to_date = 10;

    pub fn up_to_date(&self) -> bool {
        self.up_to_date.unwrap_or(false)
    }

    pub fn clear_up_to_date(&mut self) {
        self.up_to_date = ::std::option::Option::None;
    }

    pub fn has_up_to_date(&self) -> bool {
        self.up_to_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up_to_date(&mut self, v: bool) {
        self.up_to_date = ::std::option::Option::Some(v);
    }

    // optional int64 timestamp = 15;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string owner_username = 16;

    pub fn owner_username(&self) -> &str {
        match self.owner_username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_owner_username(&mut self) {
        self.owner_username = ::std::option::Option::None;
    }

    pub fn has_owner_username(&self) -> bool {
        self.owner_username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_username(&mut self, v: ::std::string::String) {
        self.owner_username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_username(&mut self) -> &mut ::std::string::String {
        if self.owner_username.is_none() {
            self.owner_username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.owner_username.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_username(&mut self) -> ::std::string::String {
        self.owner_username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool abuse_reporting_enabled = 17;

    pub fn abuse_reporting_enabled(&self) -> bool {
        self.abuse_reporting_enabled.unwrap_or(false)
    }

    pub fn clear_abuse_reporting_enabled(&mut self) {
        self.abuse_reporting_enabled = ::std::option::Option::None;
    }

    pub fn has_abuse_reporting_enabled(&self) -> bool {
        self.abuse_reporting_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abuse_reporting_enabled(&mut self, v: bool) {
        self.abuse_reporting_enabled = ::std::option::Option::Some(v);
    }

    // optional bool changes_require_resync = 20;

    pub fn changes_require_resync(&self) -> bool {
        self.changes_require_resync.unwrap_or(false)
    }

    pub fn clear_changes_require_resync(&mut self) {
        self.changes_require_resync = ::std::option::Option::None;
    }

    pub fn has_changes_require_resync(&self) -> bool {
        self.changes_require_resync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changes_require_resync(&mut self, v: bool) {
        self.changes_require_resync = ::std::option::Option::Some(v);
    }

    // optional int64 created_at = 21;

    pub fn created_at(&self) -> i64 {
        self.created_at.unwrap_or(0)
    }

    pub fn clear_created_at(&mut self) {
        self.created_at = ::std::option::Option::None;
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &SelectedListContent| { &m.revision },
            |m: &mut SelectedListContent| { &mut m.revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &SelectedListContent| { &m.length },
            |m: &mut SelectedListContent| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListAttributes>(
            "attributes",
            |m: &SelectedListContent| { &m.attributes },
            |m: &mut SelectedListContent| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListItems>(
            "contents",
            |m: &SelectedListContent| { &m.contents },
            |m: &mut SelectedListContent| { &mut m.contents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Diff>(
            "diff",
            |m: &SelectedListContent| { &m.diff },
            |m: &mut SelectedListContent| { &mut m.diff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Diff>(
            "sync_result",
            |m: &SelectedListContent| { &m.sync_result },
            |m: &mut SelectedListContent| { &mut m.sync_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resulting_revisions",
            |m: &SelectedListContent| { &m.resulting_revisions },
            |m: &mut SelectedListContent| { &mut m.resulting_revisions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multiple_heads",
            |m: &SelectedListContent| { &m.multiple_heads },
            |m: &mut SelectedListContent| { &mut m.multiple_heads },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "up_to_date",
            |m: &SelectedListContent| { &m.up_to_date },
            |m: &mut SelectedListContent| { &mut m.up_to_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonces",
            |m: &SelectedListContent| { &m.nonces },
            |m: &mut SelectedListContent| { &mut m.nonces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &SelectedListContent| { &m.timestamp },
            |m: &mut SelectedListContent| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_username",
            |m: &SelectedListContent| { &m.owner_username },
            |m: &mut SelectedListContent| { &mut m.owner_username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abuse_reporting_enabled",
            |m: &SelectedListContent| { &m.abuse_reporting_enabled },
            |m: &mut SelectedListContent| { &mut m.abuse_reporting_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::playlist_permission::Capabilities>(
            "capabilities",
            |m: &SelectedListContent| { &m.capabilities },
            |m: &mut SelectedListContent| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "geoblock",
            |m: &SelectedListContent| { &m.geoblock },
            |m: &mut SelectedListContent| { &mut m.geoblock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "changes_require_resync",
            |m: &SelectedListContent| { &m.changes_require_resync },
            |m: &mut SelectedListContent| { &mut m.changes_require_resync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "created_at",
            |m: &SelectedListContent| { &m.created_at },
            |m: &mut SelectedListContent| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppliedLenses>(
            "applied_lenses",
            |m: &SelectedListContent| { &m.applied_lenses },
            |m: &mut SelectedListContent| { &mut m.applied_lenses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectedListContent>(
            "SelectedListContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectedListContent {
    const NAME: &'static str = "SelectedListContent";

    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contents {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.diff {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sync_result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.applied_lenses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.length = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attributes)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contents)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.diff)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sync_result)?;
                },
                66 => {
                    self.resulting_revisions.push(is.read_bytes()?);
                },
                72 => {
                    self.multiple_heads = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.up_to_date = ::std::option::Option::Some(is.read_bool()?);
                },
                114 => {
                    is.read_repeated_packed_int64_into(&mut self.nonces)?;
                },
                112 => {
                    self.nonces.push(is.read_int64()?);
                },
                120 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                130 => {
                    self.owner_username = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.abuse_reporting_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                152 => {
                    self.geoblock.push(is.read_enum_or_unknown()?);
                },
                154 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.geoblock)?
                },
                160 => {
                    self.changes_require_resync = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.created_at = ::std::option::Option::Some(is.read_int64()?);
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.applied_lenses)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contents.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.diff.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sync_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.resulting_revisions {
            my_size += ::protobuf::rt::bytes_size(8, &value);
        };
        if let Some(v) = self.multiple_heads {
            my_size += 1 + 1;
        }
        if let Some(v) = self.up_to_date {
            my_size += 1 + 1;
        }
        for value in &self.nonces {
            my_size += ::protobuf::rt::int64_size(14, *value);
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(15, v);
        }
        if let Some(v) = self.owner_username.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.abuse_reporting_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.geoblock {
            my_size += ::protobuf::rt::int32_size(19, value.value());
        };
        if let Some(v) = self.changes_require_resync {
            my_size += 2 + 1;
        }
        if let Some(v) = self.created_at {
            my_size += ::protobuf::rt::int64_size(21, v);
        }
        if let Some(v) = self.applied_lenses.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.contents.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.diff.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.sync_result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.resulting_revisions {
            os.write_bytes(8, &v)?;
        };
        if let Some(v) = self.multiple_heads {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.up_to_date {
            os.write_bool(10, v)?;
        }
        for v in &self.nonces {
            os.write_int64(14, *v)?;
        };
        if let Some(v) = self.timestamp {
            os.write_int64(15, v)?;
        }
        if let Some(v) = self.owner_username.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.abuse_reporting_enabled {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        for v in &self.geoblock {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.changes_require_resync {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.created_at {
            os.write_int64(21, v)?;
        }
        if let Some(v) = self.applied_lenses.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectedListContent {
        SelectedListContent::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.attributes.clear();
        self.contents.clear();
        self.diff.clear();
        self.sync_result.clear();
        self.resulting_revisions.clear();
        self.multiple_heads = ::std::option::Option::None;
        self.up_to_date = ::std::option::Option::None;
        self.nonces.clear();
        self.timestamp = ::std::option::Option::None;
        self.owner_username = ::std::option::Option::None;
        self.abuse_reporting_enabled = ::std::option::Option::None;
        self.capabilities.clear();
        self.geoblock.clear();
        self.changes_require_resync = ::std::option::Option::None;
        self.created_at = ::std::option::Option::None;
        self.applied_lenses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectedListContent {
        static instance: SelectedListContent = SelectedListContent {
            revision: ::std::option::Option::None,
            length: ::std::option::Option::None,
            attributes: ::protobuf::MessageField::none(),
            contents: ::protobuf::MessageField::none(),
            diff: ::protobuf::MessageField::none(),
            sync_result: ::protobuf::MessageField::none(),
            resulting_revisions: ::std::vec::Vec::new(),
            multiple_heads: ::std::option::Option::None,
            up_to_date: ::std::option::Option::None,
            nonces: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            owner_username: ::std::option::Option::None,
            abuse_reporting_enabled: ::std::option::Option::None,
            capabilities: ::protobuf::MessageField::none(),
            geoblock: ::std::vec::Vec::new(),
            changes_require_resync: ::std::option::Option::None,
            created_at: ::std::option::Option::None,
            applied_lenses: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectedListContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectedListContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectedListContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectedListContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.AppliedLenses)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppliedLenses {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.AppliedLenses.states)
    pub states: ::std::vec::Vec<super::lens_model::LensState>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.AppliedLenses.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppliedLenses {
    fn default() -> &'a AppliedLenses {
        <AppliedLenses as ::protobuf::Message>::default_instance()
    }
}

impl AppliedLenses {
    pub fn new() -> AppliedLenses {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "states",
            |m: &AppliedLenses| { &m.states },
            |m: &mut AppliedLenses| { &mut m.states },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppliedLenses>(
            "AppliedLenses",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppliedLenses {
    const NAME: &'static str = "AppliedLenses";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.states.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.states {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppliedLenses {
        AppliedLenses::new()
    }

    fn clear(&mut self) {
        self.states.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppliedLenses {
        static instance: AppliedLenses = AppliedLenses {
            states: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppliedLenses {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppliedLenses").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppliedLenses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppliedLenses {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.CreateListReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateListReply {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.CreateListReply.uri)
    pub uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.CreateListReply.revision)
    pub revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.CreateListReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateListReply {
    fn default() -> &'a CreateListReply {
        <CreateListReply as ::protobuf::Message>::default_instance()
    }
}

impl CreateListReply {
    pub fn new() -> CreateListReply {
        ::std::default::Default::default()
    }

    // required string uri = 1;

    pub fn uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        self.uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes revision = 2;

    pub fn revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &CreateListReply| { &m.uri },
            |m: &mut CreateListReply| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CreateListReply| { &m.revision },
            |m: &mut CreateListReply| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateListReply>(
            "CreateListReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateListReply {
    const NAME: &'static str = "CreateListReply";

    fn is_initialized(&self) -> bool {
        if self.uri.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uri.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.revision.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateListReply {
        CreateListReply::new()
    }

    fn clear(&mut self) {
        self.uri = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateListReply {
        static instance: CreateListReply = CreateListReply {
            uri: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateListReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateListReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateListReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateListReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.PlaylistV1UriRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlaylistV1UriRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PlaylistV1UriRequest.v2_uris)
    pub v2_uris: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.PlaylistV1UriRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlaylistV1UriRequest {
    fn default() -> &'a PlaylistV1UriRequest {
        <PlaylistV1UriRequest as ::protobuf::Message>::default_instance()
    }
}

impl PlaylistV1UriRequest {
    pub fn new() -> PlaylistV1UriRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "v2_uris",
            |m: &PlaylistV1UriRequest| { &m.v2_uris },
            |m: &mut PlaylistV1UriRequest| { &mut m.v2_uris },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlaylistV1UriRequest>(
            "PlaylistV1UriRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlaylistV1UriRequest {
    const NAME: &'static str = "PlaylistV1UriRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.v2_uris.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.v2_uris {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.v2_uris {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlaylistV1UriRequest {
        PlaylistV1UriRequest::new()
    }

    fn clear(&mut self) {
        self.v2_uris.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlaylistV1UriRequest {
        static instance: PlaylistV1UriRequest = PlaylistV1UriRequest {
            v2_uris: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlaylistV1UriRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlaylistV1UriRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlaylistV1UriRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaylistV1UriRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.PlaylistV1UriReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlaylistV1UriReply {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PlaylistV1UriReply.v2_uri_to_v1_uri)
    pub v2_uri_to_v1_uri: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.PlaylistV1UriReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlaylistV1UriReply {
    fn default() -> &'a PlaylistV1UriReply {
        <PlaylistV1UriReply as ::protobuf::Message>::default_instance()
    }
}

impl PlaylistV1UriReply {
    pub fn new() -> PlaylistV1UriReply {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "v2_uri_to_v1_uri",
            |m: &PlaylistV1UriReply| { &m.v2_uri_to_v1_uri },
            |m: &mut PlaylistV1UriReply| { &mut m.v2_uri_to_v1_uri },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlaylistV1UriReply>(
            "PlaylistV1UriReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlaylistV1UriReply {
    const NAME: &'static str = "PlaylistV1UriReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.v2_uri_to_v1_uri.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.v2_uri_to_v1_uri {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.v2_uri_to_v1_uri {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlaylistV1UriReply {
        PlaylistV1UriReply::new()
    }

    fn clear(&mut self) {
        self.v2_uri_to_v1_uri.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlaylistV1UriReply {
        static instance: ::protobuf::rt::Lazy<PlaylistV1UriReply> = ::protobuf::rt::Lazy::new();
        instance.get(PlaylistV1UriReply::new)
    }
}

impl ::protobuf::MessageFull for PlaylistV1UriReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlaylistV1UriReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlaylistV1UriReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaylistV1UriReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ListUpdateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListUpdateRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListUpdateRequest.base_revision)
    pub base_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListUpdateRequest.attributes)
    pub attributes: ::protobuf::MessageField<ListAttributes>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListUpdateRequest.items)
    pub items: ::std::vec::Vec<Item>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ListUpdateRequest.info)
    pub info: ::protobuf::MessageField<ChangeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ListUpdateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListUpdateRequest {
    fn default() -> &'a ListUpdateRequest {
        <ListUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUpdateRequest {
    pub fn new() -> ListUpdateRequest {
        ::std::default::Default::default()
    }

    // optional bytes base_revision = 1;

    pub fn base_revision(&self) -> &[u8] {
        match self.base_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_base_revision(&mut self) {
        self.base_revision = ::std::option::Option::None;
    }

    pub fn has_base_revision(&self) -> bool {
        self.base_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.base_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.base_revision.is_none() {
            self.base_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.base_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.base_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_revision",
            |m: &ListUpdateRequest| { &m.base_revision },
            |m: &mut ListUpdateRequest| { &mut m.base_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListAttributes>(
            "attributes",
            |m: &ListUpdateRequest| { &m.attributes },
            |m: &mut ListUpdateRequest| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ListUpdateRequest| { &m.items },
            |m: &mut ListUpdateRequest| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ChangeInfo>(
            "info",
            |m: &ListUpdateRequest| { &m.info },
            |m: &mut ListUpdateRequest| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListUpdateRequest>(
            "ListUpdateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListUpdateRequest {
    const NAME: &'static str = "ListUpdateRequest";

    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.base_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attributes)?;
                },
                26 => {
                    self.items.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListUpdateRequest {
        ListUpdateRequest::new()
    }

    fn clear(&mut self) {
        self.base_revision = ::std::option::Option::None;
        self.attributes.clear();
        self.items.clear();
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListUpdateRequest {
        static instance: ListUpdateRequest = ListUpdateRequest {
            base_revision: ::std::option::Option::None,
            attributes: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListUpdateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListUpdateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUpdateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.RegisterPlaylistImageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RegisterPlaylistImageRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.RegisterPlaylistImageRequest.upload_token)
    pub upload_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.RegisterPlaylistImageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterPlaylistImageRequest {
    fn default() -> &'a RegisterPlaylistImageRequest {
        <RegisterPlaylistImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterPlaylistImageRequest {
    pub fn new() -> RegisterPlaylistImageRequest {
        ::std::default::Default::default()
    }

    // optional string upload_token = 1;

    pub fn upload_token(&self) -> &str {
        match self.upload_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_upload_token(&mut self) {
        self.upload_token = ::std::option::Option::None;
    }

    pub fn has_upload_token(&self) -> bool {
        self.upload_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_token(&mut self, v: ::std::string::String) {
        self.upload_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_token(&mut self) -> &mut ::std::string::String {
        if self.upload_token.is_none() {
            self.upload_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.upload_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_upload_token(&mut self) -> ::std::string::String {
        self.upload_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_token",
            |m: &RegisterPlaylistImageRequest| { &m.upload_token },
            |m: &mut RegisterPlaylistImageRequest| { &mut m.upload_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterPlaylistImageRequest>(
            "RegisterPlaylistImageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterPlaylistImageRequest {
    const NAME: &'static str = "RegisterPlaylistImageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upload_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upload_token.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterPlaylistImageRequest {
        RegisterPlaylistImageRequest::new()
    }

    fn clear(&mut self) {
        self.upload_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterPlaylistImageRequest {
        static instance: RegisterPlaylistImageRequest = RegisterPlaylistImageRequest {
            upload_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterPlaylistImageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterPlaylistImageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterPlaylistImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterPlaylistImageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.RegisterPlaylistImageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RegisterPlaylistImageResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.RegisterPlaylistImageResponse.picture)
    pub picture: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.RegisterPlaylistImageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterPlaylistImageResponse {
    fn default() -> &'a RegisterPlaylistImageResponse {
        <RegisterPlaylistImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterPlaylistImageResponse {
    pub fn new() -> RegisterPlaylistImageResponse {
        ::std::default::Default::default()
    }

    // optional bytes picture = 1;

    pub fn picture(&self) -> &[u8] {
        match self.picture.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_picture(&mut self) {
        self.picture = ::std::option::Option::None;
    }

    pub fn has_picture(&self) -> bool {
        self.picture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picture(&mut self, v: ::std::vec::Vec<u8>) {
        self.picture = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_picture(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.picture.is_none() {
            self.picture = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.picture.as_mut().unwrap()
    }

    // Take field
    pub fn take_picture(&mut self) -> ::std::vec::Vec<u8> {
        self.picture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "picture",
            |m: &RegisterPlaylistImageResponse| { &m.picture },
            |m: &mut RegisterPlaylistImageResponse| { &mut m.picture },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterPlaylistImageResponse>(
            "RegisterPlaylistImageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterPlaylistImageResponse {
    const NAME: &'static str = "RegisterPlaylistImageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.picture = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.picture.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.picture.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterPlaylistImageResponse {
        RegisterPlaylistImageResponse::new()
    }

    fn clear(&mut self) {
        self.picture = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterPlaylistImageResponse {
        static instance: RegisterPlaylistImageResponse = RegisterPlaylistImageResponse {
            picture: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterPlaylistImageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterPlaylistImageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterPlaylistImageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterPlaylistImageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.ResolvedPersonalizedPlaylist)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResolvedPersonalizedPlaylist {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ResolvedPersonalizedPlaylist.uri)
    pub uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.ResolvedPersonalizedPlaylist.tag)
    pub tag: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.ResolvedPersonalizedPlaylist.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResolvedPersonalizedPlaylist {
    fn default() -> &'a ResolvedPersonalizedPlaylist {
        <ResolvedPersonalizedPlaylist as ::protobuf::Message>::default_instance()
    }
}

impl ResolvedPersonalizedPlaylist {
    pub fn new() -> ResolvedPersonalizedPlaylist {
        ::std::default::Default::default()
    }

    // optional string uri = 1;

    pub fn uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        self.uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tag = 2;

    pub fn tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &ResolvedPersonalizedPlaylist| { &m.uri },
            |m: &mut ResolvedPersonalizedPlaylist| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &ResolvedPersonalizedPlaylist| { &m.tag },
            |m: &mut ResolvedPersonalizedPlaylist| { &mut m.tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResolvedPersonalizedPlaylist>(
            "ResolvedPersonalizedPlaylist",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResolvedPersonalizedPlaylist {
    const NAME: &'static str = "ResolvedPersonalizedPlaylist";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.tag = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uri.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.tag.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResolvedPersonalizedPlaylist {
        ResolvedPersonalizedPlaylist::new()
    }

    fn clear(&mut self) {
        self.uri = ::std::option::Option::None;
        self.tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResolvedPersonalizedPlaylist {
        static instance: ResolvedPersonalizedPlaylist = ResolvedPersonalizedPlaylist {
            uri: ::std::option::Option::None,
            tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResolvedPersonalizedPlaylist {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResolvedPersonalizedPlaylist").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResolvedPersonalizedPlaylist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolvedPersonalizedPlaylist {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.PlaylistUriResolverResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlaylistUriResolverResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PlaylistUriResolverResponse.resolved_playlists)
    pub resolved_playlists: ::std::vec::Vec<ResolvedPersonalizedPlaylist>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.PlaylistUriResolverResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlaylistUriResolverResponse {
    fn default() -> &'a PlaylistUriResolverResponse {
        <PlaylistUriResolverResponse as ::protobuf::Message>::default_instance()
    }
}

impl PlaylistUriResolverResponse {
    pub fn new() -> PlaylistUriResolverResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resolved_playlists",
            |m: &PlaylistUriResolverResponse| { &m.resolved_playlists },
            |m: &mut PlaylistUriResolverResponse| { &mut m.resolved_playlists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlaylistUriResolverResponse>(
            "PlaylistUriResolverResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlaylistUriResolverResponse {
    const NAME: &'static str = "PlaylistUriResolverResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resolved_playlists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resolved_playlists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resolved_playlists {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlaylistUriResolverResponse {
        PlaylistUriResolverResponse::new()
    }

    fn clear(&mut self) {
        self.resolved_playlists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlaylistUriResolverResponse {
        static instance: PlaylistUriResolverResponse = PlaylistUriResolverResponse {
            resolved_playlists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlaylistUriResolverResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlaylistUriResolverResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlaylistUriResolverResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaylistUriResolverResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.SubscribeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.SubscribeRequest.uris)
    pub uris: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.SubscribeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeRequest {
    fn default() -> &'a SubscribeRequest {
        <SubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRequest {
    pub fn new() -> SubscribeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uris",
            |m: &SubscribeRequest| { &m.uris },
            |m: &mut SubscribeRequest| { &mut m.uris },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeRequest>(
            "SubscribeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeRequest {
    const NAME: &'static str = "SubscribeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uris.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uris {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uris {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeRequest {
        SubscribeRequest::new()
    }

    fn clear(&mut self) {
        self.uris.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeRequest {
        static instance: SubscribeRequest = SubscribeRequest {
            uris: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.UnsubscribeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnsubscribeRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.UnsubscribeRequest.uris)
    pub uris: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.UnsubscribeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnsubscribeRequest {
    fn default() -> &'a UnsubscribeRequest {
        <UnsubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnsubscribeRequest {
    pub fn new() -> UnsubscribeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uris",
            |m: &UnsubscribeRequest| { &m.uris },
            |m: &mut UnsubscribeRequest| { &mut m.uris },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnsubscribeRequest>(
            "UnsubscribeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnsubscribeRequest {
    const NAME: &'static str = "UnsubscribeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uris.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uris {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uris {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnsubscribeRequest {
        UnsubscribeRequest::new()
    }

    fn clear(&mut self) {
        self.uris.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnsubscribeRequest {
        static instance: UnsubscribeRequest = UnsubscribeRequest {
            uris: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnsubscribeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnsubscribeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnsubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsubscribeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.PlaylistModificationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlaylistModificationInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PlaylistModificationInfo.uri)
    pub uri: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PlaylistModificationInfo.new_revision)
    pub new_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PlaylistModificationInfo.parent_revision)
    pub parent_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.PlaylistModificationInfo.ops)
    pub ops: ::std::vec::Vec<Op>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.PlaylistModificationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlaylistModificationInfo {
    fn default() -> &'a PlaylistModificationInfo {
        <PlaylistModificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlaylistModificationInfo {
    pub fn new() -> PlaylistModificationInfo {
        ::std::default::Default::default()
    }

    // optional bytes uri = 1;

    pub fn uri(&self) -> &[u8] {
        match self.uri.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::vec::Vec<u8>) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::vec::Vec<u8> {
        self.uri.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes new_revision = 2;

    pub fn new_revision(&self) -> &[u8] {
        match self.new_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_new_revision(&mut self) {
        self.new_revision = ::std::option::Option::None;
    }

    pub fn has_new_revision(&self) -> bool {
        self.new_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.new_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.new_revision.is_none() {
            self.new_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.new_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.new_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes parent_revision = 3;

    pub fn parent_revision(&self) -> &[u8] {
        match self.parent_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_parent_revision(&mut self) {
        self.parent_revision = ::std::option::Option::None;
    }

    pub fn has_parent_revision(&self) -> bool {
        self.parent_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.parent_revision.is_none() {
            self.parent_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.parent_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.parent_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &PlaylistModificationInfo| { &m.uri },
            |m: &mut PlaylistModificationInfo| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_revision",
            |m: &PlaylistModificationInfo| { &m.new_revision },
            |m: &mut PlaylistModificationInfo| { &mut m.new_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_revision",
            |m: &PlaylistModificationInfo| { &m.parent_revision },
            |m: &mut PlaylistModificationInfo| { &mut m.parent_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ops",
            |m: &PlaylistModificationInfo| { &m.ops },
            |m: &mut PlaylistModificationInfo| { &mut m.ops },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlaylistModificationInfo>(
            "PlaylistModificationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlaylistModificationInfo {
    const NAME: &'static str = "PlaylistModificationInfo";

    fn is_initialized(&self) -> bool {
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.new_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.parent_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.ops.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.new_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.parent_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uri.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.new_revision.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.parent_revision.as_ref() {
            os.write_bytes(3, v)?;
        }
        for v in &self.ops {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlaylistModificationInfo {
        PlaylistModificationInfo::new()
    }

    fn clear(&mut self) {
        self.uri = ::std::option::Option::None;
        self.new_revision = ::std::option::Option::None;
        self.parent_revision = ::std::option::Option::None;
        self.ops.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlaylistModificationInfo {
        static instance: PlaylistModificationInfo = PlaylistModificationInfo {
            uri: ::std::option::Option::None,
            new_revision: ::std::option::Option::None,
            parent_revision: ::std::option::Option::None,
            ops: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlaylistModificationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlaylistModificationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlaylistModificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaylistModificationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.RootlistModificationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RootlistModificationInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.RootlistModificationInfo.new_revision)
    pub new_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.RootlistModificationInfo.parent_revision)
    pub parent_revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.RootlistModificationInfo.ops)
    pub ops: ::std::vec::Vec<Op>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.RootlistModificationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RootlistModificationInfo {
    fn default() -> &'a RootlistModificationInfo {
        <RootlistModificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl RootlistModificationInfo {
    pub fn new() -> RootlistModificationInfo {
        ::std::default::Default::default()
    }

    // optional bytes new_revision = 1;

    pub fn new_revision(&self) -> &[u8] {
        match self.new_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_new_revision(&mut self) {
        self.new_revision = ::std::option::Option::None;
    }

    pub fn has_new_revision(&self) -> bool {
        self.new_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.new_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.new_revision.is_none() {
            self.new_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.new_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.new_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes parent_revision = 2;

    pub fn parent_revision(&self) -> &[u8] {
        match self.parent_revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_parent_revision(&mut self) {
        self.parent_revision = ::std::option::Option::None;
    }

    pub fn has_parent_revision(&self) -> bool {
        self.parent_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.parent_revision.is_none() {
            self.parent_revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.parent_revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.parent_revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_revision",
            |m: &RootlistModificationInfo| { &m.new_revision },
            |m: &mut RootlistModificationInfo| { &mut m.new_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_revision",
            |m: &RootlistModificationInfo| { &m.parent_revision },
            |m: &mut RootlistModificationInfo| { &mut m.parent_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ops",
            |m: &RootlistModificationInfo| { &m.ops },
            |m: &mut RootlistModificationInfo| { &mut m.ops },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RootlistModificationInfo>(
            "RootlistModificationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RootlistModificationInfo {
    const NAME: &'static str = "RootlistModificationInfo";

    fn is_initialized(&self) -> bool {
        for v in &self.ops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.new_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.parent_revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.ops.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.parent_revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.ops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_revision.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.parent_revision.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.ops {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RootlistModificationInfo {
        RootlistModificationInfo::new()
    }

    fn clear(&mut self) {
        self.new_revision = ::std::option::Option::None;
        self.parent_revision = ::std::option::Option::None;
        self.ops.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RootlistModificationInfo {
        static instance: RootlistModificationInfo = RootlistModificationInfo {
            new_revision: ::std::option::Option::None,
            parent_revision: ::std::option::Option::None,
            ops: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RootlistModificationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RootlistModificationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RootlistModificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RootlistModificationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.playlist4.proto.FollowerUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FollowerUpdate {
    // message fields
    // @@protoc_insertion_point(field:spotify.playlist4.proto.FollowerUpdate.uri)
    pub uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.FollowerUpdate.username)
    pub username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.FollowerUpdate.is_following)
    pub is_following: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:spotify.playlist4.proto.FollowerUpdate.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.playlist4.proto.FollowerUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FollowerUpdate {
    fn default() -> &'a FollowerUpdate {
        <FollowerUpdate as ::protobuf::Message>::default_instance()
    }
}

impl FollowerUpdate {
    pub fn new() -> FollowerUpdate {
        ::std::default::Default::default()
    }

    // optional string uri = 1;

    pub fn uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        self.uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string username = 2;

    pub fn username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_following = 3;

    pub fn is_following(&self) -> bool {
        self.is_following.unwrap_or(false)
    }

    pub fn clear_is_following(&mut self) {
        self.is_following = ::std::option::Option::None;
    }

    pub fn has_is_following(&self) -> bool {
        self.is_following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_following(&mut self, v: bool) {
        self.is_following = ::std::option::Option::Some(v);
    }

    // optional uint64 timestamp = 4;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &FollowerUpdate| { &m.uri },
            |m: &mut FollowerUpdate| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &FollowerUpdate| { &m.username },
            |m: &mut FollowerUpdate| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_following",
            |m: &FollowerUpdate| { &m.is_following },
            |m: &mut FollowerUpdate| { &mut m.is_following },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &FollowerUpdate| { &m.timestamp },
            |m: &mut FollowerUpdate| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FollowerUpdate>(
            "FollowerUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FollowerUpdate {
    const NAME: &'static str = "FollowerUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uri = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.is_following = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_following {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uri.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.username.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_following {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FollowerUpdate {
        FollowerUpdate::new()
    }

    fn clear(&mut self) {
        self.uri = ::std::option::Option::None;
        self.username = ::std::option::Option::None;
        self.is_following = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FollowerUpdate {
        static instance: FollowerUpdate = FollowerUpdate {
            uri: ::std::option::Option::None,
            username: ::std::option::Option::None,
            is_following: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FollowerUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FollowerUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FollowerUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FollowerUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.playlist4.proto.ListAttributeKind)
pub enum ListAttributeKind {
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_UNKNOWN)
    LIST_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_NAME)
    LIST_NAME = 1,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_DESCRIPTION)
    LIST_DESCRIPTION = 2,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_PICTURE)
    LIST_PICTURE = 3,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_COLLABORATIVE)
    LIST_COLLABORATIVE = 4,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_PL3_VERSION)
    LIST_PL3_VERSION = 5,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_DELETED_BY_OWNER)
    LIST_DELETED_BY_OWNER = 6,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_CLIENT_ID)
    LIST_CLIENT_ID = 10,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_FORMAT)
    LIST_FORMAT = 11,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_FORMAT_ATTRIBUTES)
    LIST_FORMAT_ATTRIBUTES = 12,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_PICTURE_SIZE)
    LIST_PICTURE_SIZE = 13,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_SEQUENCE_CONTEXT_TEMPLATE)
    LIST_SEQUENCE_CONTEXT_TEMPLATE = 14,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ListAttributeKind.LIST_AI_CURATION_REFERENCE_ID)
    LIST_AI_CURATION_REFERENCE_ID = 15,
}

impl ::protobuf::Enum for ListAttributeKind {
    const NAME: &'static str = "ListAttributeKind";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ListAttributeKind> {
        match value {
            0 => ::std::option::Option::Some(ListAttributeKind::LIST_UNKNOWN),
            1 => ::std::option::Option::Some(ListAttributeKind::LIST_NAME),
            2 => ::std::option::Option::Some(ListAttributeKind::LIST_DESCRIPTION),
            3 => ::std::option::Option::Some(ListAttributeKind::LIST_PICTURE),
            4 => ::std::option::Option::Some(ListAttributeKind::LIST_COLLABORATIVE),
            5 => ::std::option::Option::Some(ListAttributeKind::LIST_PL3_VERSION),
            6 => ::std::option::Option::Some(ListAttributeKind::LIST_DELETED_BY_OWNER),
            10 => ::std::option::Option::Some(ListAttributeKind::LIST_CLIENT_ID),
            11 => ::std::option::Option::Some(ListAttributeKind::LIST_FORMAT),
            12 => ::std::option::Option::Some(ListAttributeKind::LIST_FORMAT_ATTRIBUTES),
            13 => ::std::option::Option::Some(ListAttributeKind::LIST_PICTURE_SIZE),
            14 => ::std::option::Option::Some(ListAttributeKind::LIST_SEQUENCE_CONTEXT_TEMPLATE),
            15 => ::std::option::Option::Some(ListAttributeKind::LIST_AI_CURATION_REFERENCE_ID),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ListAttributeKind> {
        match str {
            "LIST_UNKNOWN" => ::std::option::Option::Some(ListAttributeKind::LIST_UNKNOWN),
            "LIST_NAME" => ::std::option::Option::Some(ListAttributeKind::LIST_NAME),
            "LIST_DESCRIPTION" => ::std::option::Option::Some(ListAttributeKind::LIST_DESCRIPTION),
            "LIST_PICTURE" => ::std::option::Option::Some(ListAttributeKind::LIST_PICTURE),
            "LIST_COLLABORATIVE" => ::std::option::Option::Some(ListAttributeKind::LIST_COLLABORATIVE),
            "LIST_PL3_VERSION" => ::std::option::Option::Some(ListAttributeKind::LIST_PL3_VERSION),
            "LIST_DELETED_BY_OWNER" => ::std::option::Option::Some(ListAttributeKind::LIST_DELETED_BY_OWNER),
            "LIST_CLIENT_ID" => ::std::option::Option::Some(ListAttributeKind::LIST_CLIENT_ID),
            "LIST_FORMAT" => ::std::option::Option::Some(ListAttributeKind::LIST_FORMAT),
            "LIST_FORMAT_ATTRIBUTES" => ::std::option::Option::Some(ListAttributeKind::LIST_FORMAT_ATTRIBUTES),
            "LIST_PICTURE_SIZE" => ::std::option::Option::Some(ListAttributeKind::LIST_PICTURE_SIZE),
            "LIST_SEQUENCE_CONTEXT_TEMPLATE" => ::std::option::Option::Some(ListAttributeKind::LIST_SEQUENCE_CONTEXT_TEMPLATE),
            "LIST_AI_CURATION_REFERENCE_ID" => ::std::option::Option::Some(ListAttributeKind::LIST_AI_CURATION_REFERENCE_ID),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ListAttributeKind] = &[
        ListAttributeKind::LIST_UNKNOWN,
        ListAttributeKind::LIST_NAME,
        ListAttributeKind::LIST_DESCRIPTION,
        ListAttributeKind::LIST_PICTURE,
        ListAttributeKind::LIST_COLLABORATIVE,
        ListAttributeKind::LIST_PL3_VERSION,
        ListAttributeKind::LIST_DELETED_BY_OWNER,
        ListAttributeKind::LIST_CLIENT_ID,
        ListAttributeKind::LIST_FORMAT,
        ListAttributeKind::LIST_FORMAT_ATTRIBUTES,
        ListAttributeKind::LIST_PICTURE_SIZE,
        ListAttributeKind::LIST_SEQUENCE_CONTEXT_TEMPLATE,
        ListAttributeKind::LIST_AI_CURATION_REFERENCE_ID,
    ];
}

impl ::protobuf::EnumFull for ListAttributeKind {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ListAttributeKind").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ListAttributeKind::LIST_UNKNOWN => 0,
            ListAttributeKind::LIST_NAME => 1,
            ListAttributeKind::LIST_DESCRIPTION => 2,
            ListAttributeKind::LIST_PICTURE => 3,
            ListAttributeKind::LIST_COLLABORATIVE => 4,
            ListAttributeKind::LIST_PL3_VERSION => 5,
            ListAttributeKind::LIST_DELETED_BY_OWNER => 6,
            ListAttributeKind::LIST_CLIENT_ID => 7,
            ListAttributeKind::LIST_FORMAT => 8,
            ListAttributeKind::LIST_FORMAT_ATTRIBUTES => 9,
            ListAttributeKind::LIST_PICTURE_SIZE => 10,
            ListAttributeKind::LIST_SEQUENCE_CONTEXT_TEMPLATE => 11,
            ListAttributeKind::LIST_AI_CURATION_REFERENCE_ID => 12,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ListAttributeKind {
    fn default() -> Self {
        ListAttributeKind::LIST_UNKNOWN
    }
}

impl ListAttributeKind {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ListAttributeKind>("ListAttributeKind")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.playlist4.proto.ItemAttributeKind)
pub enum ItemAttributeKind {
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_UNKNOWN)
    ITEM_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_ADDED_BY)
    ITEM_ADDED_BY = 1,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_TIMESTAMP)
    ITEM_TIMESTAMP = 2,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_SEEN_AT)
    ITEM_SEEN_AT = 9,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_PUBLIC)
    ITEM_PUBLIC = 10,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_FORMAT_ATTRIBUTES)
    ITEM_FORMAT_ATTRIBUTES = 11,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_ID)
    ITEM_ID = 12,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_SOURCE_LENS)
    ITEM_SOURCE_LENS = 13,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_AVAILABLE_SIGNALS)
    ITEM_AVAILABLE_SIGNALS = 14,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_RECOMMENDATION_INFO)
    ITEM_RECOMMENDATION_INFO = 15,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.ItemAttributeKind.ITEM_SEQUENCE_CHILD_TEMPLATE)
    ITEM_SEQUENCE_CHILD_TEMPLATE = 16,
}

impl ::protobuf::Enum for ItemAttributeKind {
    const NAME: &'static str = "ItemAttributeKind";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ItemAttributeKind> {
        match value {
            0 => ::std::option::Option::Some(ItemAttributeKind::ITEM_UNKNOWN),
            1 => ::std::option::Option::Some(ItemAttributeKind::ITEM_ADDED_BY),
            2 => ::std::option::Option::Some(ItemAttributeKind::ITEM_TIMESTAMP),
            9 => ::std::option::Option::Some(ItemAttributeKind::ITEM_SEEN_AT),
            10 => ::std::option::Option::Some(ItemAttributeKind::ITEM_PUBLIC),
            11 => ::std::option::Option::Some(ItemAttributeKind::ITEM_FORMAT_ATTRIBUTES),
            12 => ::std::option::Option::Some(ItemAttributeKind::ITEM_ID),
            13 => ::std::option::Option::Some(ItemAttributeKind::ITEM_SOURCE_LENS),
            14 => ::std::option::Option::Some(ItemAttributeKind::ITEM_AVAILABLE_SIGNALS),
            15 => ::std::option::Option::Some(ItemAttributeKind::ITEM_RECOMMENDATION_INFO),
            16 => ::std::option::Option::Some(ItemAttributeKind::ITEM_SEQUENCE_CHILD_TEMPLATE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ItemAttributeKind> {
        match str {
            "ITEM_UNKNOWN" => ::std::option::Option::Some(ItemAttributeKind::ITEM_UNKNOWN),
            "ITEM_ADDED_BY" => ::std::option::Option::Some(ItemAttributeKind::ITEM_ADDED_BY),
            "ITEM_TIMESTAMP" => ::std::option::Option::Some(ItemAttributeKind::ITEM_TIMESTAMP),
            "ITEM_SEEN_AT" => ::std::option::Option::Some(ItemAttributeKind::ITEM_SEEN_AT),
            "ITEM_PUBLIC" => ::std::option::Option::Some(ItemAttributeKind::ITEM_PUBLIC),
            "ITEM_FORMAT_ATTRIBUTES" => ::std::option::Option::Some(ItemAttributeKind::ITEM_FORMAT_ATTRIBUTES),
            "ITEM_ID" => ::std::option::Option::Some(ItemAttributeKind::ITEM_ID),
            "ITEM_SOURCE_LENS" => ::std::option::Option::Some(ItemAttributeKind::ITEM_SOURCE_LENS),
            "ITEM_AVAILABLE_SIGNALS" => ::std::option::Option::Some(ItemAttributeKind::ITEM_AVAILABLE_SIGNALS),
            "ITEM_RECOMMENDATION_INFO" => ::std::option::Option::Some(ItemAttributeKind::ITEM_RECOMMENDATION_INFO),
            "ITEM_SEQUENCE_CHILD_TEMPLATE" => ::std::option::Option::Some(ItemAttributeKind::ITEM_SEQUENCE_CHILD_TEMPLATE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ItemAttributeKind] = &[
        ItemAttributeKind::ITEM_UNKNOWN,
        ItemAttributeKind::ITEM_ADDED_BY,
        ItemAttributeKind::ITEM_TIMESTAMP,
        ItemAttributeKind::ITEM_SEEN_AT,
        ItemAttributeKind::ITEM_PUBLIC,
        ItemAttributeKind::ITEM_FORMAT_ATTRIBUTES,
        ItemAttributeKind::ITEM_ID,
        ItemAttributeKind::ITEM_SOURCE_LENS,
        ItemAttributeKind::ITEM_AVAILABLE_SIGNALS,
        ItemAttributeKind::ITEM_RECOMMENDATION_INFO,
        ItemAttributeKind::ITEM_SEQUENCE_CHILD_TEMPLATE,
    ];
}

impl ::protobuf::EnumFull for ItemAttributeKind {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ItemAttributeKind").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ItemAttributeKind::ITEM_UNKNOWN => 0,
            ItemAttributeKind::ITEM_ADDED_BY => 1,
            ItemAttributeKind::ITEM_TIMESTAMP => 2,
            ItemAttributeKind::ITEM_SEEN_AT => 3,
            ItemAttributeKind::ITEM_PUBLIC => 4,
            ItemAttributeKind::ITEM_FORMAT_ATTRIBUTES => 5,
            ItemAttributeKind::ITEM_ID => 6,
            ItemAttributeKind::ITEM_SOURCE_LENS => 7,
            ItemAttributeKind::ITEM_AVAILABLE_SIGNALS => 8,
            ItemAttributeKind::ITEM_RECOMMENDATION_INFO => 9,
            ItemAttributeKind::ITEM_SEQUENCE_CHILD_TEMPLATE => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ItemAttributeKind {
    fn default() -> Self {
        ItemAttributeKind::ITEM_UNKNOWN
    }
}

impl ItemAttributeKind {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ItemAttributeKind>("ItemAttributeKind")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.playlist4.proto.GeoblockBlockingType)
pub enum GeoblockBlockingType {
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.GeoblockBlockingType.GEOBLOCK_BLOCKING_TYPE_UNSPECIFIED)
    GEOBLOCK_BLOCKING_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.GeoblockBlockingType.GEOBLOCK_BLOCKING_TYPE_TITLE)
    GEOBLOCK_BLOCKING_TYPE_TITLE = 1,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.GeoblockBlockingType.GEOBLOCK_BLOCKING_TYPE_DESCRIPTION)
    GEOBLOCK_BLOCKING_TYPE_DESCRIPTION = 2,
    // @@protoc_insertion_point(enum_value:spotify.playlist4.proto.GeoblockBlockingType.GEOBLOCK_BLOCKING_TYPE_IMAGE)
    GEOBLOCK_BLOCKING_TYPE_IMAGE = 3,
}

impl ::protobuf::Enum for GeoblockBlockingType {
    const NAME: &'static str = "GeoblockBlockingType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GeoblockBlockingType> {
        match value {
            0 => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_TITLE),
            2 => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_DESCRIPTION),
            3 => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_IMAGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GeoblockBlockingType> {
        match str {
            "GEOBLOCK_BLOCKING_TYPE_UNSPECIFIED" => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_UNSPECIFIED),
            "GEOBLOCK_BLOCKING_TYPE_TITLE" => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_TITLE),
            "GEOBLOCK_BLOCKING_TYPE_DESCRIPTION" => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_DESCRIPTION),
            "GEOBLOCK_BLOCKING_TYPE_IMAGE" => ::std::option::Option::Some(GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_IMAGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GeoblockBlockingType] = &[
        GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_UNSPECIFIED,
        GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_TITLE,
        GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_DESCRIPTION,
        GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_IMAGE,
    ];
}

impl ::protobuf::EnumFull for GeoblockBlockingType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GeoblockBlockingType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GeoblockBlockingType {
    fn default() -> Self {
        GeoblockBlockingType::GEOBLOCK_BLOCKING_TYPE_UNSPECIFIED
    }
}

impl GeoblockBlockingType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GeoblockBlockingType>("GeoblockBlockingType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18playlist4_external.proto\x12\x17spotify.playlist4.proto\x1a\x10len\
    s-model.proto\x1a\x19playlist_permission.proto\x1a\x12signal-model.proto\
    \"a\n\x04Item\x12\x10\n\x03uri\x18\x01\x20\x02(\tR\x03uri\x12G\n\nattrib\
    utes\x18\x02\x20\x01(\x0b2'.spotify.playlist4.proto.ItemAttributesR\natt\
    ributes\"\xc5\x03\n\x08MetaItem\x12\x1a\n\x08revision\x18\x01\x20\x01(\
    \x0cR\x08revision\x12G\n\nattributes\x18\x02\x20\x01(\x0b2'.spotify.play\
    list4.proto.ListAttributesR\nattributes\x12\x16\n\x06length\x18\x03\x20\
    \x01(\x05R\x06length\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\x03R\ttimesta\
    mp\x12%\n\x0eowner_username\x18\x05\x20\x01(\tR\rownerUsername\x126\n\
    \x17abuse_reporting_enabled\x18\x06\x20\x01(\x08R\x15abuseReportingEnabl\
    ed\x12S\n\x0ccapabilities\x18\x07\x20\x01(\x0b2/.spotify.playlist_permis\
    sion.proto.CapabilitiesR\x0ccapabilities\x12I\n\x08geoblock\x18\x08\x20\
    \x03(\x0e2-.spotify.playlist4.proto.GeoblockBlockingTypeR\x08geoblock\
    \x12\x1f\n\x0bstatus_code\x18\t\x20\x01(\x11R\nstatusCode\"\xb5\x02\n\tL\
    istItems\x12\x10\n\x03pos\x18\x01\x20\x02(\x05R\x03pos\x12\x1c\n\ttrunca\
    ted\x18\x02\x20\x02(\x08R\ttruncated\x123\n\x05items\x18\x03\x20\x03(\
    \x0b2\x1d.spotify.playlist4.proto.ItemR\x05items\x12@\n\nmeta_items\x18\
    \x04\x20\x03(\x0b2!.spotify.playlist4.proto.MetaItemR\tmetaItems\x12R\n\
    \x11available_signals\x18\x05\x20\x03(\x0b2%.spotify.playlist.signal.pro\
    to.SignalR\x10availableSignals\x12-\n\x12continuation_token\x18\x06\x20\
    \x01(\tR\x11continuationToken\"\x83\x02\n\x1cPaginatedUnfollowedListItem\
    s\x12\x14\n\x05limit\x18\x01\x20\x01(\x05R\x05limit\x12\x16\n\x06offset\
    \x18\x02\x20\x01(\x05R\x06offset\x12$\n\rnextPageIndex\x18\x03\x20\x01(\
    \x05R\rnextPageIndex\x12,\n\x11previousPageIndex\x18\x04\x20\x01(\x05R\
    \x11previousPageIndex\x12\x1e\n\ntotalPages\x18\x05\x20\x01(\x05R\ntotal\
    Pages\x12A\n\x05items\x18\x06\x20\x03(\x0b2+.spotify.playlist4.proto.Unf\
    ollowedListItemR\x05items\"\x93\x01\n\x12UnfollowedListItem\x12\x10\n\
    \x03uri\x18\x01\x20\x01(\tR\x03uri\x12\x20\n\x0brecoverable\x18\x02\x20\
    \x01(\x08R\x0brecoverable\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\
    \x12\x1d\n\ndeleted_at\x18\x04\x20\x01(\x03R\tdeletedAt\x12\x16\n\x06len\
    gth\x18\x05\x20\x01(\x05R\x06length\"=\n\x13FormatListAttribute\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value\"@\n\x0bPictureSize\x12\x1f\n\x0btarget_name\x18\x01\x20\
    \x01(\tR\ntargetName\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\"A\n\
    \x12RecommendationInfo\x12+\n\x11is_recommendation\x18\x01\x20\x01(\x08R\
    \x10isRecommendation\"\x9f\x04\n\x0eListAttributes\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\
    \x0bdescription\x12\x18\n\x07picture\x18\x03\x20\x01(\x0cR\x07picture\
    \x12$\n\rcollaborative\x18\x04\x20\x01(\x08R\rcollaborative\x12\x1f\n\
    \x0bpl3_version\x18\x05\x20\x01(\tR\npl3Version\x12(\n\x10deleted_by_own\
    er\x18\x06\x20\x01(\x08R\x0edeletedByOwner\x12\x1b\n\tclient_id\x18\n\
    \x20\x01(\tR\x08clientId\x12\x16\n\x06format\x18\x0b\x20\x01(\tR\x06form\
    at\x12Y\n\x11format_attributes\x18\x0c\x20\x03(\x0b2,.spotify.playlist4.\
    proto.FormatListAttributeR\x10formatAttributes\x12G\n\x0cpicture_size\
    \x18\r\x20\x03(\x0b2$.spotify.playlist4.proto.PictureSizeR\x0bpictureSiz\
    e\x12:\n\x19sequence_context_template\x18\x0e\x20\x01(\x0cR\x17sequenceC\
    ontextTemplate\x127\n\x18ai_curation_reference_id\x18\x0f\x20\x01(\x0cR\
    \x15aiCurationReferenceId\"\x99\x04\n\x0eItemAttributes\x12\x19\n\x08add\
    ed_by\x18\x01\x20\x01(\tR\x07addedBy\x12\x1c\n\ttimestamp\x18\x02\x20\
    \x01(\x03R\ttimestamp\x12\x17\n\x07seen_at\x18\t\x20\x01(\x03R\x06seenAt\
    \x12\x16\n\x06public\x18\n\x20\x01(\x08R\x06public\x12Y\n\x11format_attr\
    ibutes\x18\x0b\x20\x03(\x0b2,.spotify.playlist4.proto.FormatListAttribut\
    eR\x10formatAttributes\x12\x17\n\x07item_id\x18\x0c\x20\x01(\x0cR\x06ite\
    mId\x12?\n\x0bsource_lens\x18\r\x20\x01(\x0b2\x1e.spotify.lens.model.pro\
    to.LensR\nsourceLens\x12R\n\x11available_signals\x18\x0e\x20\x03(\x0b2%.\
    spotify.playlist.signal.proto.SignalR\x10availableSignals\x12\\\n\x13rec\
    ommendation_info\x18\x0f\x20\x01(\x0b2+.spotify.playlist4.proto.Recommen\
    dationInfoR\x12recommendationInfo\x126\n\x17sequence_child_template\x18\
    \x10\x20\x01(\x0cR\x15sequenceChildTemplate\"\x9d\x02\n\x03Add\x12\x1d\n\
    \nfrom_index\x18\x01\x20\x01(\x05R\tfromIndex\x123\n\x05items\x18\x02\
    \x20\x03(\x0b2\x1d.spotify.playlist4.proto.ItemR\x05items\x12\x19\n\x08a\
    dd_last\x18\x04\x20\x01(\x08R\x07addLast\x12\x1b\n\tadd_first\x18\x05\
    \x20\x01(\x08R\x08addFirst\x12E\n\x0fadd_before_item\x18\x06\x20\x01(\
    \x0b2\x1d.spotify.playlist4.proto.ItemR\raddBeforeItem\x12C\n\x0eadd_aft\
    er_item\x18\x07\x20\x01(\x0b2\x1d.spotify.playlist4.proto.ItemR\x0caddAf\
    terItem\"\x93\x01\n\x03Rem\x12\x1d\n\nfrom_index\x18\x01\x20\x01(\x05R\t\
    fromIndex\x12\x16\n\x06length\x18\x02\x20\x01(\x05R\x06length\x123\n\x05\
    items\x18\x03\x20\x03(\x0b2\x1d.spotify.playlist4.proto.ItemR\x05items\
    \x12\x20\n\x0citems_as_key\x18\x07\x20\x01(\x08R\nitemsAsKey\"\xd0\x02\n\
    \x03Mov\x12\x1d\n\nfrom_index\x18\x01\x20\x01(\x05R\tfromIndex\x12\x16\n\
    \x06length\x18\x02\x20\x01(\x05R\x06length\x12\x19\n\x08to_index\x18\x03\
    \x20\x01(\x05R\x07toIndex\x123\n\x05items\x18\x04\x20\x03(\x0b2\x1d.spot\
    ify.playlist4.proto.ItemR\x05items\x12E\n\x0fadd_before_item\x18\x05\x20\
    \x01(\x0b2\x1d.spotify.playlist4.proto.ItemR\raddBeforeItem\x12C\n\x0ead\
    d_after_item\x18\x06\x20\x01(\x0b2\x1d.spotify.playlist4.proto.ItemR\x0c\
    addAfterItem\x12\x1b\n\tadd_first\x18\x07\x20\x01(\x08R\x08addFirst\x12\
    \x19\n\x08add_last\x18\x08\x20\x01(\x08R\x07addLast\"\xa4\x01\n\x1aItemA\
    ttributesPartialState\x12?\n\x06values\x18\x01\x20\x02(\x0b2'.spotify.pl\
    aylist4.proto.ItemAttributesR\x06values\x12E\n\x08no_value\x18\x02\x20\
    \x03(\x0e2*.spotify.playlist4.proto.ItemAttributeKindR\x07noValue\"\xa4\
    \x01\n\x1aListAttributesPartialState\x12?\n\x06values\x18\x01\x20\x02(\
    \x0b2'.spotify.playlist4.proto.ListAttributesR\x06values\x12E\n\x08no_va\
    lue\x18\x02\x20\x03(\x0e2*.spotify.playlist4.proto.ListAttributeKindR\
    \x07noValue\"\x97\x02\n\x14UpdateItemAttributes\x12\x14\n\x05index\x18\
    \x01\x20\x01(\x05R\x05index\x12Z\n\x0enew_attributes\x18\x02\x20\x02(\
    \x0b23.spotify.playlist4.proto.ItemAttributesPartialStateR\rnewAttribute\
    s\x12Z\n\x0eold_attributes\x18\x03\x20\x01(\x0b23.spotify.playlist4.prot\
    o.ItemAttributesPartialStateR\roldAttributes\x121\n\x04item\x18\x04\x20\
    \x01(\x0b2\x1d.spotify.playlist4.proto.ItemR\x04item\"\xce\x01\n\x14Upda\
    teListAttributes\x12Z\n\x0enew_attributes\x18\x01\x20\x02(\x0b23.spotify\
    .playlist4.proto.ListAttributesPartialStateR\rnewAttributes\x12Z\n\x0eol\
    d_attributes\x18\x02\x20\x01(\x0b23.spotify.playlist4.proto.ListAttribut\
    esPartialStateR\roldAttributes\"d\n\x0eUpdateItemUris\x12R\n\x10uri_repl\
    acements\x18\x01\x20\x03(\x0b2'.spotify.playlist4.proto.UriReplacementR\
    \x0furiReplacements\"r\n\x0eUriReplacement\x12\x14\n\x05index\x18\x01\
    \x20\x01(\x05R\x05index\x121\n\x04item\x18\x02\x20\x01(\x0b2\x1d.spotify\
    .playlist4.proto.ItemR\x04item\x12\x17\n\x07new_uri\x18\x03\x20\x01(\tR\
    \x06newUri\"\xeb\x04\n\x02Op\x124\n\x04kind\x18\x01\x20\x02(\x0e2\x20.sp\
    otify.playlist4.proto.Op.KindR\x04kind\x12.\n\x03add\x18\x02\x20\x01(\
    \x0b2\x1c.spotify.playlist4.proto.AddR\x03add\x12.\n\x03rem\x18\x03\x20\
    \x01(\x0b2\x1c.spotify.playlist4.proto.RemR\x03rem\x12.\n\x03mov\x18\x04\
    \x20\x01(\x0b2\x1c.spotify.playlist4.proto.MovR\x03mov\x12c\n\x16update_\
    item_attributes\x18\x05\x20\x01(\x0b2-.spotify.playlist4.proto.UpdateIte\
    mAttributesR\x14updateItemAttributes\x12c\n\x16update_list_attributes\
    \x18\x06\x20\x01(\x0b2-.spotify.playlist4.proto.UpdateListAttributesR\
    \x14updateListAttributes\x12Q\n\x10update_item_uris\x18\x07\x20\x01(\x0b\
    2'.spotify.playlist4.proto.UpdateItemUrisR\x0eupdateItemUris\"\x81\x01\n\
    \x04Kind\x12\x10\n\x0cKIND_UNKNOWN\x10\0\x12\x07\n\x03ADD\x10\x02\x12\
    \x07\n\x03REM\x10\x03\x12\x07\n\x03MOV\x10\x04\x12\x1a\n\x16UPDATE_ITEM_\
    ATTRIBUTES\x10\x05\x12\x1a\n\x16UPDATE_LIST_ATTRIBUTES\x10\x06\x12\x14\n\
    \x10UPDATE_ITEM_URIS\x10\x07\"7\n\x06OpList\x12-\n\x03ops\x18\x01\x20\
    \x03(\x0b2\x1b.spotify.playlist4.proto.OpR\x03ops\"\xa8\x02\n\nChangeInf\
    o\x12\x12\n\x04user\x18\x01\x20\x01(\tR\x04user\x12\x1c\n\ttimestamp\x18\
    \x02\x20\x01(\x03R\ttimestamp\x12\x14\n\x05admin\x18\x03\x20\x01(\x08R\
    \x05admin\x12\x12\n\x04undo\x18\x04\x20\x01(\x08R\x04undo\x12\x12\n\x04r\
    edo\x18\x05\x20\x01(\x08R\x04redo\x12\x14\n\x05merge\x18\x06\x20\x01(\
    \x08R\x05merge\x12\x1e\n\ncompressed\x18\x07\x20\x01(\x08R\ncompressed\
    \x12\x1c\n\tmigration\x18\x08\x20\x01(\x08R\tmigration\x12\x19\n\x08spli\
    t_id\x18\t\x20\x01(\x05R\x07splitId\x12;\n\x06source\x18\n\x20\x01(\x0b2\
    #.spotify.playlist4.proto.SourceInfoR\x06source\"\xab\x02\n\nSourceInfo\
    \x12B\n\x06client\x18\x01\x20\x01(\x0e2*.spotify.playlist4.proto.SourceI\
    nfo.ClientR\x06client\x12\x10\n\x03app\x18\x03\x20\x01(\tR\x03app\x12\
    \x16\n\x06source\x18\x04\x20\x01(\tR\x06source\x12\x18\n\x07version\x18\
    \x05\x20\x01(\tR\x07version\x12#\n\rserver_domain\x18\x06\x20\x01(\tR\
    \x0cserverDomain\"p\n\x06Client\x12\x12\n\x0eCLIENT_UNKNOWN\x10\0\x12\
    \x11\n\rNATIVE_HERMES\x10\x01\x12\n\n\x06CLIENT\x10\x02\x12\n\n\x06PYTHO\
    N\x10\x03\x12\x08\n\x04JAVA\x10\x04\x12\r\n\tWEBPLAYER\x10\x05\x12\x0e\n\
    \nLIBSPOTIFY\x10\x06\"\x92\x01\n\x05Delta\x12!\n\x0cbase_version\x18\x01\
    \x20\x01(\x0cR\x0bbaseVersion\x12-\n\x03ops\x18\x02\x20\x03(\x0b2\x1b.sp\
    otify.playlist4.proto.OpR\x03ops\x127\n\x04info\x18\x04\x20\x01(\x0b2#.s\
    potify.playlist4.proto.ChangeInfoR\x04info\"{\n\x04Diff\x12#\n\rfrom_rev\
    ision\x18\x01\x20\x02(\x0cR\x0cfromRevision\x12-\n\x03ops\x18\x02\x20\
    \x03(\x0b2\x1b.spotify.playlist4.proto.OpR\x03ops\x12\x1f\n\x0bto_revisi\
    on\x18\x03\x20\x02(\x0cR\ntoRevision\"\xe6\x01\n\x0bListChanges\x12#\n\r\
    base_revision\x18\x01\x20\x01(\x0cR\x0cbaseRevision\x126\n\x06deltas\x18\
    \x02\x20\x03(\x0b2\x1e.spotify.playlist4.proto.DeltaR\x06deltas\x128\n\
    \x18want_resulting_revisions\x18\x03\x20\x01(\x08R\x16wantResultingRevis\
    ions\x12(\n\x10want_sync_result\x18\x04\x20\x01(\x08R\x0ewantSyncResult\
    \x12\x16\n\x06nonces\x18\x06\x20\x03(\x03R\x06nonces\"\x82\x01\n\x0bList\
    Signals\x12#\n\rbase_revision\x18\x01\x20\x01(\x0cR\x0cbaseRevision\x12N\
    \n\x0femitted_signals\x18\x02\x20\x03(\x0b2%.spotify.playlist.signal.pro\
    to.SignalR\x0eemittedSignals\"\x94\x07\n\x13SelectedListContent\x12\x1a\
    \n\x08revision\x18\x01\x20\x01(\x0cR\x08revision\x12\x16\n\x06length\x18\
    \x02\x20\x01(\x05R\x06length\x12G\n\nattributes\x18\x03\x20\x01(\x0b2'.s\
    potify.playlist4.proto.ListAttributesR\nattributes\x12>\n\x08contents\
    \x18\x05\x20\x01(\x0b2\".spotify.playlist4.proto.ListItemsR\x08contents\
    \x121\n\x04diff\x18\x06\x20\x01(\x0b2\x1d.spotify.playlist4.proto.DiffR\
    \x04diff\x12>\n\x0bsync_result\x18\x07\x20\x01(\x0b2\x1d.spotify.playlis\
    t4.proto.DiffR\nsyncResult\x12/\n\x13resulting_revisions\x18\x08\x20\x03\
    (\x0cR\x12resultingRevisions\x12%\n\x0emultiple_heads\x18\t\x20\x01(\x08\
    R\rmultipleHeads\x12\x1c\n\nup_to_date\x18\n\x20\x01(\x08R\x08upToDate\
    \x12\x16\n\x06nonces\x18\x0e\x20\x03(\x03R\x06nonces\x12\x1c\n\ttimestam\
    p\x18\x0f\x20\x01(\x03R\ttimestamp\x12%\n\x0eowner_username\x18\x10\x20\
    \x01(\tR\rownerUsername\x126\n\x17abuse_reporting_enabled\x18\x11\x20\
    \x01(\x08R\x15abuseReportingEnabled\x12S\n\x0ccapabilities\x18\x12\x20\
    \x01(\x0b2/.spotify.playlist_permission.proto.CapabilitiesR\x0ccapabilit\
    ies\x12I\n\x08geoblock\x18\x13\x20\x03(\x0e2-.spotify.playlist4.proto.Ge\
    oblockBlockingTypeR\x08geoblock\x124\n\x16changes_require_resync\x18\x14\
    \x20\x01(\x08R\x14changesRequireResync\x12\x1d\n\ncreated_at\x18\x15\x20\
    \x01(\x03R\tcreatedAt\x12M\n\x0eapplied_lenses\x18\x16\x20\x01(\x0b2&.sp\
    otify.playlist4.proto.AppliedLensesR\rappliedLenses\"L\n\rAppliedLenses\
    \x12;\n\x06states\x18\x01\x20\x03(\x0b2#.spotify.lens.model.proto.LensSt\
    ateR\x06states\"?\n\x0fCreateListReply\x12\x10\n\x03uri\x18\x01\x20\x02(\
    \tR\x03uri\x12\x1a\n\x08revision\x18\x02\x20\x01(\x0cR\x08revision\"/\n\
    \x14PlaylistV1UriRequest\x12\x17\n\x07v2_uris\x18\x01\x20\x03(\tR\x06v2U\
    ris\"\xbc\x01\n\x12PlaylistV1UriReply\x12e\n\x10v2_uri_to_v1_uri\x18\x01\
    \x20\x03(\x0b2=.spotify.playlist4.proto.PlaylistV1UriReply.V2UriToV1UriE\
    ntryR\x0cv2UriToV1Uri\x1a?\n\x11V2UriToV1UriEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\"\xef\x01\n\x11ListUpdateRequest\x12#\n\rbase_revision\x18\x01\
    \x20\x01(\x0cR\x0cbaseRevision\x12G\n\nattributes\x18\x02\x20\x01(\x0b2'\
    .spotify.playlist4.proto.ListAttributesR\nattributes\x123\n\x05items\x18\
    \x03\x20\x03(\x0b2\x1d.spotify.playlist4.proto.ItemR\x05items\x127\n\x04\
    info\x18\x04\x20\x01(\x0b2#.spotify.playlist4.proto.ChangeInfoR\x04info\
    \"A\n\x1cRegisterPlaylistImageRequest\x12!\n\x0cupload_token\x18\x01\x20\
    \x01(\tR\x0buploadToken\"9\n\x1dRegisterPlaylistImageResponse\x12\x18\n\
    \x07picture\x18\x01\x20\x01(\x0cR\x07picture\"B\n\x1cResolvedPersonalize\
    dPlaylist\x12\x10\n\x03uri\x18\x01\x20\x01(\tR\x03uri\x12\x10\n\x03tag\
    \x18\x02\x20\x01(\tR\x03tag\"\x83\x01\n\x1bPlaylistUriResolverResponse\
    \x12d\n\x12resolved_playlists\x18\x01\x20\x03(\x0b25.spotify.playlist4.p\
    roto.ResolvedPersonalizedPlaylistR\x11resolvedPlaylists\"&\n\x10Subscrib\
    eRequest\x12\x12\n\x04uris\x18\x01\x20\x03(\x0cR\x04uris\"(\n\x12Unsubsc\
    ribeRequest\x12\x12\n\x04uris\x18\x01\x20\x03(\x0cR\x04uris\"\xa7\x01\n\
    \x18PlaylistModificationInfo\x12\x10\n\x03uri\x18\x01\x20\x01(\x0cR\x03u\
    ri\x12!\n\x0cnew_revision\x18\x02\x20\x01(\x0cR\x0bnewRevision\x12'\n\
    \x0fparent_revision\x18\x03\x20\x01(\x0cR\x0eparentRevision\x12-\n\x03op\
    s\x18\x04\x20\x03(\x0b2\x1b.spotify.playlist4.proto.OpR\x03ops\"\x95\x01\
    \n\x18RootlistModificationInfo\x12!\n\x0cnew_revision\x18\x01\x20\x01(\
    \x0cR\x0bnewRevision\x12'\n\x0fparent_revision\x18\x02\x20\x01(\x0cR\x0e\
    parentRevision\x12-\n\x03ops\x18\x03\x20\x03(\x0b2\x1b.spotify.playlist4\
    .proto.OpR\x03ops\"\x7f\n\x0eFollowerUpdate\x12\x10\n\x03uri\x18\x01\x20\
    \x01(\tR\x03uri\x12\x1a\n\x08username\x18\x02\x20\x01(\tR\x08username\
    \x12!\n\x0cis_following\x18\x03\x20\x01(\x08R\x0bisFollowing\x12\x1c\n\t\
    timestamp\x18\x04\x20\x01(\x04R\ttimestamp*\xc4\x02\n\x11ListAttributeKi\
    nd\x12\x10\n\x0cLIST_UNKNOWN\x10\0\x12\r\n\tLIST_NAME\x10\x01\x12\x14\n\
    \x10LIST_DESCRIPTION\x10\x02\x12\x10\n\x0cLIST_PICTURE\x10\x03\x12\x16\n\
    \x12LIST_COLLABORATIVE\x10\x04\x12\x14\n\x10LIST_PL3_VERSION\x10\x05\x12\
    \x19\n\x15LIST_DELETED_BY_OWNER\x10\x06\x12\x12\n\x0eLIST_CLIENT_ID\x10\
    \n\x12\x0f\n\x0bLIST_FORMAT\x10\x0b\x12\x1a\n\x16LIST_FORMAT_ATTRIBUTES\
    \x10\x0c\x12\x15\n\x11LIST_PICTURE_SIZE\x10\r\x12\"\n\x1eLIST_SEQUENCE_C\
    ONTEXT_TEMPLATE\x10\x0e\x12!\n\x1dLIST_AI_CURATION_REFERENCE_ID\x10\x0f*\
    \x8a\x02\n\x11ItemAttributeKind\x12\x10\n\x0cITEM_UNKNOWN\x10\0\x12\x11\
    \n\rITEM_ADDED_BY\x10\x01\x12\x12\n\x0eITEM_TIMESTAMP\x10\x02\x12\x10\n\
    \x0cITEM_SEEN_AT\x10\t\x12\x0f\n\x0bITEM_PUBLIC\x10\n\x12\x1a\n\x16ITEM_\
    FORMAT_ATTRIBUTES\x10\x0b\x12\x0b\n\x07ITEM_ID\x10\x0c\x12\x14\n\x10ITEM\
    _SOURCE_LENS\x10\r\x12\x1a\n\x16ITEM_AVAILABLE_SIGNALS\x10\x0e\x12\x1c\n\
    \x18ITEM_RECOMMENDATION_INFO\x10\x0f\x12\x20\n\x1cITEM_SEQUENCE_CHILD_TE\
    MPLATE\x10\x10*\xaa\x01\n\x14GeoblockBlockingType\x12&\n\"GEOBLOCK_BLOCK\
    ING_TYPE_UNSPECIFIED\x10\0\x12\x20\n\x1cGEOBLOCK_BLOCKING_TYPE_TITLE\x10\
    \x01\x12&\n\"GEOBLOCK_BLOCKING_TYPE_DESCRIPTION\x10\x02\x12\x20\n\x1cGEO\
    BLOCK_BLOCKING_TYPE_IMAGE\x10\x03B2\n\x1bcom.spotify.playlist4.protoB\
    \x11Playlist4ApiProtoH\x02b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::lens_model::file_descriptor().clone());
            deps.push(super::playlist_permission::file_descriptor().clone());
            deps.push(super::signal_model::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(42);
            messages.push(Item::generated_message_descriptor_data());
            messages.push(MetaItem::generated_message_descriptor_data());
            messages.push(ListItems::generated_message_descriptor_data());
            messages.push(PaginatedUnfollowedListItems::generated_message_descriptor_data());
            messages.push(UnfollowedListItem::generated_message_descriptor_data());
            messages.push(FormatListAttribute::generated_message_descriptor_data());
            messages.push(PictureSize::generated_message_descriptor_data());
            messages.push(RecommendationInfo::generated_message_descriptor_data());
            messages.push(ListAttributes::generated_message_descriptor_data());
            messages.push(ItemAttributes::generated_message_descriptor_data());
            messages.push(Add::generated_message_descriptor_data());
            messages.push(Rem::generated_message_descriptor_data());
            messages.push(Mov::generated_message_descriptor_data());
            messages.push(ItemAttributesPartialState::generated_message_descriptor_data());
            messages.push(ListAttributesPartialState::generated_message_descriptor_data());
            messages.push(UpdateItemAttributes::generated_message_descriptor_data());
            messages.push(UpdateListAttributes::generated_message_descriptor_data());
            messages.push(UpdateItemUris::generated_message_descriptor_data());
            messages.push(UriReplacement::generated_message_descriptor_data());
            messages.push(Op::generated_message_descriptor_data());
            messages.push(OpList::generated_message_descriptor_data());
            messages.push(ChangeInfo::generated_message_descriptor_data());
            messages.push(SourceInfo::generated_message_descriptor_data());
            messages.push(Delta::generated_message_descriptor_data());
            messages.push(Diff::generated_message_descriptor_data());
            messages.push(ListChanges::generated_message_descriptor_data());
            messages.push(ListSignals::generated_message_descriptor_data());
            messages.push(SelectedListContent::generated_message_descriptor_data());
            messages.push(AppliedLenses::generated_message_descriptor_data());
            messages.push(CreateListReply::generated_message_descriptor_data());
            messages.push(PlaylistV1UriRequest::generated_message_descriptor_data());
            messages.push(PlaylistV1UriReply::generated_message_descriptor_data());
            messages.push(ListUpdateRequest::generated_message_descriptor_data());
            messages.push(RegisterPlaylistImageRequest::generated_message_descriptor_data());
            messages.push(RegisterPlaylistImageResponse::generated_message_descriptor_data());
            messages.push(ResolvedPersonalizedPlaylist::generated_message_descriptor_data());
            messages.push(PlaylistUriResolverResponse::generated_message_descriptor_data());
            messages.push(SubscribeRequest::generated_message_descriptor_data());
            messages.push(UnsubscribeRequest::generated_message_descriptor_data());
            messages.push(PlaylistModificationInfo::generated_message_descriptor_data());
            messages.push(RootlistModificationInfo::generated_message_descriptor_data());
            messages.push(FollowerUpdate::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(ListAttributeKind::generated_enum_descriptor_data());
            enums.push(ItemAttributeKind::generated_enum_descriptor_data());
            enums.push(GeoblockBlockingType::generated_enum_descriptor_data());
            enums.push(op::Kind::generated_enum_descriptor_data());
            enums.push(source_info::Client::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
