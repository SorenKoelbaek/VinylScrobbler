// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `spotify/login5/v3/login5.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.login5.v3.Challenges)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Challenges {
    // message fields
    // @@protoc_insertion_point(field:spotify.login5.v3.Challenges.challenges)
    pub challenges: ::std::vec::Vec<Challenge>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.login5.v3.Challenges.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Challenges {
    fn default() -> &'a Challenges {
        <Challenges as ::protobuf::Message>::default_instance()
    }
}

impl Challenges {
    pub fn new() -> Challenges {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "challenges",
            |m: &Challenges| { &m.challenges },
            |m: &mut Challenges| { &mut m.challenges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Challenges>(
            "Challenges",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Challenges {
    const NAME: &'static str = "Challenges";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.challenges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.challenges {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Challenges {
        Challenges::new()
    }

    fn clear(&mut self) {
        self.challenges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Challenges {
        static instance: Challenges = Challenges {
            challenges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Challenges {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Challenges").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Challenges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Challenges {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.login5.v3.Challenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Challenge {
    // message oneof groups
    pub challenge: ::std::option::Option<challenge::Challenge>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.login5.v3.Challenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Challenge {
    fn default() -> &'a Challenge {
        <Challenge as ::protobuf::Message>::default_instance()
    }
}

impl Challenge {
    pub fn new() -> Challenge {
        ::std::default::Default::default()
    }

    // .spotify.login5.v3.challenges.HashcashChallenge hashcash = 1;

    pub fn hashcash(&self) -> &super::hashcash::HashcashChallenge {
        match self.challenge {
            ::std::option::Option::Some(challenge::Challenge::Hashcash(ref v)) => v,
            _ => <super::hashcash::HashcashChallenge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hashcash(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_hashcash(&self) -> bool {
        match self.challenge {
            ::std::option::Option::Some(challenge::Challenge::Hashcash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hashcash(&mut self, v: super::hashcash::HashcashChallenge) {
        self.challenge = ::std::option::Option::Some(challenge::Challenge::Hashcash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hashcash(&mut self) -> &mut super::hashcash::HashcashChallenge {
        if let ::std::option::Option::Some(challenge::Challenge::Hashcash(_)) = self.challenge {
        } else {
            self.challenge = ::std::option::Option::Some(challenge::Challenge::Hashcash(super::hashcash::HashcashChallenge::new()));
        }
        match self.challenge {
            ::std::option::Option::Some(challenge::Challenge::Hashcash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hashcash(&mut self) -> super::hashcash::HashcashChallenge {
        if self.has_hashcash() {
            match self.challenge.take() {
                ::std::option::Option::Some(challenge::Challenge::Hashcash(v)) => v,
                _ => panic!(),
            }
        } else {
            super::hashcash::HashcashChallenge::new()
        }
    }

    // .spotify.login5.v3.challenges.CodeChallenge code = 2;

    pub fn code(&self) -> &super::code::CodeChallenge {
        match self.challenge {
            ::std::option::Option::Some(challenge::Challenge::Code(ref v)) => v,
            _ => <super::code::CodeChallenge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_code(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        match self.challenge {
            ::std::option::Option::Some(challenge::Challenge::Code(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: super::code::CodeChallenge) {
        self.challenge = ::std::option::Option::Some(challenge::Challenge::Code(v))
    }

    // Mutable pointer to the field.
    pub fn mut_code(&mut self) -> &mut super::code::CodeChallenge {
        if let ::std::option::Option::Some(challenge::Challenge::Code(_)) = self.challenge {
        } else {
            self.challenge = ::std::option::Option::Some(challenge::Challenge::Code(super::code::CodeChallenge::new()));
        }
        match self.challenge {
            ::std::option::Option::Some(challenge::Challenge::Code(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_code(&mut self) -> super::code::CodeChallenge {
        if self.has_code() {
            match self.challenge.take() {
                ::std::option::Option::Some(challenge::Challenge::Code(v)) => v,
                _ => panic!(),
            }
        } else {
            super::code::CodeChallenge::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::hashcash::HashcashChallenge>(
            "hashcash",
            Challenge::has_hashcash,
            Challenge::hashcash,
            Challenge::mut_hashcash,
            Challenge::set_hashcash,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::code::CodeChallenge>(
            "code",
            Challenge::has_code,
            Challenge::code,
            Challenge::mut_code,
            Challenge::set_code,
        ));
        oneofs.push(challenge::Challenge::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Challenge>(
            "Challenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Challenge {
    const NAME: &'static str = "Challenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge = ::std::option::Option::Some(challenge::Challenge::Hashcash(is.read_message()?));
                },
                18 => {
                    self.challenge = ::std::option::Option::Some(challenge::Challenge::Code(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.challenge {
            match v {
                &challenge::Challenge::Hashcash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &challenge::Challenge::Code(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.challenge {
            match v {
                &challenge::Challenge::Hashcash(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &challenge::Challenge::Code(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Challenge {
        Challenge::new()
    }

    fn clear(&mut self) {
        self.challenge = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Challenge {
        static instance: Challenge = Challenge {
            challenge: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Challenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Challenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Challenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Challenge`
pub mod challenge {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.login5.v3.Challenge.challenge)
    pub enum Challenge {
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.Challenge.hashcash)
        Hashcash(super::super::hashcash::HashcashChallenge),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.Challenge.code)
        Code(super::super::code::CodeChallenge),
    }

    impl ::protobuf::Oneof for Challenge {
    }

    impl ::protobuf::OneofFull for Challenge {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Challenge as ::protobuf::MessageFull>::descriptor().oneof_by_name("challenge").unwrap()).clone()
        }
    }

    impl Challenge {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Challenge>("challenge")
        }
    }
}

// @@protoc_insertion_point(message:spotify.login5.v3.ChallengeSolutions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChallengeSolutions {
    // message fields
    // @@protoc_insertion_point(field:spotify.login5.v3.ChallengeSolutions.solutions)
    pub solutions: ::std::vec::Vec<ChallengeSolution>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.login5.v3.ChallengeSolutions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChallengeSolutions {
    fn default() -> &'a ChallengeSolutions {
        <ChallengeSolutions as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeSolutions {
    pub fn new() -> ChallengeSolutions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "solutions",
            |m: &ChallengeSolutions| { &m.solutions },
            |m: &mut ChallengeSolutions| { &mut m.solutions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChallengeSolutions>(
            "ChallengeSolutions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChallengeSolutions {
    const NAME: &'static str = "ChallengeSolutions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.solutions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.solutions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.solutions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChallengeSolutions {
        ChallengeSolutions::new()
    }

    fn clear(&mut self) {
        self.solutions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChallengeSolutions {
        static instance: ChallengeSolutions = ChallengeSolutions {
            solutions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChallengeSolutions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChallengeSolutions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChallengeSolutions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeSolutions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.login5.v3.ChallengeSolution)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChallengeSolution {
    // message oneof groups
    pub solution: ::std::option::Option<challenge_solution::Solution>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.login5.v3.ChallengeSolution.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChallengeSolution {
    fn default() -> &'a ChallengeSolution {
        <ChallengeSolution as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeSolution {
    pub fn new() -> ChallengeSolution {
        ::std::default::Default::default()
    }

    // .spotify.login5.v3.challenges.HashcashSolution hashcash = 1;

    pub fn hashcash(&self) -> &super::hashcash::HashcashSolution {
        match self.solution {
            ::std::option::Option::Some(challenge_solution::Solution::Hashcash(ref v)) => v,
            _ => <super::hashcash::HashcashSolution as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hashcash(&mut self) {
        self.solution = ::std::option::Option::None;
    }

    pub fn has_hashcash(&self) -> bool {
        match self.solution {
            ::std::option::Option::Some(challenge_solution::Solution::Hashcash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hashcash(&mut self, v: super::hashcash::HashcashSolution) {
        self.solution = ::std::option::Option::Some(challenge_solution::Solution::Hashcash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hashcash(&mut self) -> &mut super::hashcash::HashcashSolution {
        if let ::std::option::Option::Some(challenge_solution::Solution::Hashcash(_)) = self.solution {
        } else {
            self.solution = ::std::option::Option::Some(challenge_solution::Solution::Hashcash(super::hashcash::HashcashSolution::new()));
        }
        match self.solution {
            ::std::option::Option::Some(challenge_solution::Solution::Hashcash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hashcash(&mut self) -> super::hashcash::HashcashSolution {
        if self.has_hashcash() {
            match self.solution.take() {
                ::std::option::Option::Some(challenge_solution::Solution::Hashcash(v)) => v,
                _ => panic!(),
            }
        } else {
            super::hashcash::HashcashSolution::new()
        }
    }

    // .spotify.login5.v3.challenges.CodeSolution code = 2;

    pub fn code(&self) -> &super::code::CodeSolution {
        match self.solution {
            ::std::option::Option::Some(challenge_solution::Solution::Code(ref v)) => v,
            _ => <super::code::CodeSolution as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_code(&mut self) {
        self.solution = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        match self.solution {
            ::std::option::Option::Some(challenge_solution::Solution::Code(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: super::code::CodeSolution) {
        self.solution = ::std::option::Option::Some(challenge_solution::Solution::Code(v))
    }

    // Mutable pointer to the field.
    pub fn mut_code(&mut self) -> &mut super::code::CodeSolution {
        if let ::std::option::Option::Some(challenge_solution::Solution::Code(_)) = self.solution {
        } else {
            self.solution = ::std::option::Option::Some(challenge_solution::Solution::Code(super::code::CodeSolution::new()));
        }
        match self.solution {
            ::std::option::Option::Some(challenge_solution::Solution::Code(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_code(&mut self) -> super::code::CodeSolution {
        if self.has_code() {
            match self.solution.take() {
                ::std::option::Option::Some(challenge_solution::Solution::Code(v)) => v,
                _ => panic!(),
            }
        } else {
            super::code::CodeSolution::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::hashcash::HashcashSolution>(
            "hashcash",
            ChallengeSolution::has_hashcash,
            ChallengeSolution::hashcash,
            ChallengeSolution::mut_hashcash,
            ChallengeSolution::set_hashcash,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::code::CodeSolution>(
            "code",
            ChallengeSolution::has_code,
            ChallengeSolution::code,
            ChallengeSolution::mut_code,
            ChallengeSolution::set_code,
        ));
        oneofs.push(challenge_solution::Solution::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChallengeSolution>(
            "ChallengeSolution",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChallengeSolution {
    const NAME: &'static str = "ChallengeSolution";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.solution = ::std::option::Option::Some(challenge_solution::Solution::Hashcash(is.read_message()?));
                },
                18 => {
                    self.solution = ::std::option::Option::Some(challenge_solution::Solution::Code(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.solution {
            match v {
                &challenge_solution::Solution::Hashcash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &challenge_solution::Solution::Code(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.solution {
            match v {
                &challenge_solution::Solution::Hashcash(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &challenge_solution::Solution::Code(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChallengeSolution {
        ChallengeSolution::new()
    }

    fn clear(&mut self) {
        self.solution = ::std::option::Option::None;
        self.solution = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChallengeSolution {
        static instance: ChallengeSolution = ChallengeSolution {
            solution: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChallengeSolution {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChallengeSolution").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChallengeSolution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeSolution {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ChallengeSolution`
pub mod challenge_solution {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.login5.v3.ChallengeSolution.solution)
    pub enum Solution {
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.ChallengeSolution.hashcash)
        Hashcash(super::super::hashcash::HashcashSolution),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.ChallengeSolution.code)
        Code(super::super::code::CodeSolution),
    }

    impl ::protobuf::Oneof for Solution {
    }

    impl ::protobuf::OneofFull for Solution {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ChallengeSolution as ::protobuf::MessageFull>::descriptor().oneof_by_name("solution").unwrap()).clone()
        }
    }

    impl Solution {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Solution>("solution")
        }
    }
}

// @@protoc_insertion_point(message:spotify.login5.v3.LoginRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginRequest.client_info)
    pub client_info: ::protobuf::MessageField<super::client_info::ClientInfo>,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginRequest.login_context)
    pub login_context: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginRequest.challenge_solutions)
    pub challenge_solutions: ::protobuf::MessageField<ChallengeSolutions>,
    // message oneof groups
    pub login_method: ::std::option::Option<login_request::Login_method>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.login5.v3.LoginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginRequest {
    fn default() -> &'a LoginRequest {
        <LoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoginRequest {
    pub fn new() -> LoginRequest {
        ::std::default::Default::default()
    }

    // .spotify.login5.v3.credentials.StoredCredential stored_credential = 100;

    pub fn stored_credential(&self) -> &super::credentials::StoredCredential {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::StoredCredential(ref v)) => v,
            _ => <super::credentials::StoredCredential as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stored_credential(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_stored_credential(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::StoredCredential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stored_credential(&mut self, v: super::credentials::StoredCredential) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::StoredCredential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stored_credential(&mut self) -> &mut super::credentials::StoredCredential {
        if let ::std::option::Option::Some(login_request::Login_method::StoredCredential(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::StoredCredential(super::credentials::StoredCredential::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::StoredCredential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stored_credential(&mut self) -> super::credentials::StoredCredential {
        if self.has_stored_credential() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::StoredCredential(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::StoredCredential::new()
        }
    }

    // .spotify.login5.v3.credentials.Password password = 101;

    pub fn password(&self) -> &super::credentials::Password {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::Password(ref v)) => v,
            _ => <super::credentials::Password as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_password(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::Password(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: super::credentials::Password) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::Password(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password(&mut self) -> &mut super::credentials::Password {
        if let ::std::option::Option::Some(login_request::Login_method::Password(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::Password(super::credentials::Password::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::Password(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password(&mut self) -> super::credentials::Password {
        if self.has_password() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::Password(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::Password::new()
        }
    }

    // .spotify.login5.v3.credentials.FacebookAccessToken facebook_access_token = 102;

    pub fn facebook_access_token(&self) -> &super::credentials::FacebookAccessToken {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(ref v)) => v,
            _ => <super::credentials::FacebookAccessToken as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_facebook_access_token(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_facebook_access_token(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_facebook_access_token(&mut self, v: super::credentials::FacebookAccessToken) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(v))
    }

    // Mutable pointer to the field.
    pub fn mut_facebook_access_token(&mut self) -> &mut super::credentials::FacebookAccessToken {
        if let ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(super::credentials::FacebookAccessToken::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_facebook_access_token(&mut self) -> super::credentials::FacebookAccessToken {
        if self.has_facebook_access_token() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::FacebookAccessToken::new()
        }
    }

    // .spotify.login5.v3.identifiers.PhoneNumber phone_number = 103;

    pub fn phone_number(&self) -> &super::identifiers::PhoneNumber {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::PhoneNumber(ref v)) => v,
            _ => <super::identifiers::PhoneNumber as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_phone_number(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_phone_number(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::PhoneNumber(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_phone_number(&mut self, v: super::identifiers::PhoneNumber) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::PhoneNumber(v))
    }

    // Mutable pointer to the field.
    pub fn mut_phone_number(&mut self) -> &mut super::identifiers::PhoneNumber {
        if let ::std::option::Option::Some(login_request::Login_method::PhoneNumber(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::PhoneNumber(super::identifiers::PhoneNumber::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::PhoneNumber(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_phone_number(&mut self) -> super::identifiers::PhoneNumber {
        if self.has_phone_number() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::PhoneNumber(v)) => v,
                _ => panic!(),
            }
        } else {
            super::identifiers::PhoneNumber::new()
        }
    }

    // .spotify.login5.v3.credentials.OneTimeToken one_time_token = 104;

    pub fn one_time_token(&self) -> &super::credentials::OneTimeToken {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::OneTimeToken(ref v)) => v,
            _ => <super::credentials::OneTimeToken as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_one_time_token(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_one_time_token(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::OneTimeToken(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_one_time_token(&mut self, v: super::credentials::OneTimeToken) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::OneTimeToken(v))
    }

    // Mutable pointer to the field.
    pub fn mut_one_time_token(&mut self) -> &mut super::credentials::OneTimeToken {
        if let ::std::option::Option::Some(login_request::Login_method::OneTimeToken(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::OneTimeToken(super::credentials::OneTimeToken::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::OneTimeToken(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_one_time_token(&mut self) -> super::credentials::OneTimeToken {
        if self.has_one_time_token() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::OneTimeToken(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::OneTimeToken::new()
        }
    }

    // .spotify.login5.v3.credentials.ParentChildCredential parent_child_credential = 105;

    pub fn parent_child_credential(&self) -> &super::credentials::ParentChildCredential {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(ref v)) => v,
            _ => <super::credentials::ParentChildCredential as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_parent_child_credential(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_parent_child_credential(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_child_credential(&mut self, v: super::credentials::ParentChildCredential) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_child_credential(&mut self) -> &mut super::credentials::ParentChildCredential {
        if let ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(super::credentials::ParentChildCredential::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_child_credential(&mut self) -> super::credentials::ParentChildCredential {
        if self.has_parent_child_credential() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::ParentChildCredential::new()
        }
    }

    // .spotify.login5.v3.credentials.AppleSignInCredential apple_sign_in_credential = 106;

    pub fn apple_sign_in_credential(&self) -> &super::credentials::AppleSignInCredential {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(ref v)) => v,
            _ => <super::credentials::AppleSignInCredential as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_apple_sign_in_credential(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_apple_sign_in_credential(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apple_sign_in_credential(&mut self, v: super::credentials::AppleSignInCredential) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apple_sign_in_credential(&mut self) -> &mut super::credentials::AppleSignInCredential {
        if let ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(super::credentials::AppleSignInCredential::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apple_sign_in_credential(&mut self) -> super::credentials::AppleSignInCredential {
        if self.has_apple_sign_in_credential() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::AppleSignInCredential::new()
        }
    }

    // .spotify.login5.v3.credentials.SamsungSignInCredential samsung_sign_in_credential = 107;

    pub fn samsung_sign_in_credential(&self) -> &super::credentials::SamsungSignInCredential {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(ref v)) => v,
            _ => <super::credentials::SamsungSignInCredential as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_samsung_sign_in_credential(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_samsung_sign_in_credential(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_samsung_sign_in_credential(&mut self, v: super::credentials::SamsungSignInCredential) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_samsung_sign_in_credential(&mut self) -> &mut super::credentials::SamsungSignInCredential {
        if let ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(super::credentials::SamsungSignInCredential::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_samsung_sign_in_credential(&mut self) -> super::credentials::SamsungSignInCredential {
        if self.has_samsung_sign_in_credential() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::SamsungSignInCredential::new()
        }
    }

    // .spotify.login5.v3.credentials.GoogleSignInCredential google_sign_in_credential = 108;

    pub fn google_sign_in_credential(&self) -> &super::credentials::GoogleSignInCredential {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(ref v)) => v,
            _ => <super::credentials::GoogleSignInCredential as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_google_sign_in_credential(&mut self) {
        self.login_method = ::std::option::Option::None;
    }

    pub fn has_google_sign_in_credential(&self) -> bool {
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_google_sign_in_credential(&mut self, v: super::credentials::GoogleSignInCredential) {
        self.login_method = ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(v))
    }

    // Mutable pointer to the field.
    pub fn mut_google_sign_in_credential(&mut self) -> &mut super::credentials::GoogleSignInCredential {
        if let ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(_)) = self.login_method {
        } else {
            self.login_method = ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(super::credentials::GoogleSignInCredential::new()));
        }
        match self.login_method {
            ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_google_sign_in_credential(&mut self) -> super::credentials::GoogleSignInCredential {
        if self.has_google_sign_in_credential() {
            match self.login_method.take() {
                ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(v)) => v,
                _ => panic!(),
            }
        } else {
            super::credentials::GoogleSignInCredential::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::client_info::ClientInfo>(
            "client_info",
            |m: &LoginRequest| { &m.client_info },
            |m: &mut LoginRequest| { &mut m.client_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "login_context",
            |m: &LoginRequest| { &m.login_context },
            |m: &mut LoginRequest| { &mut m.login_context },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ChallengeSolutions>(
            "challenge_solutions",
            |m: &LoginRequest| { &m.challenge_solutions },
            |m: &mut LoginRequest| { &mut m.challenge_solutions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::StoredCredential>(
            "stored_credential",
            LoginRequest::has_stored_credential,
            LoginRequest::stored_credential,
            LoginRequest::mut_stored_credential,
            LoginRequest::set_stored_credential,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::Password>(
            "password",
            LoginRequest::has_password,
            LoginRequest::password,
            LoginRequest::mut_password,
            LoginRequest::set_password,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::FacebookAccessToken>(
            "facebook_access_token",
            LoginRequest::has_facebook_access_token,
            LoginRequest::facebook_access_token,
            LoginRequest::mut_facebook_access_token,
            LoginRequest::set_facebook_access_token,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::identifiers::PhoneNumber>(
            "phone_number",
            LoginRequest::has_phone_number,
            LoginRequest::phone_number,
            LoginRequest::mut_phone_number,
            LoginRequest::set_phone_number,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::OneTimeToken>(
            "one_time_token",
            LoginRequest::has_one_time_token,
            LoginRequest::one_time_token,
            LoginRequest::mut_one_time_token,
            LoginRequest::set_one_time_token,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::ParentChildCredential>(
            "parent_child_credential",
            LoginRequest::has_parent_child_credential,
            LoginRequest::parent_child_credential,
            LoginRequest::mut_parent_child_credential,
            LoginRequest::set_parent_child_credential,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::AppleSignInCredential>(
            "apple_sign_in_credential",
            LoginRequest::has_apple_sign_in_credential,
            LoginRequest::apple_sign_in_credential,
            LoginRequest::mut_apple_sign_in_credential,
            LoginRequest::set_apple_sign_in_credential,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::SamsungSignInCredential>(
            "samsung_sign_in_credential",
            LoginRequest::has_samsung_sign_in_credential,
            LoginRequest::samsung_sign_in_credential,
            LoginRequest::mut_samsung_sign_in_credential,
            LoginRequest::set_samsung_sign_in_credential,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::credentials::GoogleSignInCredential>(
            "google_sign_in_credential",
            LoginRequest::has_google_sign_in_credential,
            LoginRequest::google_sign_in_credential,
            LoginRequest::mut_google_sign_in_credential,
            LoginRequest::set_google_sign_in_credential,
        ));
        oneofs.push(login_request::Login_method::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginRequest>(
            "LoginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginRequest {
    const NAME: &'static str = "LoginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.client_info)?;
                },
                18 => {
                    self.login_context = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.challenge_solutions)?;
                },
                802 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::StoredCredential(is.read_message()?));
                },
                810 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::Password(is.read_message()?));
                },
                818 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::FacebookAccessToken(is.read_message()?));
                },
                826 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::PhoneNumber(is.read_message()?));
                },
                834 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::OneTimeToken(is.read_message()?));
                },
                842 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::ParentChildCredential(is.read_message()?));
                },
                850 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::AppleSignInCredential(is.read_message()?));
                },
                858 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::SamsungSignInCredential(is.read_message()?));
                },
                866 => {
                    self.login_method = ::std::option::Option::Some(login_request::Login_method::GoogleSignInCredential(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.login_context.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.login_context);
        }
        if let Some(v) = self.challenge_solutions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.login_method {
            match v {
                &login_request::Login_method::StoredCredential(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::Password(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::FacebookAccessToken(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::PhoneNumber(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::OneTimeToken(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::ParentChildCredential(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::AppleSignInCredential(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::SamsungSignInCredential(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Login_method::GoogleSignInCredential(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.login_context.is_empty() {
            os.write_bytes(2, &self.login_context)?;
        }
        if let Some(v) = self.challenge_solutions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.login_method {
            match v {
                &login_request::Login_method::StoredCredential(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
                },
                &login_request::Login_method::Password(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(101, v, os)?;
                },
                &login_request::Login_method::FacebookAccessToken(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(102, v, os)?;
                },
                &login_request::Login_method::PhoneNumber(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(103, v, os)?;
                },
                &login_request::Login_method::OneTimeToken(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(104, v, os)?;
                },
                &login_request::Login_method::ParentChildCredential(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(105, v, os)?;
                },
                &login_request::Login_method::AppleSignInCredential(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(106, v, os)?;
                },
                &login_request::Login_method::SamsungSignInCredential(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(107, v, os)?;
                },
                &login_request::Login_method::GoogleSignInCredential(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(108, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginRequest {
        LoginRequest::new()
    }

    fn clear(&mut self) {
        self.client_info.clear();
        self.login_context.clear();
        self.challenge_solutions.clear();
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.login_method = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginRequest {
        static instance: LoginRequest = LoginRequest {
            client_info: ::protobuf::MessageField::none(),
            login_context: ::std::vec::Vec::new(),
            challenge_solutions: ::protobuf::MessageField::none(),
            login_method: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginRequest`
pub mod login_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.login5.v3.LoginRequest.login_method)
    pub enum Login_method {
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.stored_credential)
        StoredCredential(super::super::credentials::StoredCredential),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.password)
        Password(super::super::credentials::Password),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.facebook_access_token)
        FacebookAccessToken(super::super::credentials::FacebookAccessToken),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.phone_number)
        PhoneNumber(super::super::identifiers::PhoneNumber),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.one_time_token)
        OneTimeToken(super::super::credentials::OneTimeToken),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.parent_child_credential)
        ParentChildCredential(super::super::credentials::ParentChildCredential),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.apple_sign_in_credential)
        AppleSignInCredential(super::super::credentials::AppleSignInCredential),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.samsung_sign_in_credential)
        SamsungSignInCredential(super::super::credentials::SamsungSignInCredential),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginRequest.google_sign_in_credential)
        GoogleSignInCredential(super::super::credentials::GoogleSignInCredential),
    }

    impl ::protobuf::Oneof for Login_method {
    }

    impl ::protobuf::OneofFull for Login_method {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoginRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("login_method").unwrap()).clone()
        }
    }

    impl Login_method {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Login_method>("login_method")
        }
    }
}

// @@protoc_insertion_point(message:spotify.login5.v3.LoginOk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginOk {
    // message fields
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginOk.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginOk.access_token)
    pub access_token: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginOk.stored_credential)
    pub stored_credential: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginOk.access_token_expires_in)
    pub access_token_expires_in: i32,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.login5.v3.LoginOk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginOk {
    fn default() -> &'a LoginOk {
        <LoginOk as ::protobuf::Message>::default_instance()
    }
}

impl LoginOk {
    pub fn new() -> LoginOk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &LoginOk| { &m.username },
            |m: &mut LoginOk| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &LoginOk| { &m.access_token },
            |m: &mut LoginOk| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stored_credential",
            |m: &LoginOk| { &m.stored_credential },
            |m: &mut LoginOk| { &mut m.stored_credential },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token_expires_in",
            |m: &LoginOk| { &m.access_token_expires_in },
            |m: &mut LoginOk| { &mut m.access_token_expires_in },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginOk>(
            "LoginOk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginOk {
    const NAME: &'static str = "LoginOk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.access_token = is.read_string()?;
                },
                26 => {
                    self.stored_credential = is.read_bytes()?;
                },
                32 => {
                    self.access_token_expires_in = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.access_token);
        }
        if !self.stored_credential.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.stored_credential);
        }
        if self.access_token_expires_in != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.access_token_expires_in);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(2, &self.access_token)?;
        }
        if !self.stored_credential.is_empty() {
            os.write_bytes(3, &self.stored_credential)?;
        }
        if self.access_token_expires_in != 0 {
            os.write_int32(4, self.access_token_expires_in)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginOk {
        LoginOk::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.access_token.clear();
        self.stored_credential.clear();
        self.access_token_expires_in = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginOk {
        static instance: LoginOk = LoginOk {
            username: ::std::string::String::new(),
            access_token: ::std::string::String::new(),
            stored_credential: ::std::vec::Vec::new(),
            access_token_expires_in: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginOk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginOk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginOk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginOk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.login5.v3.LoginResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginResponse.warnings)
    pub warnings: ::std::vec::Vec<::protobuf::EnumOrUnknown<login_response::Warnings>>,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginResponse.login_context)
    pub login_context: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginResponse.identifier_token)
    pub identifier_token: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.login5.v3.LoginResponse.user_info)
    pub user_info: ::protobuf::MessageField<super::user_info::UserInfo>,
    // message oneof groups
    pub response: ::std::option::Option<login_response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.login5.v3.LoginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginResponse {
    fn default() -> &'a LoginResponse {
        <LoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginResponse {
    pub fn new() -> LoginResponse {
        ::std::default::Default::default()
    }

    // .spotify.login5.v3.LoginOk ok = 1;

    pub fn ok(&self) -> &LoginOk {
        match self.response {
            ::std::option::Option::Some(login_response::Response::Ok(ref v)) => v,
            _ => <LoginOk as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ok(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_ok(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(login_response::Response::Ok(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: LoginOk) {
        self.response = ::std::option::Option::Some(login_response::Response::Ok(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ok(&mut self) -> &mut LoginOk {
        if let ::std::option::Option::Some(login_response::Response::Ok(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(login_response::Response::Ok(LoginOk::new()));
        }
        match self.response {
            ::std::option::Option::Some(login_response::Response::Ok(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ok(&mut self) -> LoginOk {
        if self.has_ok() {
            match self.response.take() {
                ::std::option::Option::Some(login_response::Response::Ok(v)) => v,
                _ => panic!(),
            }
        } else {
            LoginOk::new()
        }
    }

    // .spotify.login5.v3.LoginError error = 2;

    pub fn error(&self) -> LoginError {
        match self.response {
            ::std::option::Option::Some(login_response::Response::Error(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => LoginError::UNKNOWN_ERROR,
        }
    }

    pub fn clear_error(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(login_response::Response::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: LoginError) {
        self.response = ::std::option::Option::Some(login_response::Response::Error(::protobuf::EnumOrUnknown::new(v)))
    }

    // .spotify.login5.v3.Challenges challenges = 3;

    pub fn challenges(&self) -> &Challenges {
        match self.response {
            ::std::option::Option::Some(login_response::Response::Challenges(ref v)) => v,
            _ => <Challenges as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_challenges(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_challenges(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(login_response::Response::Challenges(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_challenges(&mut self, v: Challenges) {
        self.response = ::std::option::Option::Some(login_response::Response::Challenges(v))
    }

    // Mutable pointer to the field.
    pub fn mut_challenges(&mut self) -> &mut Challenges {
        if let ::std::option::Option::Some(login_response::Response::Challenges(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(login_response::Response::Challenges(Challenges::new()));
        }
        match self.response {
            ::std::option::Option::Some(login_response::Response::Challenges(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_challenges(&mut self) -> Challenges {
        if self.has_challenges() {
            match self.response.take() {
                ::std::option::Option::Some(login_response::Response::Challenges(v)) => v,
                _ => panic!(),
            }
        } else {
            Challenges::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "warnings",
            |m: &LoginResponse| { &m.warnings },
            |m: &mut LoginResponse| { &mut m.warnings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "login_context",
            |m: &LoginResponse| { &m.login_context },
            |m: &mut LoginResponse| { &mut m.login_context },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "identifier_token",
            |m: &LoginResponse| { &m.identifier_token },
            |m: &mut LoginResponse| { &mut m.identifier_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::user_info::UserInfo>(
            "user_info",
            |m: &LoginResponse| { &m.user_info },
            |m: &mut LoginResponse| { &mut m.user_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LoginOk>(
            "ok",
            LoginResponse::has_ok,
            LoginResponse::ok,
            LoginResponse::mut_ok,
            LoginResponse::set_ok,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "error",
            |message: &LoginResponse| match &message.response {
                ::std::option::Option::Some(login_response::Response::Error(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LoginResponse, e: ::protobuf::EnumOrUnknown<LoginError>| {
                message.response = ::std::option::Option::Some(login_response::Response::Error(e));
            },
            LoginError::UNKNOWN_ERROR,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Challenges>(
            "challenges",
            LoginResponse::has_challenges,
            LoginResponse::challenges,
            LoginResponse::mut_challenges,
            LoginResponse::set_challenges,
        ));
        oneofs.push(login_response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginResponse>(
            "LoginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginResponse {
    const NAME: &'static str = "LoginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.warnings.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.warnings)?
                },
                42 => {
                    self.login_context = is.read_bytes()?;
                },
                50 => {
                    self.identifier_token = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_info)?;
                },
                10 => {
                    self.response = ::std::option::Option::Some(login_response::Response::Ok(is.read_message()?));
                },
                16 => {
                    self.response = ::std::option::Option::Some(login_response::Response::Error(is.read_enum_or_unknown()?));
                },
                26 => {
                    self.response = ::std::option::Option::Some(login_response::Response::Challenges(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(4, &self.warnings);
        if !self.login_context.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.login_context);
        }
        if !self.identifier_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.identifier_token);
        }
        if let Some(v) = self.user_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &login_response::Response::Ok(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_response::Response::Error(v) => {
                    my_size += ::protobuf::rt::int32_size(2, v.value());
                },
                &login_response::Response::Challenges(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_enum_or_unknown(4, &self.warnings)?;
        if !self.login_context.is_empty() {
            os.write_bytes(5, &self.login_context)?;
        }
        if !self.identifier_token.is_empty() {
            os.write_string(6, &self.identifier_token)?;
        }
        if let Some(v) = self.user_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &login_response::Response::Ok(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &login_response::Response::Error(v) => {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &login_response::Response::Challenges(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginResponse {
        LoginResponse::new()
    }

    fn clear(&mut self) {
        self.warnings.clear();
        self.login_context.clear();
        self.identifier_token.clear();
        self.user_info.clear();
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginResponse {
        static instance: LoginResponse = LoginResponse {
            warnings: ::std::vec::Vec::new(),
            login_context: ::std::vec::Vec::new(),
            identifier_token: ::std::string::String::new(),
            user_info: ::protobuf::MessageField::none(),
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginResponse`
pub mod login_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.login5.v3.LoginResponse.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginResponse.ok)
        Ok(super::LoginOk),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginResponse.error)
        Error(::protobuf::EnumOrUnknown<super::LoginError>),
        // @@protoc_insertion_point(oneof_field:spotify.login5.v3.LoginResponse.challenges)
        Challenges(super::Challenges),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoginResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:spotify.login5.v3.LoginResponse.Warnings)
    pub enum Warnings {
        // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginResponse.Warnings.UNKNOWN_WARNING)
        UNKNOWN_WARNING = 0,
        // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginResponse.Warnings.DEPRECATED_PROTOCOL_VERSION)
        DEPRECATED_PROTOCOL_VERSION = 1,
    }

    impl ::protobuf::Enum for Warnings {
        const NAME: &'static str = "Warnings";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Warnings> {
            match value {
                0 => ::std::option::Option::Some(Warnings::UNKNOWN_WARNING),
                1 => ::std::option::Option::Some(Warnings::DEPRECATED_PROTOCOL_VERSION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Warnings> {
            match str {
                "UNKNOWN_WARNING" => ::std::option::Option::Some(Warnings::UNKNOWN_WARNING),
                "DEPRECATED_PROTOCOL_VERSION" => ::std::option::Option::Some(Warnings::DEPRECATED_PROTOCOL_VERSION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Warnings] = &[
            Warnings::UNKNOWN_WARNING,
            Warnings::DEPRECATED_PROTOCOL_VERSION,
        ];
    }

    impl ::protobuf::EnumFull for Warnings {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("LoginResponse.Warnings").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Warnings {
        fn default() -> Self {
            Warnings::UNKNOWN_WARNING
        }
    }

    impl Warnings {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Warnings>("LoginResponse.Warnings")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.login5.v3.LoginError)
pub enum LoginError {
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.UNKNOWN_ERROR)
    UNKNOWN_ERROR = 0,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.INVALID_CREDENTIALS)
    INVALID_CREDENTIALS = 1,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.BAD_REQUEST)
    BAD_REQUEST = 2,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.UNSUPPORTED_LOGIN_PROTOCOL)
    UNSUPPORTED_LOGIN_PROTOCOL = 3,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.TIMEOUT)
    TIMEOUT = 4,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.UNKNOWN_IDENTIFIER)
    UNKNOWN_IDENTIFIER = 5,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.TOO_MANY_ATTEMPTS)
    TOO_MANY_ATTEMPTS = 6,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.INVALID_PHONENUMBER)
    INVALID_PHONENUMBER = 7,
    // @@protoc_insertion_point(enum_value:spotify.login5.v3.LoginError.TRY_AGAIN_LATER)
    TRY_AGAIN_LATER = 8,
}

impl ::protobuf::Enum for LoginError {
    const NAME: &'static str = "LoginError";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LoginError> {
        match value {
            0 => ::std::option::Option::Some(LoginError::UNKNOWN_ERROR),
            1 => ::std::option::Option::Some(LoginError::INVALID_CREDENTIALS),
            2 => ::std::option::Option::Some(LoginError::BAD_REQUEST),
            3 => ::std::option::Option::Some(LoginError::UNSUPPORTED_LOGIN_PROTOCOL),
            4 => ::std::option::Option::Some(LoginError::TIMEOUT),
            5 => ::std::option::Option::Some(LoginError::UNKNOWN_IDENTIFIER),
            6 => ::std::option::Option::Some(LoginError::TOO_MANY_ATTEMPTS),
            7 => ::std::option::Option::Some(LoginError::INVALID_PHONENUMBER),
            8 => ::std::option::Option::Some(LoginError::TRY_AGAIN_LATER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LoginError> {
        match str {
            "UNKNOWN_ERROR" => ::std::option::Option::Some(LoginError::UNKNOWN_ERROR),
            "INVALID_CREDENTIALS" => ::std::option::Option::Some(LoginError::INVALID_CREDENTIALS),
            "BAD_REQUEST" => ::std::option::Option::Some(LoginError::BAD_REQUEST),
            "UNSUPPORTED_LOGIN_PROTOCOL" => ::std::option::Option::Some(LoginError::UNSUPPORTED_LOGIN_PROTOCOL),
            "TIMEOUT" => ::std::option::Option::Some(LoginError::TIMEOUT),
            "UNKNOWN_IDENTIFIER" => ::std::option::Option::Some(LoginError::UNKNOWN_IDENTIFIER),
            "TOO_MANY_ATTEMPTS" => ::std::option::Option::Some(LoginError::TOO_MANY_ATTEMPTS),
            "INVALID_PHONENUMBER" => ::std::option::Option::Some(LoginError::INVALID_PHONENUMBER),
            "TRY_AGAIN_LATER" => ::std::option::Option::Some(LoginError::TRY_AGAIN_LATER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LoginError] = &[
        LoginError::UNKNOWN_ERROR,
        LoginError::INVALID_CREDENTIALS,
        LoginError::BAD_REQUEST,
        LoginError::UNSUPPORTED_LOGIN_PROTOCOL,
        LoginError::TIMEOUT,
        LoginError::UNKNOWN_IDENTIFIER,
        LoginError::TOO_MANY_ATTEMPTS,
        LoginError::INVALID_PHONENUMBER,
        LoginError::TRY_AGAIN_LATER,
    ];
}

impl ::protobuf::EnumFull for LoginError {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LoginError").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LoginError {
    fn default() -> Self {
        LoginError::UNKNOWN_ERROR
    }
}

impl LoginError {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LoginError>("LoginError")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1espotify/login5/v3/login5.proto\x12\x11spotify.login5.v3\x1a#spotif\
    y/login5/v3/client_info.proto\x1a!spotify/login5/v3/user_info.proto\x1a'\
    spotify/login5/v3/challenges/code.proto\x1a+spotify/login5/v3/challenges\
    /hashcash.proto\x1a/spotify/login5/v3/credentials/credentials.proto\x1a/\
    spotify/login5/v3/identifiers/identifiers.proto\"J\n\nChallenges\x12<\n\
    \nchallenges\x18\x01\x20\x03(\x0b2\x1c.spotify.login5.v3.ChallengeR\ncha\
    llenges\"\xaa\x01\n\tChallenge\x12M\n\x08hashcash\x18\x01\x20\x01(\x0b2/\
    .spotify.login5.v3.challenges.HashcashChallengeH\0R\x08hashcash\x12A\n\
    \x04code\x18\x02\x20\x01(\x0b2+.spotify.login5.v3.challenges.CodeChallen\
    geH\0R\x04codeB\x0b\n\tchallenge\"X\n\x12ChallengeSolutions\x12B\n\tsolu\
    tions\x18\x01\x20\x03(\x0b2$.spotify.login5.v3.ChallengeSolutionR\tsolut\
    ions\"\xaf\x01\n\x11ChallengeSolution\x12L\n\x08hashcash\x18\x01\x20\x01\
    (\x0b2..spotify.login5.v3.challenges.HashcashSolutionH\0R\x08hashcash\
    \x12@\n\x04code\x18\x02\x20\x01(\x0b2*.spotify.login5.v3.challenges.Code\
    SolutionH\0R\x04codeB\n\n\x08solution\"\xde\x08\n\x0cLoginRequest\x12>\n\
    \x0bclient_info\x18\x01\x20\x01(\x0b2\x1d.spotify.login5.v3.ClientInfoR\
    \nclientInfo\x12#\n\rlogin_context\x18\x02\x20\x01(\x0cR\x0cloginContext\
    \x12V\n\x13challenge_solutions\x18\x03\x20\x01(\x0b2%.spotify.login5.v3.\
    ChallengeSolutionsR\x12challengeSolutions\x12^\n\x11stored_credential\
    \x18d\x20\x01(\x0b2/.spotify.login5.v3.credentials.StoredCredentialH\0R\
    \x10storedCredential\x12E\n\x08password\x18e\x20\x01(\x0b2'.spotify.logi\
    n5.v3.credentials.PasswordH\0R\x08password\x12h\n\x15facebook_access_tok\
    en\x18f\x20\x01(\x0b22.spotify.login5.v3.credentials.FacebookAccessToken\
    H\0R\x13facebookAccessToken\x12O\n\x0cphone_number\x18g\x20\x01(\x0b2*.s\
    potify.login5.v3.identifiers.PhoneNumberH\0R\x0bphoneNumber\x12S\n\x0eon\
    e_time_token\x18h\x20\x01(\x0b2+.spotify.login5.v3.credentials.OneTimeTo\
    kenH\0R\x0coneTimeToken\x12n\n\x17parent_child_credential\x18i\x20\x01(\
    \x0b24.spotify.login5.v3.credentials.ParentChildCredentialH\0R\x15parent\
    ChildCredential\x12o\n\x18apple_sign_in_credential\x18j\x20\x01(\x0b24.s\
    potify.login5.v3.credentials.AppleSignInCredentialH\0R\x15appleSignInCre\
    dential\x12u\n\x1asamsung_sign_in_credential\x18k\x20\x01(\x0b26.spotify\
    .login5.v3.credentials.SamsungSignInCredentialH\0R\x17samsungSignInCrede\
    ntial\x12r\n\x19google_sign_in_credential\x18l\x20\x01(\x0b25.spotify.lo\
    gin5.v3.credentials.GoogleSignInCredentialH\0R\x16googleSignInCredential\
    B\x0e\n\x0clogin_method\"\xac\x01\n\x07LoginOk\x12\x1a\n\x08username\x18\
    \x01\x20\x01(\tR\x08username\x12!\n\x0caccess_token\x18\x02\x20\x01(\tR\
    \x0baccessToken\x12+\n\x11stored_credential\x18\x03\x20\x01(\x0cR\x10sto\
    redCredential\x125\n\x17access_token_expires_in\x18\x04\x20\x01(\x05R\
    \x14accessTokenExpiresIn\"\xd4\x03\n\rLoginResponse\x12E\n\x08warnings\
    \x18\x04\x20\x03(\x0e2).spotify.login5.v3.LoginResponse.WarningsR\x08war\
    nings\x12#\n\rlogin_context\x18\x05\x20\x01(\x0cR\x0cloginContext\x12)\n\
    \x10identifier_token\x18\x06\x20\x01(\tR\x0fidentifierToken\x128\n\tuser\
    _info\x18\x07\x20\x01(\x0b2\x1b.spotify.login5.v3.UserInfoR\x08userInfo\
    \x12,\n\x02ok\x18\x01\x20\x01(\x0b2\x1a.spotify.login5.v3.LoginOkH\0R\
    \x02ok\x125\n\x05error\x18\x02\x20\x01(\x0e2\x1d.spotify.login5.v3.Login\
    ErrorH\0R\x05error\x12?\n\nchallenges\x18\x03\x20\x01(\x0b2\x1d.spotify.\
    login5.v3.ChallengesH\0R\nchallenges\"@\n\x08Warnings\x12\x13\n\x0fUNKNO\
    WN_WARNING\x10\0\x12\x1f\n\x1bDEPRECATED_PROTOCOL_VERSION\x10\x01B\n\n\
    \x08response*\xd3\x01\n\nLoginError\x12\x11\n\rUNKNOWN_ERROR\x10\0\x12\
    \x17\n\x13INVALID_CREDENTIALS\x10\x01\x12\x0f\n\x0bBAD_REQUEST\x10\x02\
    \x12\x1e\n\x1aUNSUPPORTED_LOGIN_PROTOCOL\x10\x03\x12\x0b\n\x07TIMEOUT\
    \x10\x04\x12\x16\n\x12UNKNOWN_IDENTIFIER\x10\x05\x12\x15\n\x11TOO_MANY_A\
    TTEMPTS\x10\x06\x12\x17\n\x13INVALID_PHONENUMBER\x10\x07\x12\x13\n\x0fTR\
    Y_AGAIN_LATER\x10\x08B-\n\x1bcom.spotify.login5.v3.protoP\x01H\x02\xa2\
    \x02\tSPTLogin5b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::client_info::file_descriptor().clone());
            deps.push(super::user_info::file_descriptor().clone());
            deps.push(super::code::file_descriptor().clone());
            deps.push(super::hashcash::file_descriptor().clone());
            deps.push(super::credentials::file_descriptor().clone());
            deps.push(super::identifiers::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(Challenges::generated_message_descriptor_data());
            messages.push(Challenge::generated_message_descriptor_data());
            messages.push(ChallengeSolutions::generated_message_descriptor_data());
            messages.push(ChallengeSolution::generated_message_descriptor_data());
            messages.push(LoginRequest::generated_message_descriptor_data());
            messages.push(LoginOk::generated_message_descriptor_data());
            messages.push(LoginResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(LoginError::generated_enum_descriptor_data());
            enums.push(login_response::Warnings::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
