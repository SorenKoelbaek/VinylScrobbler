// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `keyexchange.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:ClientHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientHello {
    // message fields
    // @@protoc_insertion_point(field:ClientHello.build_info)
    pub build_info: ::protobuf::MessageField<BuildInfo>,
    // @@protoc_insertion_point(field:ClientHello.fingerprints_supported)
    pub fingerprints_supported: ::std::vec::Vec<::protobuf::EnumOrUnknown<Fingerprint>>,
    // @@protoc_insertion_point(field:ClientHello.cryptosuites_supported)
    pub cryptosuites_supported: ::std::vec::Vec<::protobuf::EnumOrUnknown<Cryptosuite>>,
    // @@protoc_insertion_point(field:ClientHello.powschemes_supported)
    pub powschemes_supported: ::std::vec::Vec<::protobuf::EnumOrUnknown<Powscheme>>,
    // @@protoc_insertion_point(field:ClientHello.login_crypto_hello)
    pub login_crypto_hello: ::protobuf::MessageField<LoginCryptoHelloUnion>,
    // @@protoc_insertion_point(field:ClientHello.client_nonce)
    pub client_nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ClientHello.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ClientHello.feature_set)
    pub feature_set: ::protobuf::MessageField<FeatureSet>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientHello {
    fn default() -> &'a ClientHello {
        <ClientHello as ::protobuf::Message>::default_instance()
    }
}

impl ClientHello {
    pub fn new() -> ClientHello {
        ::std::default::Default::default()
    }

    // required bytes client_nonce = 60;

    pub fn client_nonce(&self) -> &[u8] {
        match self.client_nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_client_nonce(&mut self) {
        self.client_nonce = ::std::option::Option::None;
    }

    pub fn has_client_nonce(&self) -> bool {
        self.client_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.client_nonce.is_none() {
            self.client_nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.client_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.client_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes padding = 70;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BuildInfo>(
            "build_info",
            |m: &ClientHello| { &m.build_info },
            |m: &mut ClientHello| { &mut m.build_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fingerprints_supported",
            |m: &ClientHello| { &m.fingerprints_supported },
            |m: &mut ClientHello| { &mut m.fingerprints_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cryptosuites_supported",
            |m: &ClientHello| { &m.cryptosuites_supported },
            |m: &mut ClientHello| { &mut m.cryptosuites_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "powschemes_supported",
            |m: &ClientHello| { &m.powschemes_supported },
            |m: &mut ClientHello| { &mut m.powschemes_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginCryptoHelloUnion>(
            "login_crypto_hello",
            |m: &ClientHello| { &m.login_crypto_hello },
            |m: &mut ClientHello| { &mut m.login_crypto_hello },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_nonce",
            |m: &ClientHello| { &m.client_nonce },
            |m: &mut ClientHello| { &mut m.client_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &ClientHello| { &m.padding },
            |m: &mut ClientHello| { &mut m.padding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeatureSet>(
            "feature_set",
            |m: &ClientHello| { &m.feature_set },
            |m: &mut ClientHello| { &mut m.feature_set },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientHello>(
            "ClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientHello {
    const NAME: &'static str = "ClientHello";

    fn is_initialized(&self) -> bool {
        if self.build_info.is_none() {
            return false;
        }
        if self.login_crypto_hello.is_none() {
            return false;
        }
        if self.client_nonce.is_none() {
            return false;
        }
        for v in &self.build_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.login_crypto_hello {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.feature_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_info)?;
                },
                160 => {
                    self.fingerprints_supported.push(is.read_enum_or_unknown()?);
                },
                162 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.fingerprints_supported)?
                },
                240 => {
                    self.cryptosuites_supported.push(is.read_enum_or_unknown()?);
                },
                242 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.cryptosuites_supported)?
                },
                320 => {
                    self.powschemes_supported.push(is.read_enum_or_unknown()?);
                },
                322 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.powschemes_supported)?
                },
                402 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.login_crypto_hello)?;
                },
                482 => {
                    self.client_nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                562 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                642 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.feature_set)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.build_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.fingerprints_supported {
            my_size += ::protobuf::rt::int32_size(20, value.value());
        };
        for value in &self.cryptosuites_supported {
            my_size += ::protobuf::rt::int32_size(30, value.value());
        };
        for value in &self.powschemes_supported {
            my_size += ::protobuf::rt::int32_size(40, value.value());
        };
        if let Some(v) = self.login_crypto_hello.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(60, &v);
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(70, &v);
        }
        if let Some(v) = self.feature_set.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.build_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.fingerprints_supported {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.cryptosuites_supported {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.powschemes_supported {
            os.write_enum(40, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.login_crypto_hello.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.client_nonce.as_ref() {
            os.write_bytes(60, v)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(70, v)?;
        }
        if let Some(v) = self.feature_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(80, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientHello {
        ClientHello::new()
    }

    fn clear(&mut self) {
        self.build_info.clear();
        self.fingerprints_supported.clear();
        self.cryptosuites_supported.clear();
        self.powschemes_supported.clear();
        self.login_crypto_hello.clear();
        self.client_nonce = ::std::option::Option::None;
        self.padding = ::std::option::Option::None;
        self.feature_set.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientHello {
        static instance: ClientHello = ClientHello {
            build_info: ::protobuf::MessageField::none(),
            fingerprints_supported: ::std::vec::Vec::new(),
            cryptosuites_supported: ::std::vec::Vec::new(),
            powschemes_supported: ::std::vec::Vec::new(),
            login_crypto_hello: ::protobuf::MessageField::none(),
            client_nonce: ::std::option::Option::None,
            padding: ::std::option::Option::None,
            feature_set: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BuildInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BuildInfo {
    // message fields
    // @@protoc_insertion_point(field:BuildInfo.product)
    pub product: ::std::option::Option<::protobuf::EnumOrUnknown<Product>>,
    // @@protoc_insertion_point(field:BuildInfo.product_flags)
    pub product_flags: ::std::vec::Vec<::protobuf::EnumOrUnknown<ProductFlags>>,
    // @@protoc_insertion_point(field:BuildInfo.platform)
    pub platform: ::std::option::Option<::protobuf::EnumOrUnknown<Platform>>,
    // @@protoc_insertion_point(field:BuildInfo.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:BuildInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildInfo {
    fn default() -> &'a BuildInfo {
        <BuildInfo as ::protobuf::Message>::default_instance()
    }
}

impl BuildInfo {
    pub fn new() -> BuildInfo {
        ::std::default::Default::default()
    }

    // required .Product product = 10;

    pub fn product(&self) -> Product {
        match self.product {
            Some(e) => e.enum_value_or(Product::PRODUCT_CLIENT),
            None => Product::PRODUCT_CLIENT,
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: Product) {
        self.product = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .Platform platform = 30;

    pub fn platform(&self) -> Platform {
        match self.platform {
            Some(e) => e.enum_value_or(Platform::PLATFORM_WIN32_X86),
            None => Platform::PLATFORM_WIN32_X86,
        }
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: Platform) {
        self.platform = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint64 version = 40;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &BuildInfo| { &m.product },
            |m: &mut BuildInfo| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "product_flags",
            |m: &BuildInfo| { &m.product_flags },
            |m: &mut BuildInfo| { &mut m.product_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &BuildInfo| { &m.platform },
            |m: &mut BuildInfo| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &BuildInfo| { &m.version },
            |m: &mut BuildInfo| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildInfo>(
            "BuildInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildInfo {
    const NAME: &'static str = "BuildInfo";

    fn is_initialized(&self) -> bool {
        if self.product.is_none() {
            return false;
        }
        if self.platform.is_none() {
            return false;
        }
        if self.version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.product = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.product_flags.push(is.read_enum_or_unknown()?);
                },
                162 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.product_flags)?
                },
                240 => {
                    self.platform = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                320 => {
                    self.version = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        for value in &self.product_flags {
            my_size += ::protobuf::rt::int32_size(20, value.value());
        };
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::int32_size(30, v.value());
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint64_size(40, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.product {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.product_flags {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.platform {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.version {
            os.write_uint64(40, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildInfo {
        BuildInfo::new()
    }

    fn clear(&mut self) {
        self.product = ::std::option::Option::None;
        self.product_flags.clear();
        self.platform = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildInfo {
        static instance: BuildInfo = BuildInfo {
            product: ::std::option::Option::None,
            product_flags: ::std::vec::Vec::new(),
            platform: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LoginCryptoHelloUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginCryptoHelloUnion {
    // message fields
    // @@protoc_insertion_point(field:LoginCryptoHelloUnion.diffie_hellman)
    pub diffie_hellman: ::protobuf::MessageField<LoginCryptoDiffieHellmanHello>,
    // special fields
    // @@protoc_insertion_point(special_field:LoginCryptoHelloUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginCryptoHelloUnion {
    fn default() -> &'a LoginCryptoHelloUnion {
        <LoginCryptoHelloUnion as ::protobuf::Message>::default_instance()
    }
}

impl LoginCryptoHelloUnion {
    pub fn new() -> LoginCryptoHelloUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginCryptoDiffieHellmanHello>(
            "diffie_hellman",
            |m: &LoginCryptoHelloUnion| { &m.diffie_hellman },
            |m: &mut LoginCryptoHelloUnion| { &mut m.diffie_hellman },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginCryptoHelloUnion>(
            "LoginCryptoHelloUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginCryptoHelloUnion {
    const NAME: &'static str = "LoginCryptoHelloUnion";

    fn is_initialized(&self) -> bool {
        for v in &self.diffie_hellman {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.diffie_hellman)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diffie_hellman.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.diffie_hellman.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginCryptoHelloUnion {
        LoginCryptoHelloUnion::new()
    }

    fn clear(&mut self) {
        self.diffie_hellman.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginCryptoHelloUnion {
        static instance: LoginCryptoHelloUnion = LoginCryptoHelloUnion {
            diffie_hellman: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginCryptoHelloUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginCryptoHelloUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginCryptoHelloUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCryptoHelloUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LoginCryptoDiffieHellmanHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginCryptoDiffieHellmanHello {
    // message fields
    // @@protoc_insertion_point(field:LoginCryptoDiffieHellmanHello.gc)
    pub gc: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LoginCryptoDiffieHellmanHello.server_keys_known)
    pub server_keys_known: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:LoginCryptoDiffieHellmanHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginCryptoDiffieHellmanHello {
    fn default() -> &'a LoginCryptoDiffieHellmanHello {
        <LoginCryptoDiffieHellmanHello as ::protobuf::Message>::default_instance()
    }
}

impl LoginCryptoDiffieHellmanHello {
    pub fn new() -> LoginCryptoDiffieHellmanHello {
        ::std::default::Default::default()
    }

    // required bytes gc = 10;

    pub fn gc(&self) -> &[u8] {
        match self.gc.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gc(&mut self) {
        self.gc = ::std::option::Option::None;
    }

    pub fn has_gc(&self) -> bool {
        self.gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc(&mut self, v: ::std::vec::Vec<u8>) {
        self.gc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gc.is_none() {
            self.gc = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gc.as_mut().unwrap()
    }

    // Take field
    pub fn take_gc(&mut self) -> ::std::vec::Vec<u8> {
        self.gc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 server_keys_known = 20;

    pub fn server_keys_known(&self) -> u32 {
        self.server_keys_known.unwrap_or(0)
    }

    pub fn clear_server_keys_known(&mut self) {
        self.server_keys_known = ::std::option::Option::None;
    }

    pub fn has_server_keys_known(&self) -> bool {
        self.server_keys_known.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_keys_known(&mut self, v: u32) {
        self.server_keys_known = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gc",
            |m: &LoginCryptoDiffieHellmanHello| { &m.gc },
            |m: &mut LoginCryptoDiffieHellmanHello| { &mut m.gc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_keys_known",
            |m: &LoginCryptoDiffieHellmanHello| { &m.server_keys_known },
            |m: &mut LoginCryptoDiffieHellmanHello| { &mut m.server_keys_known },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginCryptoDiffieHellmanHello>(
            "LoginCryptoDiffieHellmanHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginCryptoDiffieHellmanHello {
    const NAME: &'static str = "LoginCryptoDiffieHellmanHello";

    fn is_initialized(&self) -> bool {
        if self.gc.is_none() {
            return false;
        }
        if self.server_keys_known.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.gc = ::std::option::Option::Some(is.read_bytes()?);
                },
                160 => {
                    self.server_keys_known = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.server_keys_known {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gc.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.server_keys_known {
            os.write_uint32(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginCryptoDiffieHellmanHello {
        LoginCryptoDiffieHellmanHello::new()
    }

    fn clear(&mut self) {
        self.gc = ::std::option::Option::None;
        self.server_keys_known = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginCryptoDiffieHellmanHello {
        static instance: LoginCryptoDiffieHellmanHello = LoginCryptoDiffieHellmanHello {
            gc: ::std::option::Option::None,
            server_keys_known: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginCryptoDiffieHellmanHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginCryptoDiffieHellmanHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginCryptoDiffieHellmanHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCryptoDiffieHellmanHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FeatureSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeatureSet {
    // message fields
    // @@protoc_insertion_point(field:FeatureSet.autoupdate2)
    pub autoupdate2: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:FeatureSet.current_location)
    pub current_location: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:FeatureSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureSet {
    fn default() -> &'a FeatureSet {
        <FeatureSet as ::protobuf::Message>::default_instance()
    }
}

impl FeatureSet {
    pub fn new() -> FeatureSet {
        ::std::default::Default::default()
    }

    // optional bool autoupdate2 = 1;

    pub fn autoupdate2(&self) -> bool {
        self.autoupdate2.unwrap_or(false)
    }

    pub fn clear_autoupdate2(&mut self) {
        self.autoupdate2 = ::std::option::Option::None;
    }

    pub fn has_autoupdate2(&self) -> bool {
        self.autoupdate2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoupdate2(&mut self, v: bool) {
        self.autoupdate2 = ::std::option::Option::Some(v);
    }

    // optional bool current_location = 2;

    pub fn current_location(&self) -> bool {
        self.current_location.unwrap_or(false)
    }

    pub fn clear_current_location(&mut self) {
        self.current_location = ::std::option::Option::None;
    }

    pub fn has_current_location(&self) -> bool {
        self.current_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_location(&mut self, v: bool) {
        self.current_location = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autoupdate2",
            |m: &FeatureSet| { &m.autoupdate2 },
            |m: &mut FeatureSet| { &mut m.autoupdate2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_location",
            |m: &FeatureSet| { &m.current_location },
            |m: &mut FeatureSet| { &mut m.current_location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureSet>(
            "FeatureSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureSet {
    const NAME: &'static str = "FeatureSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.autoupdate2 = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.current_location = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.autoupdate2 {
            my_size += 1 + 1;
        }
        if let Some(v) = self.current_location {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.autoupdate2 {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.current_location {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureSet {
        FeatureSet::new()
    }

    fn clear(&mut self) {
        self.autoupdate2 = ::std::option::Option::None;
        self.current_location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureSet {
        static instance: FeatureSet = FeatureSet {
            autoupdate2: ::std::option::Option::None,
            current_location: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:APResponseMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APResponseMessage {
    // message fields
    // @@protoc_insertion_point(field:APResponseMessage.challenge)
    pub challenge: ::protobuf::MessageField<APChallenge>,
    // @@protoc_insertion_point(field:APResponseMessage.upgrade)
    pub upgrade: ::protobuf::MessageField<UpgradeRequiredMessage>,
    // @@protoc_insertion_point(field:APResponseMessage.login_failed)
    pub login_failed: ::protobuf::MessageField<APLoginFailed>,
    // special fields
    // @@protoc_insertion_point(special_field:APResponseMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APResponseMessage {
    fn default() -> &'a APResponseMessage {
        <APResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl APResponseMessage {
    pub fn new() -> APResponseMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, APChallenge>(
            "challenge",
            |m: &APResponseMessage| { &m.challenge },
            |m: &mut APResponseMessage| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UpgradeRequiredMessage>(
            "upgrade",
            |m: &APResponseMessage| { &m.upgrade },
            |m: &mut APResponseMessage| { &mut m.upgrade },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, APLoginFailed>(
            "login_failed",
            |m: &APResponseMessage| { &m.login_failed },
            |m: &mut APResponseMessage| { &mut m.login_failed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APResponseMessage>(
            "APResponseMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APResponseMessage {
    const NAME: &'static str = "APResponseMessage";

    fn is_initialized(&self) -> bool {
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upgrade {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.login_failed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.challenge)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upgrade)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.login_failed)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.upgrade.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.login_failed.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.upgrade.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.login_failed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APResponseMessage {
        APResponseMessage::new()
    }

    fn clear(&mut self) {
        self.challenge.clear();
        self.upgrade.clear();
        self.login_failed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APResponseMessage {
        static instance: APResponseMessage = APResponseMessage {
            challenge: ::protobuf::MessageField::none(),
            upgrade: ::protobuf::MessageField::none(),
            login_failed: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APResponseMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APResponseMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APResponseMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:APChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APChallenge {
    // message fields
    // @@protoc_insertion_point(field:APChallenge.login_crypto_challenge)
    pub login_crypto_challenge: ::protobuf::MessageField<LoginCryptoChallengeUnion>,
    // @@protoc_insertion_point(field:APChallenge.fingerprint_challenge)
    pub fingerprint_challenge: ::protobuf::MessageField<FingerprintChallengeUnion>,
    // @@protoc_insertion_point(field:APChallenge.pow_challenge)
    pub pow_challenge: ::protobuf::MessageField<PoWChallengeUnion>,
    // @@protoc_insertion_point(field:APChallenge.crypto_challenge)
    pub crypto_challenge: ::protobuf::MessageField<CryptoChallengeUnion>,
    // @@protoc_insertion_point(field:APChallenge.server_nonce)
    pub server_nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:APChallenge.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:APChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APChallenge {
    fn default() -> &'a APChallenge {
        <APChallenge as ::protobuf::Message>::default_instance()
    }
}

impl APChallenge {
    pub fn new() -> APChallenge {
        ::std::default::Default::default()
    }

    // required bytes server_nonce = 50;

    pub fn server_nonce(&self) -> &[u8] {
        match self.server_nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_server_nonce(&mut self) {
        self.server_nonce = ::std::option::Option::None;
    }

    pub fn has_server_nonce(&self) -> bool {
        self.server_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.server_nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.server_nonce.is_none() {
            self.server_nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.server_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.server_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes padding = 60;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginCryptoChallengeUnion>(
            "login_crypto_challenge",
            |m: &APChallenge| { &m.login_crypto_challenge },
            |m: &mut APChallenge| { &mut m.login_crypto_challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FingerprintChallengeUnion>(
            "fingerprint_challenge",
            |m: &APChallenge| { &m.fingerprint_challenge },
            |m: &mut APChallenge| { &mut m.fingerprint_challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoWChallengeUnion>(
            "pow_challenge",
            |m: &APChallenge| { &m.pow_challenge },
            |m: &mut APChallenge| { &mut m.pow_challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoChallengeUnion>(
            "crypto_challenge",
            |m: &APChallenge| { &m.crypto_challenge },
            |m: &mut APChallenge| { &mut m.crypto_challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_nonce",
            |m: &APChallenge| { &m.server_nonce },
            |m: &mut APChallenge| { &mut m.server_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &APChallenge| { &m.padding },
            |m: &mut APChallenge| { &mut m.padding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APChallenge>(
            "APChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APChallenge {
    const NAME: &'static str = "APChallenge";

    fn is_initialized(&self) -> bool {
        if self.login_crypto_challenge.is_none() {
            return false;
        }
        if self.fingerprint_challenge.is_none() {
            return false;
        }
        if self.pow_challenge.is_none() {
            return false;
        }
        if self.crypto_challenge.is_none() {
            return false;
        }
        if self.server_nonce.is_none() {
            return false;
        }
        for v in &self.login_crypto_challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fingerprint_challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pow_challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crypto_challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.login_crypto_challenge)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fingerprint_challenge)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pow_challenge)?;
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.crypto_challenge)?;
                },
                402 => {
                    self.server_nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                482 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.login_crypto_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fingerprint_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pow_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.crypto_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(50, &v);
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(60, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.login_crypto_challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.fingerprint_challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.pow_challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.crypto_challenge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.server_nonce.as_ref() {
            os.write_bytes(50, v)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(60, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APChallenge {
        APChallenge::new()
    }

    fn clear(&mut self) {
        self.login_crypto_challenge.clear();
        self.fingerprint_challenge.clear();
        self.pow_challenge.clear();
        self.crypto_challenge.clear();
        self.server_nonce = ::std::option::Option::None;
        self.padding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APChallenge {
        static instance: APChallenge = APChallenge {
            login_crypto_challenge: ::protobuf::MessageField::none(),
            fingerprint_challenge: ::protobuf::MessageField::none(),
            pow_challenge: ::protobuf::MessageField::none(),
            crypto_challenge: ::protobuf::MessageField::none(),
            server_nonce: ::std::option::Option::None,
            padding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LoginCryptoChallengeUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginCryptoChallengeUnion {
    // message fields
    // @@protoc_insertion_point(field:LoginCryptoChallengeUnion.diffie_hellman)
    pub diffie_hellman: ::protobuf::MessageField<LoginCryptoDiffieHellmanChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:LoginCryptoChallengeUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginCryptoChallengeUnion {
    fn default() -> &'a LoginCryptoChallengeUnion {
        <LoginCryptoChallengeUnion as ::protobuf::Message>::default_instance()
    }
}

impl LoginCryptoChallengeUnion {
    pub fn new() -> LoginCryptoChallengeUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginCryptoDiffieHellmanChallenge>(
            "diffie_hellman",
            |m: &LoginCryptoChallengeUnion| { &m.diffie_hellman },
            |m: &mut LoginCryptoChallengeUnion| { &mut m.diffie_hellman },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginCryptoChallengeUnion>(
            "LoginCryptoChallengeUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginCryptoChallengeUnion {
    const NAME: &'static str = "LoginCryptoChallengeUnion";

    fn is_initialized(&self) -> bool {
        for v in &self.diffie_hellman {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.diffie_hellman)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diffie_hellman.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.diffie_hellman.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginCryptoChallengeUnion {
        LoginCryptoChallengeUnion::new()
    }

    fn clear(&mut self) {
        self.diffie_hellman.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginCryptoChallengeUnion {
        static instance: LoginCryptoChallengeUnion = LoginCryptoChallengeUnion {
            diffie_hellman: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginCryptoChallengeUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginCryptoChallengeUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginCryptoChallengeUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCryptoChallengeUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LoginCryptoDiffieHellmanChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginCryptoDiffieHellmanChallenge {
    // message fields
    // @@protoc_insertion_point(field:LoginCryptoDiffieHellmanChallenge.gs)
    pub gs: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LoginCryptoDiffieHellmanChallenge.server_signature_key)
    pub server_signature_key: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:LoginCryptoDiffieHellmanChallenge.gs_signature)
    pub gs_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:LoginCryptoDiffieHellmanChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginCryptoDiffieHellmanChallenge {
    fn default() -> &'a LoginCryptoDiffieHellmanChallenge {
        <LoginCryptoDiffieHellmanChallenge as ::protobuf::Message>::default_instance()
    }
}

impl LoginCryptoDiffieHellmanChallenge {
    pub fn new() -> LoginCryptoDiffieHellmanChallenge {
        ::std::default::Default::default()
    }

    // required bytes gs = 10;

    pub fn gs(&self) -> &[u8] {
        match self.gs.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gs(&mut self) {
        self.gs = ::std::option::Option::None;
    }

    pub fn has_gs(&self) -> bool {
        self.gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gs(&mut self, v: ::std::vec::Vec<u8>) {
        self.gs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gs(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gs.is_none() {
            self.gs = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gs.as_mut().unwrap()
    }

    // Take field
    pub fn take_gs(&mut self) -> ::std::vec::Vec<u8> {
        self.gs.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required int32 server_signature_key = 20;

    pub fn server_signature_key(&self) -> i32 {
        self.server_signature_key.unwrap_or(0)
    }

    pub fn clear_server_signature_key(&mut self) {
        self.server_signature_key = ::std::option::Option::None;
    }

    pub fn has_server_signature_key(&self) -> bool {
        self.server_signature_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_signature_key(&mut self, v: i32) {
        self.server_signature_key = ::std::option::Option::Some(v);
    }

    // required bytes gs_signature = 30;

    pub fn gs_signature(&self) -> &[u8] {
        match self.gs_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gs_signature(&mut self) {
        self.gs_signature = ::std::option::Option::None;
    }

    pub fn has_gs_signature(&self) -> bool {
        self.gs_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gs_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.gs_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gs_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gs_signature.is_none() {
            self.gs_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gs_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_gs_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.gs_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gs",
            |m: &LoginCryptoDiffieHellmanChallenge| { &m.gs },
            |m: &mut LoginCryptoDiffieHellmanChallenge| { &mut m.gs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_signature_key",
            |m: &LoginCryptoDiffieHellmanChallenge| { &m.server_signature_key },
            |m: &mut LoginCryptoDiffieHellmanChallenge| { &mut m.server_signature_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gs_signature",
            |m: &LoginCryptoDiffieHellmanChallenge| { &m.gs_signature },
            |m: &mut LoginCryptoDiffieHellmanChallenge| { &mut m.gs_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginCryptoDiffieHellmanChallenge>(
            "LoginCryptoDiffieHellmanChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginCryptoDiffieHellmanChallenge {
    const NAME: &'static str = "LoginCryptoDiffieHellmanChallenge";

    fn is_initialized(&self) -> bool {
        if self.gs.is_none() {
            return false;
        }
        if self.server_signature_key.is_none() {
            return false;
        }
        if self.gs_signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.gs = ::std::option::Option::Some(is.read_bytes()?);
                },
                160 => {
                    self.server_signature_key = ::std::option::Option::Some(is.read_int32()?);
                },
                242 => {
                    self.gs_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gs.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.server_signature_key {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.gs_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(30, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gs.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.server_signature_key {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.gs_signature.as_ref() {
            os.write_bytes(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginCryptoDiffieHellmanChallenge {
        LoginCryptoDiffieHellmanChallenge::new()
    }

    fn clear(&mut self) {
        self.gs = ::std::option::Option::None;
        self.server_signature_key = ::std::option::Option::None;
        self.gs_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginCryptoDiffieHellmanChallenge {
        static instance: LoginCryptoDiffieHellmanChallenge = LoginCryptoDiffieHellmanChallenge {
            gs: ::std::option::Option::None,
            server_signature_key: ::std::option::Option::None,
            gs_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginCryptoDiffieHellmanChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginCryptoDiffieHellmanChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginCryptoDiffieHellmanChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCryptoDiffieHellmanChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FingerprintChallengeUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FingerprintChallengeUnion {
    // message fields
    // @@protoc_insertion_point(field:FingerprintChallengeUnion.grain)
    pub grain: ::protobuf::MessageField<FingerprintGrainChallenge>,
    // @@protoc_insertion_point(field:FingerprintChallengeUnion.hmac_ripemd)
    pub hmac_ripemd: ::protobuf::MessageField<FingerprintHmacRipemdChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:FingerprintChallengeUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintChallengeUnion {
    fn default() -> &'a FingerprintChallengeUnion {
        <FingerprintChallengeUnion as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintChallengeUnion {
    pub fn new() -> FingerprintChallengeUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FingerprintGrainChallenge>(
            "grain",
            |m: &FingerprintChallengeUnion| { &m.grain },
            |m: &mut FingerprintChallengeUnion| { &mut m.grain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FingerprintHmacRipemdChallenge>(
            "hmac_ripemd",
            |m: &FingerprintChallengeUnion| { &m.hmac_ripemd },
            |m: &mut FingerprintChallengeUnion| { &mut m.hmac_ripemd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FingerprintChallengeUnion>(
            "FingerprintChallengeUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FingerprintChallengeUnion {
    const NAME: &'static str = "FingerprintChallengeUnion";

    fn is_initialized(&self) -> bool {
        for v in &self.grain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hmac_ripemd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.grain)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hmac_ripemd)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.grain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hmac_ripemd.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.grain.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.hmac_ripemd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintChallengeUnion {
        FingerprintChallengeUnion::new()
    }

    fn clear(&mut self) {
        self.grain.clear();
        self.hmac_ripemd.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintChallengeUnion {
        static instance: FingerprintChallengeUnion = FingerprintChallengeUnion {
            grain: ::protobuf::MessageField::none(),
            hmac_ripemd: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FingerprintChallengeUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FingerprintChallengeUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FingerprintChallengeUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintChallengeUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FingerprintGrainChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FingerprintGrainChallenge {
    // message fields
    // @@protoc_insertion_point(field:FingerprintGrainChallenge.kek)
    pub kek: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:FingerprintGrainChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintGrainChallenge {
    fn default() -> &'a FingerprintGrainChallenge {
        <FingerprintGrainChallenge as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintGrainChallenge {
    pub fn new() -> FingerprintGrainChallenge {
        ::std::default::Default::default()
    }

    // required bytes kek = 10;

    pub fn kek(&self) -> &[u8] {
        match self.kek.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_kek(&mut self) {
        self.kek = ::std::option::Option::None;
    }

    pub fn has_kek(&self) -> bool {
        self.kek.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kek(&mut self, v: ::std::vec::Vec<u8>) {
        self.kek = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kek(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kek.is_none() {
            self.kek = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.kek.as_mut().unwrap()
    }

    // Take field
    pub fn take_kek(&mut self) -> ::std::vec::Vec<u8> {
        self.kek.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kek",
            |m: &FingerprintGrainChallenge| { &m.kek },
            |m: &mut FingerprintGrainChallenge| { &mut m.kek },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FingerprintGrainChallenge>(
            "FingerprintGrainChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FingerprintGrainChallenge {
    const NAME: &'static str = "FingerprintGrainChallenge";

    fn is_initialized(&self) -> bool {
        if self.kek.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.kek = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kek.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kek.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintGrainChallenge {
        FingerprintGrainChallenge::new()
    }

    fn clear(&mut self) {
        self.kek = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintGrainChallenge {
        static instance: FingerprintGrainChallenge = FingerprintGrainChallenge {
            kek: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FingerprintGrainChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FingerprintGrainChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FingerprintGrainChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintGrainChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FingerprintHmacRipemdChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FingerprintHmacRipemdChallenge {
    // message fields
    // @@protoc_insertion_point(field:FingerprintHmacRipemdChallenge.challenge)
    pub challenge: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:FingerprintHmacRipemdChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintHmacRipemdChallenge {
    fn default() -> &'a FingerprintHmacRipemdChallenge {
        <FingerprintHmacRipemdChallenge as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintHmacRipemdChallenge {
    pub fn new() -> FingerprintHmacRipemdChallenge {
        ::std::default::Default::default()
    }

    // required bytes challenge = 10;

    pub fn challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge.is_none() {
            self.challenge = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &FingerprintHmacRipemdChallenge| { &m.challenge },
            |m: &mut FingerprintHmacRipemdChallenge| { &mut m.challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FingerprintHmacRipemdChallenge>(
            "FingerprintHmacRipemdChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FingerprintHmacRipemdChallenge {
    const NAME: &'static str = "FingerprintHmacRipemdChallenge";

    fn is_initialized(&self) -> bool {
        if self.challenge.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.challenge = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintHmacRipemdChallenge {
        FingerprintHmacRipemdChallenge::new()
    }

    fn clear(&mut self) {
        self.challenge = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintHmacRipemdChallenge {
        static instance: FingerprintHmacRipemdChallenge = FingerprintHmacRipemdChallenge {
            challenge: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FingerprintHmacRipemdChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FingerprintHmacRipemdChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FingerprintHmacRipemdChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintHmacRipemdChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PoWChallengeUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoWChallengeUnion {
    // message fields
    // @@protoc_insertion_point(field:PoWChallengeUnion.hash_cash)
    pub hash_cash: ::protobuf::MessageField<PoWHashCashChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:PoWChallengeUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoWChallengeUnion {
    fn default() -> &'a PoWChallengeUnion {
        <PoWChallengeUnion as ::protobuf::Message>::default_instance()
    }
}

impl PoWChallengeUnion {
    pub fn new() -> PoWChallengeUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoWHashCashChallenge>(
            "hash_cash",
            |m: &PoWChallengeUnion| { &m.hash_cash },
            |m: &mut PoWChallengeUnion| { &mut m.hash_cash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoWChallengeUnion>(
            "PoWChallengeUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoWChallengeUnion {
    const NAME: &'static str = "PoWChallengeUnion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hash_cash)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash_cash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash_cash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoWChallengeUnion {
        PoWChallengeUnion::new()
    }

    fn clear(&mut self) {
        self.hash_cash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoWChallengeUnion {
        static instance: PoWChallengeUnion = PoWChallengeUnion {
            hash_cash: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoWChallengeUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoWChallengeUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoWChallengeUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoWChallengeUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PoWHashCashChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoWHashCashChallenge {
    // message fields
    // @@protoc_insertion_point(field:PoWHashCashChallenge.prefix)
    pub prefix: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PoWHashCashChallenge.length)
    pub length: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:PoWHashCashChallenge.target)
    pub target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:PoWHashCashChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoWHashCashChallenge {
    fn default() -> &'a PoWHashCashChallenge {
        <PoWHashCashChallenge as ::protobuf::Message>::default_instance()
    }
}

impl PoWHashCashChallenge {
    pub fn new() -> PoWHashCashChallenge {
        ::std::default::Default::default()
    }

    // optional bytes prefix = 10;

    pub fn prefix(&self) -> &[u8] {
        match self.prefix.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_prefix(&mut self) {
        self.prefix = ::std::option::Option::None;
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.prefix.is_none() {
            self.prefix = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        self.prefix.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 length = 20;

    pub fn length(&self) -> i32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional int32 target = 30;

    pub fn target(&self) -> i32 {
        self.target.unwrap_or(0)
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: i32) {
        self.target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefix",
            |m: &PoWHashCashChallenge| { &m.prefix },
            |m: &mut PoWHashCashChallenge| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &PoWHashCashChallenge| { &m.length },
            |m: &mut PoWHashCashChallenge| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target",
            |m: &PoWHashCashChallenge| { &m.target },
            |m: &mut PoWHashCashChallenge| { &mut m.target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoWHashCashChallenge>(
            "PoWHashCashChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoWHashCashChallenge {
    const NAME: &'static str = "PoWHashCashChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.prefix = ::std::option::Option::Some(is.read_bytes()?);
                },
                160 => {
                    self.length = ::std::option::Option::Some(is.read_int32()?);
                },
                240 => {
                    self.target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.target {
            my_size += ::protobuf::rt::int32_size(30, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.prefix.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.target {
            os.write_int32(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoWHashCashChallenge {
        PoWHashCashChallenge::new()
    }

    fn clear(&mut self) {
        self.prefix = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoWHashCashChallenge {
        static instance: PoWHashCashChallenge = PoWHashCashChallenge {
            prefix: ::std::option::Option::None,
            length: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoWHashCashChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoWHashCashChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoWHashCashChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoWHashCashChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CryptoChallengeUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CryptoChallengeUnion {
    // message fields
    // @@protoc_insertion_point(field:CryptoChallengeUnion.shannon)
    pub shannon: ::protobuf::MessageField<CryptoShannonChallenge>,
    // @@protoc_insertion_point(field:CryptoChallengeUnion.rc4_sha1_hmac)
    pub rc4_sha1_hmac: ::protobuf::MessageField<CryptoRc4Sha1HmacChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CryptoChallengeUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptoChallengeUnion {
    fn default() -> &'a CryptoChallengeUnion {
        <CryptoChallengeUnion as ::protobuf::Message>::default_instance()
    }
}

impl CryptoChallengeUnion {
    pub fn new() -> CryptoChallengeUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoShannonChallenge>(
            "shannon",
            |m: &CryptoChallengeUnion| { &m.shannon },
            |m: &mut CryptoChallengeUnion| { &mut m.shannon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoRc4Sha1HmacChallenge>(
            "rc4_sha1_hmac",
            |m: &CryptoChallengeUnion| { &m.rc4_sha1_hmac },
            |m: &mut CryptoChallengeUnion| { &mut m.rc4_sha1_hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptoChallengeUnion>(
            "CryptoChallengeUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptoChallengeUnion {
    const NAME: &'static str = "CryptoChallengeUnion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shannon)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rc4_sha1_hmac)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shannon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rc4_sha1_hmac.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shannon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.rc4_sha1_hmac.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptoChallengeUnion {
        CryptoChallengeUnion::new()
    }

    fn clear(&mut self) {
        self.shannon.clear();
        self.rc4_sha1_hmac.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptoChallengeUnion {
        static instance: CryptoChallengeUnion = CryptoChallengeUnion {
            shannon: ::protobuf::MessageField::none(),
            rc4_sha1_hmac: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptoChallengeUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptoChallengeUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptoChallengeUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoChallengeUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CryptoShannonChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CryptoShannonChallenge {
    // special fields
    // @@protoc_insertion_point(special_field:CryptoShannonChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptoShannonChallenge {
    fn default() -> &'a CryptoShannonChallenge {
        <CryptoShannonChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CryptoShannonChallenge {
    pub fn new() -> CryptoShannonChallenge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptoShannonChallenge>(
            "CryptoShannonChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptoShannonChallenge {
    const NAME: &'static str = "CryptoShannonChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptoShannonChallenge {
        CryptoShannonChallenge::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptoShannonChallenge {
        static instance: CryptoShannonChallenge = CryptoShannonChallenge {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptoShannonChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptoShannonChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptoShannonChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoShannonChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CryptoRc4Sha1HmacChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CryptoRc4Sha1HmacChallenge {
    // special fields
    // @@protoc_insertion_point(special_field:CryptoRc4Sha1HmacChallenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptoRc4Sha1HmacChallenge {
    fn default() -> &'a CryptoRc4Sha1HmacChallenge {
        <CryptoRc4Sha1HmacChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CryptoRc4Sha1HmacChallenge {
    pub fn new() -> CryptoRc4Sha1HmacChallenge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptoRc4Sha1HmacChallenge>(
            "CryptoRc4Sha1HmacChallenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptoRc4Sha1HmacChallenge {
    const NAME: &'static str = "CryptoRc4Sha1HmacChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptoRc4Sha1HmacChallenge {
        CryptoRc4Sha1HmacChallenge::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptoRc4Sha1HmacChallenge {
        static instance: CryptoRc4Sha1HmacChallenge = CryptoRc4Sha1HmacChallenge {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptoRc4Sha1HmacChallenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptoRc4Sha1HmacChallenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptoRc4Sha1HmacChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoRc4Sha1HmacChallenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpgradeRequiredMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpgradeRequiredMessage {
    // message fields
    // @@protoc_insertion_point(field:UpgradeRequiredMessage.upgrade_signed_part)
    pub upgrade_signed_part: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:UpgradeRequiredMessage.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:UpgradeRequiredMessage.http_suffix)
    pub http_suffix: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:UpgradeRequiredMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpgradeRequiredMessage {
    fn default() -> &'a UpgradeRequiredMessage {
        <UpgradeRequiredMessage as ::protobuf::Message>::default_instance()
    }
}

impl UpgradeRequiredMessage {
    pub fn new() -> UpgradeRequiredMessage {
        ::std::default::Default::default()
    }

    // required bytes upgrade_signed_part = 10;

    pub fn upgrade_signed_part(&self) -> &[u8] {
        match self.upgrade_signed_part.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_upgrade_signed_part(&mut self) {
        self.upgrade_signed_part = ::std::option::Option::None;
    }

    pub fn has_upgrade_signed_part(&self) -> bool {
        self.upgrade_signed_part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_signed_part(&mut self, v: ::std::vec::Vec<u8>) {
        self.upgrade_signed_part = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upgrade_signed_part(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.upgrade_signed_part.is_none() {
            self.upgrade_signed_part = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.upgrade_signed_part.as_mut().unwrap()
    }

    // Take field
    pub fn take_upgrade_signed_part(&mut self) -> ::std::vec::Vec<u8> {
        self.upgrade_signed_part.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes signature = 20;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string http_suffix = 30;

    pub fn http_suffix(&self) -> &str {
        match self.http_suffix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_suffix(&mut self) {
        self.http_suffix = ::std::option::Option::None;
    }

    pub fn has_http_suffix(&self) -> bool {
        self.http_suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_suffix(&mut self, v: ::std::string::String) {
        self.http_suffix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_suffix(&mut self) -> &mut ::std::string::String {
        if self.http_suffix.is_none() {
            self.http_suffix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.http_suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_suffix(&mut self) -> ::std::string::String {
        self.http_suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgrade_signed_part",
            |m: &UpgradeRequiredMessage| { &m.upgrade_signed_part },
            |m: &mut UpgradeRequiredMessage| { &mut m.upgrade_signed_part },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &UpgradeRequiredMessage| { &m.signature },
            |m: &mut UpgradeRequiredMessage| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "http_suffix",
            |m: &UpgradeRequiredMessage| { &m.http_suffix },
            |m: &mut UpgradeRequiredMessage| { &mut m.http_suffix },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpgradeRequiredMessage>(
            "UpgradeRequiredMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpgradeRequiredMessage {
    const NAME: &'static str = "UpgradeRequiredMessage";

    fn is_initialized(&self) -> bool {
        if self.upgrade_signed_part.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.upgrade_signed_part = ::std::option::Option::Some(is.read_bytes()?);
                },
                162 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                242 => {
                    self.http_suffix = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_signed_part.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        if let Some(v) = self.http_suffix.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upgrade_signed_part.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(20, v)?;
        }
        if let Some(v) = self.http_suffix.as_ref() {
            os.write_string(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpgradeRequiredMessage {
        UpgradeRequiredMessage::new()
    }

    fn clear(&mut self) {
        self.upgrade_signed_part = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.http_suffix = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpgradeRequiredMessage {
        static instance: UpgradeRequiredMessage = UpgradeRequiredMessage {
            upgrade_signed_part: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            http_suffix: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpgradeRequiredMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpgradeRequiredMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpgradeRequiredMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpgradeRequiredMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:APLoginFailed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APLoginFailed {
    // message fields
    // @@protoc_insertion_point(field:APLoginFailed.error_code)
    pub error_code: ::std::option::Option<::protobuf::EnumOrUnknown<ErrorCode>>,
    // @@protoc_insertion_point(field:APLoginFailed.retry_delay)
    pub retry_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:APLoginFailed.expiry)
    pub expiry: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:APLoginFailed.error_description)
    pub error_description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:APLoginFailed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APLoginFailed {
    fn default() -> &'a APLoginFailed {
        <APLoginFailed as ::protobuf::Message>::default_instance()
    }
}

impl APLoginFailed {
    pub fn new() -> APLoginFailed {
        ::std::default::Default::default()
    }

    // required .ErrorCode error_code = 10;

    pub fn error_code(&self) -> ErrorCode {
        match self.error_code {
            Some(e) => e.enum_value_or(ErrorCode::ProtocolError),
            None => ErrorCode::ProtocolError,
        }
    }

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ErrorCode) {
        self.error_code = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 retry_delay = 20;

    pub fn retry_delay(&self) -> i32 {
        self.retry_delay.unwrap_or(0)
    }

    pub fn clear_retry_delay(&mut self) {
        self.retry_delay = ::std::option::Option::None;
    }

    pub fn has_retry_delay(&self) -> bool {
        self.retry_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_delay(&mut self, v: i32) {
        self.retry_delay = ::std::option::Option::Some(v);
    }

    // optional int32 expiry = 30;

    pub fn expiry(&self) -> i32 {
        self.expiry.unwrap_or(0)
    }

    pub fn clear_expiry(&mut self) {
        self.expiry = ::std::option::Option::None;
    }

    pub fn has_expiry(&self) -> bool {
        self.expiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i32) {
        self.expiry = ::std::option::Option::Some(v);
    }

    // optional string error_description = 40;

    pub fn error_description(&self) -> &str {
        match self.error_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_description(&mut self) {
        self.error_description = ::std::option::Option::None;
    }

    pub fn has_error_description(&self) -> bool {
        self.error_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_description(&mut self, v: ::std::string::String) {
        self.error_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_description(&mut self) -> &mut ::std::string::String {
        if self.error_description.is_none() {
            self.error_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_description(&mut self) -> ::std::string::String {
        self.error_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_code",
            |m: &APLoginFailed| { &m.error_code },
            |m: &mut APLoginFailed| { &mut m.error_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "retry_delay",
            |m: &APLoginFailed| { &m.retry_delay },
            |m: &mut APLoginFailed| { &mut m.retry_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiry",
            |m: &APLoginFailed| { &m.expiry },
            |m: &mut APLoginFailed| { &mut m.expiry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_description",
            |m: &APLoginFailed| { &m.error_description },
            |m: &mut APLoginFailed| { &mut m.error_description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APLoginFailed>(
            "APLoginFailed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APLoginFailed {
    const NAME: &'static str = "APLoginFailed";

    fn is_initialized(&self) -> bool {
        if self.error_code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                80 => {
                    self.error_code = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.retry_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                240 => {
                    self.expiry = ::std::option::Option::Some(is.read_int32()?);
                },
                322 => {
                    self.error_description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.retry_delay {
            my_size += ::protobuf::rt::int32_size(20, v);
        }
        if let Some(v) = self.expiry {
            my_size += ::protobuf::rt::int32_size(30, v);
        }
        if let Some(v) = self.error_description.as_ref() {
            my_size += ::protobuf::rt::string_size(40, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error_code {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.retry_delay {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.expiry {
            os.write_int32(30, v)?;
        }
        if let Some(v) = self.error_description.as_ref() {
            os.write_string(40, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APLoginFailed {
        APLoginFailed::new()
    }

    fn clear(&mut self) {
        self.error_code = ::std::option::Option::None;
        self.retry_delay = ::std::option::Option::None;
        self.expiry = ::std::option::Option::None;
        self.error_description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APLoginFailed {
        static instance: APLoginFailed = APLoginFailed {
            error_code: ::std::option::Option::None,
            retry_delay: ::std::option::Option::None,
            expiry: ::std::option::Option::None,
            error_description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APLoginFailed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APLoginFailed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APLoginFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APLoginFailed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ClientResponsePlaintext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientResponsePlaintext {
    // message fields
    // @@protoc_insertion_point(field:ClientResponsePlaintext.login_crypto_response)
    pub login_crypto_response: ::protobuf::MessageField<LoginCryptoResponseUnion>,
    // @@protoc_insertion_point(field:ClientResponsePlaintext.pow_response)
    pub pow_response: ::protobuf::MessageField<PoWResponseUnion>,
    // @@protoc_insertion_point(field:ClientResponsePlaintext.crypto_response)
    pub crypto_response: ::protobuf::MessageField<CryptoResponseUnion>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientResponsePlaintext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientResponsePlaintext {
    fn default() -> &'a ClientResponsePlaintext {
        <ClientResponsePlaintext as ::protobuf::Message>::default_instance()
    }
}

impl ClientResponsePlaintext {
    pub fn new() -> ClientResponsePlaintext {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginCryptoResponseUnion>(
            "login_crypto_response",
            |m: &ClientResponsePlaintext| { &m.login_crypto_response },
            |m: &mut ClientResponsePlaintext| { &mut m.login_crypto_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoWResponseUnion>(
            "pow_response",
            |m: &ClientResponsePlaintext| { &m.pow_response },
            |m: &mut ClientResponsePlaintext| { &mut m.pow_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoResponseUnion>(
            "crypto_response",
            |m: &ClientResponsePlaintext| { &m.crypto_response },
            |m: &mut ClientResponsePlaintext| { &mut m.crypto_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientResponsePlaintext>(
            "ClientResponsePlaintext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientResponsePlaintext {
    const NAME: &'static str = "ClientResponsePlaintext";

    fn is_initialized(&self) -> bool {
        if self.login_crypto_response.is_none() {
            return false;
        }
        if self.pow_response.is_none() {
            return false;
        }
        if self.crypto_response.is_none() {
            return false;
        }
        for v in &self.login_crypto_response {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pow_response {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crypto_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.login_crypto_response)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pow_response)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.crypto_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.login_crypto_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pow_response.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.crypto_response.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.login_crypto_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.pow_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.crypto_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientResponsePlaintext {
        ClientResponsePlaintext::new()
    }

    fn clear(&mut self) {
        self.login_crypto_response.clear();
        self.pow_response.clear();
        self.crypto_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientResponsePlaintext {
        static instance: ClientResponsePlaintext = ClientResponsePlaintext {
            login_crypto_response: ::protobuf::MessageField::none(),
            pow_response: ::protobuf::MessageField::none(),
            crypto_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientResponsePlaintext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientResponsePlaintext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientResponsePlaintext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientResponsePlaintext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LoginCryptoResponseUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginCryptoResponseUnion {
    // message fields
    // @@protoc_insertion_point(field:LoginCryptoResponseUnion.diffie_hellman)
    pub diffie_hellman: ::protobuf::MessageField<LoginCryptoDiffieHellmanResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:LoginCryptoResponseUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginCryptoResponseUnion {
    fn default() -> &'a LoginCryptoResponseUnion {
        <LoginCryptoResponseUnion as ::protobuf::Message>::default_instance()
    }
}

impl LoginCryptoResponseUnion {
    pub fn new() -> LoginCryptoResponseUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoginCryptoDiffieHellmanResponse>(
            "diffie_hellman",
            |m: &LoginCryptoResponseUnion| { &m.diffie_hellman },
            |m: &mut LoginCryptoResponseUnion| { &mut m.diffie_hellman },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginCryptoResponseUnion>(
            "LoginCryptoResponseUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginCryptoResponseUnion {
    const NAME: &'static str = "LoginCryptoResponseUnion";

    fn is_initialized(&self) -> bool {
        for v in &self.diffie_hellman {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.diffie_hellman)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diffie_hellman.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.diffie_hellman.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginCryptoResponseUnion {
        LoginCryptoResponseUnion::new()
    }

    fn clear(&mut self) {
        self.diffie_hellman.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginCryptoResponseUnion {
        static instance: LoginCryptoResponseUnion = LoginCryptoResponseUnion {
            diffie_hellman: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginCryptoResponseUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginCryptoResponseUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginCryptoResponseUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCryptoResponseUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LoginCryptoDiffieHellmanResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginCryptoDiffieHellmanResponse {
    // message fields
    // @@protoc_insertion_point(field:LoginCryptoDiffieHellmanResponse.hmac)
    pub hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:LoginCryptoDiffieHellmanResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginCryptoDiffieHellmanResponse {
    fn default() -> &'a LoginCryptoDiffieHellmanResponse {
        <LoginCryptoDiffieHellmanResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginCryptoDiffieHellmanResponse {
    pub fn new() -> LoginCryptoDiffieHellmanResponse {
        ::std::default::Default::default()
    }

    // required bytes hmac = 10;

    pub fn hmac(&self) -> &[u8] {
        match self.hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hmac(&mut self) {
        self.hmac = ::std::option::Option::None;
    }

    pub fn has_hmac(&self) -> bool {
        self.hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hmac.is_none() {
            self.hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hmac",
            |m: &LoginCryptoDiffieHellmanResponse| { &m.hmac },
            |m: &mut LoginCryptoDiffieHellmanResponse| { &mut m.hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginCryptoDiffieHellmanResponse>(
            "LoginCryptoDiffieHellmanResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginCryptoDiffieHellmanResponse {
    const NAME: &'static str = "LoginCryptoDiffieHellmanResponse";

    fn is_initialized(&self) -> bool {
        if self.hmac.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hmac.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginCryptoDiffieHellmanResponse {
        LoginCryptoDiffieHellmanResponse::new()
    }

    fn clear(&mut self) {
        self.hmac = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginCryptoDiffieHellmanResponse {
        static instance: LoginCryptoDiffieHellmanResponse = LoginCryptoDiffieHellmanResponse {
            hmac: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginCryptoDiffieHellmanResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginCryptoDiffieHellmanResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginCryptoDiffieHellmanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginCryptoDiffieHellmanResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PoWResponseUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoWResponseUnion {
    // message fields
    // @@protoc_insertion_point(field:PoWResponseUnion.hash_cash)
    pub hash_cash: ::protobuf::MessageField<PoWHashCashResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:PoWResponseUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoWResponseUnion {
    fn default() -> &'a PoWResponseUnion {
        <PoWResponseUnion as ::protobuf::Message>::default_instance()
    }
}

impl PoWResponseUnion {
    pub fn new() -> PoWResponseUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoWHashCashResponse>(
            "hash_cash",
            |m: &PoWResponseUnion| { &m.hash_cash },
            |m: &mut PoWResponseUnion| { &mut m.hash_cash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoWResponseUnion>(
            "PoWResponseUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoWResponseUnion {
    const NAME: &'static str = "PoWResponseUnion";

    fn is_initialized(&self) -> bool {
        for v in &self.hash_cash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hash_cash)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash_cash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash_cash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoWResponseUnion {
        PoWResponseUnion::new()
    }

    fn clear(&mut self) {
        self.hash_cash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoWResponseUnion {
        static instance: PoWResponseUnion = PoWResponseUnion {
            hash_cash: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoWResponseUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoWResponseUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoWResponseUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoWResponseUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PoWHashCashResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoWHashCashResponse {
    // message fields
    // @@protoc_insertion_point(field:PoWHashCashResponse.hash_suffix)
    pub hash_suffix: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:PoWHashCashResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoWHashCashResponse {
    fn default() -> &'a PoWHashCashResponse {
        <PoWHashCashResponse as ::protobuf::Message>::default_instance()
    }
}

impl PoWHashCashResponse {
    pub fn new() -> PoWHashCashResponse {
        ::std::default::Default::default()
    }

    // required bytes hash_suffix = 10;

    pub fn hash_suffix(&self) -> &[u8] {
        match self.hash_suffix.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hash_suffix(&mut self) {
        self.hash_suffix = ::std::option::Option::None;
    }

    pub fn has_hash_suffix(&self) -> bool {
        self.hash_suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash_suffix(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_suffix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_suffix(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash_suffix.is_none() {
            self.hash_suffix = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hash_suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash_suffix(&mut self) -> ::std::vec::Vec<u8> {
        self.hash_suffix.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash_suffix",
            |m: &PoWHashCashResponse| { &m.hash_suffix },
            |m: &mut PoWHashCashResponse| { &mut m.hash_suffix },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoWHashCashResponse>(
            "PoWHashCashResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoWHashCashResponse {
    const NAME: &'static str = "PoWHashCashResponse";

    fn is_initialized(&self) -> bool {
        if self.hash_suffix.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.hash_suffix = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash_suffix.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash_suffix.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoWHashCashResponse {
        PoWHashCashResponse::new()
    }

    fn clear(&mut self) {
        self.hash_suffix = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoWHashCashResponse {
        static instance: PoWHashCashResponse = PoWHashCashResponse {
            hash_suffix: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoWHashCashResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoWHashCashResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoWHashCashResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoWHashCashResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CryptoResponseUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CryptoResponseUnion {
    // message fields
    // @@protoc_insertion_point(field:CryptoResponseUnion.shannon)
    pub shannon: ::protobuf::MessageField<CryptoShannonResponse>,
    // @@protoc_insertion_point(field:CryptoResponseUnion.rc4_sha1_hmac)
    pub rc4_sha1_hmac: ::protobuf::MessageField<CryptoRc4Sha1HmacResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CryptoResponseUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptoResponseUnion {
    fn default() -> &'a CryptoResponseUnion {
        <CryptoResponseUnion as ::protobuf::Message>::default_instance()
    }
}

impl CryptoResponseUnion {
    pub fn new() -> CryptoResponseUnion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoShannonResponse>(
            "shannon",
            |m: &CryptoResponseUnion| { &m.shannon },
            |m: &mut CryptoResponseUnion| { &mut m.shannon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoRc4Sha1HmacResponse>(
            "rc4_sha1_hmac",
            |m: &CryptoResponseUnion| { &m.rc4_sha1_hmac },
            |m: &mut CryptoResponseUnion| { &mut m.rc4_sha1_hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptoResponseUnion>(
            "CryptoResponseUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptoResponseUnion {
    const NAME: &'static str = "CryptoResponseUnion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shannon)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rc4_sha1_hmac)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shannon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rc4_sha1_hmac.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shannon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.rc4_sha1_hmac.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptoResponseUnion {
        CryptoResponseUnion::new()
    }

    fn clear(&mut self) {
        self.shannon.clear();
        self.rc4_sha1_hmac.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptoResponseUnion {
        static instance: CryptoResponseUnion = CryptoResponseUnion {
            shannon: ::protobuf::MessageField::none(),
            rc4_sha1_hmac: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptoResponseUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptoResponseUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptoResponseUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoResponseUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CryptoShannonResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CryptoShannonResponse {
    // message fields
    // @@protoc_insertion_point(field:CryptoShannonResponse.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CryptoShannonResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptoShannonResponse {
    fn default() -> &'a CryptoShannonResponse {
        <CryptoShannonResponse as ::protobuf::Message>::default_instance()
    }
}

impl CryptoShannonResponse {
    pub fn new() -> CryptoShannonResponse {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CryptoShannonResponse| { &m.dummy },
            |m: &mut CryptoShannonResponse| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptoShannonResponse>(
            "CryptoShannonResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptoShannonResponse {
    const NAME: &'static str = "CryptoShannonResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptoShannonResponse {
        CryptoShannonResponse::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptoShannonResponse {
        static instance: CryptoShannonResponse = CryptoShannonResponse {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptoShannonResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptoShannonResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptoShannonResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoShannonResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CryptoRc4Sha1HmacResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CryptoRc4Sha1HmacResponse {
    // message fields
    // @@protoc_insertion_point(field:CryptoRc4Sha1HmacResponse.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CryptoRc4Sha1HmacResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptoRc4Sha1HmacResponse {
    fn default() -> &'a CryptoRc4Sha1HmacResponse {
        <CryptoRc4Sha1HmacResponse as ::protobuf::Message>::default_instance()
    }
}

impl CryptoRc4Sha1HmacResponse {
    pub fn new() -> CryptoRc4Sha1HmacResponse {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CryptoRc4Sha1HmacResponse| { &m.dummy },
            |m: &mut CryptoRc4Sha1HmacResponse| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptoRc4Sha1HmacResponse>(
            "CryptoRc4Sha1HmacResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptoRc4Sha1HmacResponse {
    const NAME: &'static str = "CryptoRc4Sha1HmacResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptoRc4Sha1HmacResponse {
        CryptoRc4Sha1HmacResponse::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptoRc4Sha1HmacResponse {
        static instance: CryptoRc4Sha1HmacResponse = CryptoRc4Sha1HmacResponse {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptoRc4Sha1HmacResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptoRc4Sha1HmacResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptoRc4Sha1HmacResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoRc4Sha1HmacResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Product)
pub enum Product {
    // @@protoc_insertion_point(enum_value:Product.PRODUCT_CLIENT)
    PRODUCT_CLIENT = 0,
    // @@protoc_insertion_point(enum_value:Product.PRODUCT_LIBSPOTIFY)
    PRODUCT_LIBSPOTIFY = 1,
    // @@protoc_insertion_point(enum_value:Product.PRODUCT_MOBILE)
    PRODUCT_MOBILE = 2,
    // @@protoc_insertion_point(enum_value:Product.PRODUCT_PARTNER)
    PRODUCT_PARTNER = 3,
    // @@protoc_insertion_point(enum_value:Product.PRODUCT_LIBSPOTIFY_EMBEDDED)
    PRODUCT_LIBSPOTIFY_EMBEDDED = 5,
}

impl ::protobuf::Enum for Product {
    const NAME: &'static str = "Product";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Product> {
        match value {
            0 => ::std::option::Option::Some(Product::PRODUCT_CLIENT),
            1 => ::std::option::Option::Some(Product::PRODUCT_LIBSPOTIFY),
            2 => ::std::option::Option::Some(Product::PRODUCT_MOBILE),
            3 => ::std::option::Option::Some(Product::PRODUCT_PARTNER),
            5 => ::std::option::Option::Some(Product::PRODUCT_LIBSPOTIFY_EMBEDDED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Product> {
        match str {
            "PRODUCT_CLIENT" => ::std::option::Option::Some(Product::PRODUCT_CLIENT),
            "PRODUCT_LIBSPOTIFY" => ::std::option::Option::Some(Product::PRODUCT_LIBSPOTIFY),
            "PRODUCT_MOBILE" => ::std::option::Option::Some(Product::PRODUCT_MOBILE),
            "PRODUCT_PARTNER" => ::std::option::Option::Some(Product::PRODUCT_PARTNER),
            "PRODUCT_LIBSPOTIFY_EMBEDDED" => ::std::option::Option::Some(Product::PRODUCT_LIBSPOTIFY_EMBEDDED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Product] = &[
        Product::PRODUCT_CLIENT,
        Product::PRODUCT_LIBSPOTIFY,
        Product::PRODUCT_MOBILE,
        Product::PRODUCT_PARTNER,
        Product::PRODUCT_LIBSPOTIFY_EMBEDDED,
    ];
}

impl ::protobuf::EnumFull for Product {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Product").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Product::PRODUCT_CLIENT => 0,
            Product::PRODUCT_LIBSPOTIFY => 1,
            Product::PRODUCT_MOBILE => 2,
            Product::PRODUCT_PARTNER => 3,
            Product::PRODUCT_LIBSPOTIFY_EMBEDDED => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Product {
    fn default() -> Self {
        Product::PRODUCT_CLIENT
    }
}

impl Product {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Product>("Product")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProductFlags)
pub enum ProductFlags {
    // @@protoc_insertion_point(enum_value:ProductFlags.PRODUCT_FLAG_NONE)
    PRODUCT_FLAG_NONE = 0,
    // @@protoc_insertion_point(enum_value:ProductFlags.PRODUCT_FLAG_DEV_BUILD)
    PRODUCT_FLAG_DEV_BUILD = 1,
}

impl ::protobuf::Enum for ProductFlags {
    const NAME: &'static str = "ProductFlags";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProductFlags> {
        match value {
            0 => ::std::option::Option::Some(ProductFlags::PRODUCT_FLAG_NONE),
            1 => ::std::option::Option::Some(ProductFlags::PRODUCT_FLAG_DEV_BUILD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProductFlags> {
        match str {
            "PRODUCT_FLAG_NONE" => ::std::option::Option::Some(ProductFlags::PRODUCT_FLAG_NONE),
            "PRODUCT_FLAG_DEV_BUILD" => ::std::option::Option::Some(ProductFlags::PRODUCT_FLAG_DEV_BUILD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProductFlags] = &[
        ProductFlags::PRODUCT_FLAG_NONE,
        ProductFlags::PRODUCT_FLAG_DEV_BUILD,
    ];
}

impl ::protobuf::EnumFull for ProductFlags {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProductFlags").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProductFlags {
    fn default() -> Self {
        ProductFlags::PRODUCT_FLAG_NONE
    }
}

impl ProductFlags {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProductFlags>("ProductFlags")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Platform)
pub enum Platform {
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WIN32_X86)
    PLATFORM_WIN32_X86 = 0,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_OSX_X86)
    PLATFORM_OSX_X86 = 1,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_LINUX_X86)
    PLATFORM_LINUX_X86 = 2,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_IPHONE_ARM)
    PLATFORM_IPHONE_ARM = 3,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_S60_ARM)
    PLATFORM_S60_ARM = 4,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_OSX_PPC)
    PLATFORM_OSX_PPC = 5,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_ANDROID_ARM)
    PLATFORM_ANDROID_ARM = 6,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WINDOWS_CE_ARM)
    PLATFORM_WINDOWS_CE_ARM = 7,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_LINUX_X86_64)
    PLATFORM_LINUX_X86_64 = 8,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_OSX_X86_64)
    PLATFORM_OSX_X86_64 = 9,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_PALM_ARM)
    PLATFORM_PALM_ARM = 10,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_LINUX_SH)
    PLATFORM_LINUX_SH = 11,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_FREEBSD_X86)
    PLATFORM_FREEBSD_X86 = 12,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_FREEBSD_X86_64)
    PLATFORM_FREEBSD_X86_64 = 13,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_BLACKBERRY_ARM)
    PLATFORM_BLACKBERRY_ARM = 14,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_SONOS)
    PLATFORM_SONOS = 15,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_LINUX_MIPS)
    PLATFORM_LINUX_MIPS = 16,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_LINUX_ARM)
    PLATFORM_LINUX_ARM = 17,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_LOGITECH_ARM)
    PLATFORM_LOGITECH_ARM = 18,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_LINUX_BLACKFIN)
    PLATFORM_LINUX_BLACKFIN = 19,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WP7_ARM)
    PLATFORM_WP7_ARM = 20,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_ONKYO_ARM)
    PLATFORM_ONKYO_ARM = 21,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_QNXNTO_ARM)
    PLATFORM_QNXNTO_ARM = 22,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_BCO_ARM)
    PLATFORM_BCO_ARM = 23,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WEBPLAYER)
    PLATFORM_WEBPLAYER = 24,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WP8_ARM)
    PLATFORM_WP8_ARM = 25,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WP8_X86)
    PLATFORM_WP8_X86 = 26,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WINRT_ARM)
    PLATFORM_WINRT_ARM = 27,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WINRT_X86)
    PLATFORM_WINRT_X86 = 28,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WINRT_X86_64)
    PLATFORM_WINRT_X86_64 = 29,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_FRONTIER)
    PLATFORM_FRONTIER = 30,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_AMIGA_PPC)
    PLATFORM_AMIGA_PPC = 31,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_NANRADIO_NRX901)
    PLATFORM_NANRADIO_NRX901 = 32,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_HARMAN_ARM)
    PLATFORM_HARMAN_ARM = 33,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_SONY_PS3)
    PLATFORM_SONY_PS3 = 34,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_SONY_PS4)
    PLATFORM_SONY_PS4 = 35,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_IPHONE_ARM64)
    PLATFORM_IPHONE_ARM64 = 36,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_RTEMS_PPC)
    PLATFORM_RTEMS_PPC = 37,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_GENERIC_PARTNER)
    PLATFORM_GENERIC_PARTNER = 38,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WIN32_X86_64)
    PLATFORM_WIN32_X86_64 = 39,
    // @@protoc_insertion_point(enum_value:Platform.PLATFORM_WATCHOS)
    PLATFORM_WATCHOS = 40,
}

impl ::protobuf::Enum for Platform {
    const NAME: &'static str = "Platform";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Platform> {
        match value {
            0 => ::std::option::Option::Some(Platform::PLATFORM_WIN32_X86),
            1 => ::std::option::Option::Some(Platform::PLATFORM_OSX_X86),
            2 => ::std::option::Option::Some(Platform::PLATFORM_LINUX_X86),
            3 => ::std::option::Option::Some(Platform::PLATFORM_IPHONE_ARM),
            4 => ::std::option::Option::Some(Platform::PLATFORM_S60_ARM),
            5 => ::std::option::Option::Some(Platform::PLATFORM_OSX_PPC),
            6 => ::std::option::Option::Some(Platform::PLATFORM_ANDROID_ARM),
            7 => ::std::option::Option::Some(Platform::PLATFORM_WINDOWS_CE_ARM),
            8 => ::std::option::Option::Some(Platform::PLATFORM_LINUX_X86_64),
            9 => ::std::option::Option::Some(Platform::PLATFORM_OSX_X86_64),
            10 => ::std::option::Option::Some(Platform::PLATFORM_PALM_ARM),
            11 => ::std::option::Option::Some(Platform::PLATFORM_LINUX_SH),
            12 => ::std::option::Option::Some(Platform::PLATFORM_FREEBSD_X86),
            13 => ::std::option::Option::Some(Platform::PLATFORM_FREEBSD_X86_64),
            14 => ::std::option::Option::Some(Platform::PLATFORM_BLACKBERRY_ARM),
            15 => ::std::option::Option::Some(Platform::PLATFORM_SONOS),
            16 => ::std::option::Option::Some(Platform::PLATFORM_LINUX_MIPS),
            17 => ::std::option::Option::Some(Platform::PLATFORM_LINUX_ARM),
            18 => ::std::option::Option::Some(Platform::PLATFORM_LOGITECH_ARM),
            19 => ::std::option::Option::Some(Platform::PLATFORM_LINUX_BLACKFIN),
            20 => ::std::option::Option::Some(Platform::PLATFORM_WP7_ARM),
            21 => ::std::option::Option::Some(Platform::PLATFORM_ONKYO_ARM),
            22 => ::std::option::Option::Some(Platform::PLATFORM_QNXNTO_ARM),
            23 => ::std::option::Option::Some(Platform::PLATFORM_BCO_ARM),
            24 => ::std::option::Option::Some(Platform::PLATFORM_WEBPLAYER),
            25 => ::std::option::Option::Some(Platform::PLATFORM_WP8_ARM),
            26 => ::std::option::Option::Some(Platform::PLATFORM_WP8_X86),
            27 => ::std::option::Option::Some(Platform::PLATFORM_WINRT_ARM),
            28 => ::std::option::Option::Some(Platform::PLATFORM_WINRT_X86),
            29 => ::std::option::Option::Some(Platform::PLATFORM_WINRT_X86_64),
            30 => ::std::option::Option::Some(Platform::PLATFORM_FRONTIER),
            31 => ::std::option::Option::Some(Platform::PLATFORM_AMIGA_PPC),
            32 => ::std::option::Option::Some(Platform::PLATFORM_NANRADIO_NRX901),
            33 => ::std::option::Option::Some(Platform::PLATFORM_HARMAN_ARM),
            34 => ::std::option::Option::Some(Platform::PLATFORM_SONY_PS3),
            35 => ::std::option::Option::Some(Platform::PLATFORM_SONY_PS4),
            36 => ::std::option::Option::Some(Platform::PLATFORM_IPHONE_ARM64),
            37 => ::std::option::Option::Some(Platform::PLATFORM_RTEMS_PPC),
            38 => ::std::option::Option::Some(Platform::PLATFORM_GENERIC_PARTNER),
            39 => ::std::option::Option::Some(Platform::PLATFORM_WIN32_X86_64),
            40 => ::std::option::Option::Some(Platform::PLATFORM_WATCHOS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Platform> {
        match str {
            "PLATFORM_WIN32_X86" => ::std::option::Option::Some(Platform::PLATFORM_WIN32_X86),
            "PLATFORM_OSX_X86" => ::std::option::Option::Some(Platform::PLATFORM_OSX_X86),
            "PLATFORM_LINUX_X86" => ::std::option::Option::Some(Platform::PLATFORM_LINUX_X86),
            "PLATFORM_IPHONE_ARM" => ::std::option::Option::Some(Platform::PLATFORM_IPHONE_ARM),
            "PLATFORM_S60_ARM" => ::std::option::Option::Some(Platform::PLATFORM_S60_ARM),
            "PLATFORM_OSX_PPC" => ::std::option::Option::Some(Platform::PLATFORM_OSX_PPC),
            "PLATFORM_ANDROID_ARM" => ::std::option::Option::Some(Platform::PLATFORM_ANDROID_ARM),
            "PLATFORM_WINDOWS_CE_ARM" => ::std::option::Option::Some(Platform::PLATFORM_WINDOWS_CE_ARM),
            "PLATFORM_LINUX_X86_64" => ::std::option::Option::Some(Platform::PLATFORM_LINUX_X86_64),
            "PLATFORM_OSX_X86_64" => ::std::option::Option::Some(Platform::PLATFORM_OSX_X86_64),
            "PLATFORM_PALM_ARM" => ::std::option::Option::Some(Platform::PLATFORM_PALM_ARM),
            "PLATFORM_LINUX_SH" => ::std::option::Option::Some(Platform::PLATFORM_LINUX_SH),
            "PLATFORM_FREEBSD_X86" => ::std::option::Option::Some(Platform::PLATFORM_FREEBSD_X86),
            "PLATFORM_FREEBSD_X86_64" => ::std::option::Option::Some(Platform::PLATFORM_FREEBSD_X86_64),
            "PLATFORM_BLACKBERRY_ARM" => ::std::option::Option::Some(Platform::PLATFORM_BLACKBERRY_ARM),
            "PLATFORM_SONOS" => ::std::option::Option::Some(Platform::PLATFORM_SONOS),
            "PLATFORM_LINUX_MIPS" => ::std::option::Option::Some(Platform::PLATFORM_LINUX_MIPS),
            "PLATFORM_LINUX_ARM" => ::std::option::Option::Some(Platform::PLATFORM_LINUX_ARM),
            "PLATFORM_LOGITECH_ARM" => ::std::option::Option::Some(Platform::PLATFORM_LOGITECH_ARM),
            "PLATFORM_LINUX_BLACKFIN" => ::std::option::Option::Some(Platform::PLATFORM_LINUX_BLACKFIN),
            "PLATFORM_WP7_ARM" => ::std::option::Option::Some(Platform::PLATFORM_WP7_ARM),
            "PLATFORM_ONKYO_ARM" => ::std::option::Option::Some(Platform::PLATFORM_ONKYO_ARM),
            "PLATFORM_QNXNTO_ARM" => ::std::option::Option::Some(Platform::PLATFORM_QNXNTO_ARM),
            "PLATFORM_BCO_ARM" => ::std::option::Option::Some(Platform::PLATFORM_BCO_ARM),
            "PLATFORM_WEBPLAYER" => ::std::option::Option::Some(Platform::PLATFORM_WEBPLAYER),
            "PLATFORM_WP8_ARM" => ::std::option::Option::Some(Platform::PLATFORM_WP8_ARM),
            "PLATFORM_WP8_X86" => ::std::option::Option::Some(Platform::PLATFORM_WP8_X86),
            "PLATFORM_WINRT_ARM" => ::std::option::Option::Some(Platform::PLATFORM_WINRT_ARM),
            "PLATFORM_WINRT_X86" => ::std::option::Option::Some(Platform::PLATFORM_WINRT_X86),
            "PLATFORM_WINRT_X86_64" => ::std::option::Option::Some(Platform::PLATFORM_WINRT_X86_64),
            "PLATFORM_FRONTIER" => ::std::option::Option::Some(Platform::PLATFORM_FRONTIER),
            "PLATFORM_AMIGA_PPC" => ::std::option::Option::Some(Platform::PLATFORM_AMIGA_PPC),
            "PLATFORM_NANRADIO_NRX901" => ::std::option::Option::Some(Platform::PLATFORM_NANRADIO_NRX901),
            "PLATFORM_HARMAN_ARM" => ::std::option::Option::Some(Platform::PLATFORM_HARMAN_ARM),
            "PLATFORM_SONY_PS3" => ::std::option::Option::Some(Platform::PLATFORM_SONY_PS3),
            "PLATFORM_SONY_PS4" => ::std::option::Option::Some(Platform::PLATFORM_SONY_PS4),
            "PLATFORM_IPHONE_ARM64" => ::std::option::Option::Some(Platform::PLATFORM_IPHONE_ARM64),
            "PLATFORM_RTEMS_PPC" => ::std::option::Option::Some(Platform::PLATFORM_RTEMS_PPC),
            "PLATFORM_GENERIC_PARTNER" => ::std::option::Option::Some(Platform::PLATFORM_GENERIC_PARTNER),
            "PLATFORM_WIN32_X86_64" => ::std::option::Option::Some(Platform::PLATFORM_WIN32_X86_64),
            "PLATFORM_WATCHOS" => ::std::option::Option::Some(Platform::PLATFORM_WATCHOS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Platform] = &[
        Platform::PLATFORM_WIN32_X86,
        Platform::PLATFORM_OSX_X86,
        Platform::PLATFORM_LINUX_X86,
        Platform::PLATFORM_IPHONE_ARM,
        Platform::PLATFORM_S60_ARM,
        Platform::PLATFORM_OSX_PPC,
        Platform::PLATFORM_ANDROID_ARM,
        Platform::PLATFORM_WINDOWS_CE_ARM,
        Platform::PLATFORM_LINUX_X86_64,
        Platform::PLATFORM_OSX_X86_64,
        Platform::PLATFORM_PALM_ARM,
        Platform::PLATFORM_LINUX_SH,
        Platform::PLATFORM_FREEBSD_X86,
        Platform::PLATFORM_FREEBSD_X86_64,
        Platform::PLATFORM_BLACKBERRY_ARM,
        Platform::PLATFORM_SONOS,
        Platform::PLATFORM_LINUX_MIPS,
        Platform::PLATFORM_LINUX_ARM,
        Platform::PLATFORM_LOGITECH_ARM,
        Platform::PLATFORM_LINUX_BLACKFIN,
        Platform::PLATFORM_WP7_ARM,
        Platform::PLATFORM_ONKYO_ARM,
        Platform::PLATFORM_QNXNTO_ARM,
        Platform::PLATFORM_BCO_ARM,
        Platform::PLATFORM_WEBPLAYER,
        Platform::PLATFORM_WP8_ARM,
        Platform::PLATFORM_WP8_X86,
        Platform::PLATFORM_WINRT_ARM,
        Platform::PLATFORM_WINRT_X86,
        Platform::PLATFORM_WINRT_X86_64,
        Platform::PLATFORM_FRONTIER,
        Platform::PLATFORM_AMIGA_PPC,
        Platform::PLATFORM_NANRADIO_NRX901,
        Platform::PLATFORM_HARMAN_ARM,
        Platform::PLATFORM_SONY_PS3,
        Platform::PLATFORM_SONY_PS4,
        Platform::PLATFORM_IPHONE_ARM64,
        Platform::PLATFORM_RTEMS_PPC,
        Platform::PLATFORM_GENERIC_PARTNER,
        Platform::PLATFORM_WIN32_X86_64,
        Platform::PLATFORM_WATCHOS,
    ];
}

impl ::protobuf::EnumFull for Platform {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Platform").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Platform {
    fn default() -> Self {
        Platform::PLATFORM_WIN32_X86
    }
}

impl Platform {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Platform>("Platform")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Fingerprint)
pub enum Fingerprint {
    // @@protoc_insertion_point(enum_value:Fingerprint.FINGERPRINT_GRAIN)
    FINGERPRINT_GRAIN = 0,
    // @@protoc_insertion_point(enum_value:Fingerprint.FINGERPRINT_HMAC_RIPEMD)
    FINGERPRINT_HMAC_RIPEMD = 1,
}

impl ::protobuf::Enum for Fingerprint {
    const NAME: &'static str = "Fingerprint";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fingerprint> {
        match value {
            0 => ::std::option::Option::Some(Fingerprint::FINGERPRINT_GRAIN),
            1 => ::std::option::Option::Some(Fingerprint::FINGERPRINT_HMAC_RIPEMD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Fingerprint> {
        match str {
            "FINGERPRINT_GRAIN" => ::std::option::Option::Some(Fingerprint::FINGERPRINT_GRAIN),
            "FINGERPRINT_HMAC_RIPEMD" => ::std::option::Option::Some(Fingerprint::FINGERPRINT_HMAC_RIPEMD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Fingerprint] = &[
        Fingerprint::FINGERPRINT_GRAIN,
        Fingerprint::FINGERPRINT_HMAC_RIPEMD,
    ];
}

impl ::protobuf::EnumFull for Fingerprint {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Fingerprint").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Fingerprint {
    fn default() -> Self {
        Fingerprint::FINGERPRINT_GRAIN
    }
}

impl Fingerprint {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Fingerprint>("Fingerprint")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Cryptosuite)
pub enum Cryptosuite {
    // @@protoc_insertion_point(enum_value:Cryptosuite.CRYPTO_SUITE_SHANNON)
    CRYPTO_SUITE_SHANNON = 0,
    // @@protoc_insertion_point(enum_value:Cryptosuite.CRYPTO_SUITE_RC4_SHA1_HMAC)
    CRYPTO_SUITE_RC4_SHA1_HMAC = 1,
}

impl ::protobuf::Enum for Cryptosuite {
    const NAME: &'static str = "Cryptosuite";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Cryptosuite> {
        match value {
            0 => ::std::option::Option::Some(Cryptosuite::CRYPTO_SUITE_SHANNON),
            1 => ::std::option::Option::Some(Cryptosuite::CRYPTO_SUITE_RC4_SHA1_HMAC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Cryptosuite> {
        match str {
            "CRYPTO_SUITE_SHANNON" => ::std::option::Option::Some(Cryptosuite::CRYPTO_SUITE_SHANNON),
            "CRYPTO_SUITE_RC4_SHA1_HMAC" => ::std::option::Option::Some(Cryptosuite::CRYPTO_SUITE_RC4_SHA1_HMAC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Cryptosuite] = &[
        Cryptosuite::CRYPTO_SUITE_SHANNON,
        Cryptosuite::CRYPTO_SUITE_RC4_SHA1_HMAC,
    ];
}

impl ::protobuf::EnumFull for Cryptosuite {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Cryptosuite").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Cryptosuite {
    fn default() -> Self {
        Cryptosuite::CRYPTO_SUITE_SHANNON
    }
}

impl Cryptosuite {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Cryptosuite>("Cryptosuite")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Powscheme)
pub enum Powscheme {
    // @@protoc_insertion_point(enum_value:Powscheme.POW_HASH_CASH)
    POW_HASH_CASH = 0,
}

impl ::protobuf::Enum for Powscheme {
    const NAME: &'static str = "Powscheme";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Powscheme> {
        match value {
            0 => ::std::option::Option::Some(Powscheme::POW_HASH_CASH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Powscheme> {
        match str {
            "POW_HASH_CASH" => ::std::option::Option::Some(Powscheme::POW_HASH_CASH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Powscheme] = &[
        Powscheme::POW_HASH_CASH,
    ];
}

impl ::protobuf::EnumFull for Powscheme {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Powscheme").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Powscheme {
    fn default() -> Self {
        Powscheme::POW_HASH_CASH
    }
}

impl Powscheme {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Powscheme>("Powscheme")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ErrorCode)
pub enum ErrorCode {
    // @@protoc_insertion_point(enum_value:ErrorCode.ProtocolError)
    ProtocolError = 0,
    // @@protoc_insertion_point(enum_value:ErrorCode.TryAnotherAP)
    TryAnotherAP = 2,
    // @@protoc_insertion_point(enum_value:ErrorCode.BadConnectionId)
    BadConnectionId = 5,
    // @@protoc_insertion_point(enum_value:ErrorCode.TravelRestriction)
    TravelRestriction = 9,
    // @@protoc_insertion_point(enum_value:ErrorCode.PremiumAccountRequired)
    PremiumAccountRequired = 11,
    // @@protoc_insertion_point(enum_value:ErrorCode.BadCredentials)
    BadCredentials = 12,
    // @@protoc_insertion_point(enum_value:ErrorCode.CouldNotValidateCredentials)
    CouldNotValidateCredentials = 13,
    // @@protoc_insertion_point(enum_value:ErrorCode.AccountExists)
    AccountExists = 14,
    // @@protoc_insertion_point(enum_value:ErrorCode.ExtraVerificationRequired)
    ExtraVerificationRequired = 15,
    // @@protoc_insertion_point(enum_value:ErrorCode.InvalidAppKey)
    InvalidAppKey = 16,
    // @@protoc_insertion_point(enum_value:ErrorCode.ApplicationBanned)
    ApplicationBanned = 17,
}

impl ::protobuf::Enum for ErrorCode {
    const NAME: &'static str = "ErrorCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorCode> {
        match value {
            0 => ::std::option::Option::Some(ErrorCode::ProtocolError),
            2 => ::std::option::Option::Some(ErrorCode::TryAnotherAP),
            5 => ::std::option::Option::Some(ErrorCode::BadConnectionId),
            9 => ::std::option::Option::Some(ErrorCode::TravelRestriction),
            11 => ::std::option::Option::Some(ErrorCode::PremiumAccountRequired),
            12 => ::std::option::Option::Some(ErrorCode::BadCredentials),
            13 => ::std::option::Option::Some(ErrorCode::CouldNotValidateCredentials),
            14 => ::std::option::Option::Some(ErrorCode::AccountExists),
            15 => ::std::option::Option::Some(ErrorCode::ExtraVerificationRequired),
            16 => ::std::option::Option::Some(ErrorCode::InvalidAppKey),
            17 => ::std::option::Option::Some(ErrorCode::ApplicationBanned),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ErrorCode> {
        match str {
            "ProtocolError" => ::std::option::Option::Some(ErrorCode::ProtocolError),
            "TryAnotherAP" => ::std::option::Option::Some(ErrorCode::TryAnotherAP),
            "BadConnectionId" => ::std::option::Option::Some(ErrorCode::BadConnectionId),
            "TravelRestriction" => ::std::option::Option::Some(ErrorCode::TravelRestriction),
            "PremiumAccountRequired" => ::std::option::Option::Some(ErrorCode::PremiumAccountRequired),
            "BadCredentials" => ::std::option::Option::Some(ErrorCode::BadCredentials),
            "CouldNotValidateCredentials" => ::std::option::Option::Some(ErrorCode::CouldNotValidateCredentials),
            "AccountExists" => ::std::option::Option::Some(ErrorCode::AccountExists),
            "ExtraVerificationRequired" => ::std::option::Option::Some(ErrorCode::ExtraVerificationRequired),
            "InvalidAppKey" => ::std::option::Option::Some(ErrorCode::InvalidAppKey),
            "ApplicationBanned" => ::std::option::Option::Some(ErrorCode::ApplicationBanned),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ErrorCode] = &[
        ErrorCode::ProtocolError,
        ErrorCode::TryAnotherAP,
        ErrorCode::BadConnectionId,
        ErrorCode::TravelRestriction,
        ErrorCode::PremiumAccountRequired,
        ErrorCode::BadCredentials,
        ErrorCode::CouldNotValidateCredentials,
        ErrorCode::AccountExists,
        ErrorCode::ExtraVerificationRequired,
        ErrorCode::InvalidAppKey,
        ErrorCode::ApplicationBanned,
    ];
}

impl ::protobuf::EnumFull for ErrorCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ErrorCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ErrorCode::ProtocolError => 0,
            ErrorCode::TryAnotherAP => 1,
            ErrorCode::BadConnectionId => 2,
            ErrorCode::TravelRestriction => 3,
            ErrorCode::PremiumAccountRequired => 4,
            ErrorCode::BadCredentials => 5,
            ErrorCode::CouldNotValidateCredentials => 6,
            ErrorCode::AccountExists => 7,
            ErrorCode::ExtraVerificationRequired => 8,
            ErrorCode::InvalidAppKey => 9,
            ErrorCode::ApplicationBanned => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        ErrorCode::ProtocolError
    }
}

impl ErrorCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ErrorCode>("ErrorCode")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11keyexchange.proto\"\xb2\x03\n\x0bClientHello\x12)\n\nbuild_info\
    \x18\n\x20\x02(\x0b2\n.BuildInfoR\tbuildInfo\x12C\n\x16fingerprints_supp\
    orted\x18\x14\x20\x03(\x0e2\x0c.FingerprintR\x15fingerprintsSupported\
    \x12C\n\x16cryptosuites_supported\x18\x1e\x20\x03(\x0e2\x0c.CryptosuiteR\
    \x15cryptosuitesSupported\x12=\n\x14powschemes_supported\x18(\x20\x03(\
    \x0e2\n.PowschemeR\x13powschemesSupported\x12D\n\x12login_crypto_hello\
    \x182\x20\x02(\x0b2\x16.LoginCryptoHelloUnionR\x10loginCryptoHello\x12!\
    \n\x0cclient_nonce\x18<\x20\x02(\x0cR\x0bclientNonce\x12\x18\n\x07paddin\
    g\x18F\x20\x01(\x0cR\x07padding\x12,\n\x0bfeature_set\x18P\x20\x01(\x0b2\
    \x0b.FeatureSetR\nfeatureSet\"\xa4\x01\n\tBuildInfo\x12\"\n\x07product\
    \x18\n\x20\x02(\x0e2\x08.ProductR\x07product\x122\n\rproduct_flags\x18\
    \x14\x20\x03(\x0e2\r.ProductFlagsR\x0cproductFlags\x12%\n\x08platform\
    \x18\x1e\x20\x02(\x0e2\t.PlatformR\x08platform\x12\x18\n\x07version\x18(\
    \x20\x02(\x04R\x07version\"^\n\x15LoginCryptoHelloUnion\x12E\n\x0ediffie\
    _hellman\x18\n\x20\x01(\x0b2\x1e.LoginCryptoDiffieHellmanHelloR\rdiffieH\
    ellman\"[\n\x1dLoginCryptoDiffieHellmanHello\x12\x0e\n\x02gc\x18\n\x20\
    \x02(\x0cR\x02gc\x12*\n\x11server_keys_known\x18\x14\x20\x02(\rR\x0fserv\
    erKeysKnown\"Y\n\nFeatureSet\x12\x20\n\x0bautoupdate2\x18\x01\x20\x01(\
    \x08R\x0bautoupdate2\x12)\n\x10current_location\x18\x02\x20\x01(\x08R\
    \x0fcurrentLocation\"\xa5\x01\n\x11APResponseMessage\x12*\n\tchallenge\
    \x18\n\x20\x01(\x0b2\x0c.APChallengeR\tchallenge\x121\n\x07upgrade\x18\
    \x14\x20\x01(\x0b2\x17.UpgradeRequiredMessageR\x07upgrade\x121\n\x0clogi\
    n_failed\x18\x1e\x20\x01(\x0b2\x0e.APLoginFailedR\x0bloginFailed\"\xe8\
    \x02\n\x0bAPChallenge\x12P\n\x16login_crypto_challenge\x18\n\x20\x02(\
    \x0b2\x1a.LoginCryptoChallengeUnionR\x14loginCryptoChallenge\x12O\n\x15f\
    ingerprint_challenge\x18\x14\x20\x02(\x0b2\x1a.FingerprintChallengeUnion\
    R\x14fingerprintChallenge\x127\n\rpow_challenge\x18\x1e\x20\x02(\x0b2\
    \x12.PoWChallengeUnionR\x0cpowChallenge\x12@\n\x10crypto_challenge\x18(\
    \x20\x02(\x0b2\x15.CryptoChallengeUnionR\x0fcryptoChallenge\x12!\n\x0cse\
    rver_nonce\x182\x20\x02(\x0cR\x0bserverNonce\x12\x18\n\x07padding\x18<\
    \x20\x01(\x0cR\x07padding\"f\n\x19LoginCryptoChallengeUnion\x12I\n\x0edi\
    ffie_hellman\x18\n\x20\x01(\x0b2\".LoginCryptoDiffieHellmanChallengeR\rd\
    iffieHellman\"\x88\x01\n!LoginCryptoDiffieHellmanChallenge\x12\x0e\n\x02\
    gs\x18\n\x20\x02(\x0cR\x02gs\x120\n\x14server_signature_key\x18\x14\x20\
    \x02(\x05R\x12serverSignatureKey\x12!\n\x0cgs_signature\x18\x1e\x20\x02(\
    \x0cR\x0bgsSignature\"\x8f\x01\n\x19FingerprintChallengeUnion\x120\n\x05\
    grain\x18\n\x20\x01(\x0b2\x1a.FingerprintGrainChallengeR\x05grain\x12@\n\
    \x0bhmac_ripemd\x18\x14\x20\x01(\x0b2\x1f.FingerprintHmacRipemdChallenge\
    R\nhmacRipemd\"-\n\x19FingerprintGrainChallenge\x12\x10\n\x03kek\x18\n\
    \x20\x02(\x0cR\x03kek\">\n\x1eFingerprintHmacRipemdChallenge\x12\x1c\n\t\
    challenge\x18\n\x20\x02(\x0cR\tchallenge\"G\n\x11PoWChallengeUnion\x122\
    \n\thash_cash\x18\n\x20\x01(\x0b2\x15.PoWHashCashChallengeR\x08hashCash\
    \"^\n\x14PoWHashCashChallenge\x12\x16\n\x06prefix\x18\n\x20\x01(\x0cR\
    \x06prefix\x12\x16\n\x06length\x18\x14\x20\x01(\x05R\x06length\x12\x16\n\
    \x06target\x18\x1e\x20\x01(\x05R\x06target\"\x8a\x01\n\x14CryptoChalleng\
    eUnion\x121\n\x07shannon\x18\n\x20\x01(\x0b2\x17.CryptoShannonChallengeR\
    \x07shannon\x12?\n\rrc4_sha1_hmac\x18\x14\x20\x01(\x0b2\x1b.CryptoRc4Sha\
    1HmacChallengeR\x0brc4Sha1Hmac\"\x18\n\x16CryptoShannonChallenge\"\x1c\n\
    \x1aCryptoRc4Sha1HmacChallenge\"\x87\x01\n\x16UpgradeRequiredMessage\x12\
    .\n\x13upgrade_signed_part\x18\n\x20\x02(\x0cR\x11upgradeSignedPart\x12\
    \x1c\n\tsignature\x18\x14\x20\x02(\x0cR\tsignature\x12\x1f\n\x0bhttp_suf\
    fix\x18\x1e\x20\x01(\tR\nhttpSuffix\"\xa0\x01\n\rAPLoginFailed\x12)\n\ne\
    rror_code\x18\n\x20\x02(\x0e2\n.ErrorCodeR\terrorCode\x12\x1f\n\x0bretry\
    _delay\x18\x14\x20\x01(\x05R\nretryDelay\x12\x16\n\x06expiry\x18\x1e\x20\
    \x01(\x05R\x06expiry\x12+\n\x11error_description\x18(\x20\x01(\tR\x10err\
    orDescription\"\xdd\x01\n\x17ClientResponsePlaintext\x12M\n\x15login_cry\
    pto_response\x18\n\x20\x02(\x0b2\x19.LoginCryptoResponseUnionR\x13loginC\
    ryptoResponse\x124\n\x0cpow_response\x18\x14\x20\x02(\x0b2\x11.PoWRespon\
    seUnionR\x0bpowResponse\x12=\n\x0fcrypto_response\x18\x1e\x20\x02(\x0b2\
    \x14.CryptoResponseUnionR\x0ecryptoResponse\"d\n\x18LoginCryptoResponseU\
    nion\x12H\n\x0ediffie_hellman\x18\n\x20\x01(\x0b2!.LoginCryptoDiffieHell\
    manResponseR\rdiffieHellman\"6\n\x20LoginCryptoDiffieHellmanResponse\x12\
    \x12\n\x04hmac\x18\n\x20\x02(\x0cR\x04hmac\"E\n\x10PoWResponseUnion\x121\
    \n\thash_cash\x18\n\x20\x01(\x0b2\x14.PoWHashCashResponseR\x08hashCash\"\
    6\n\x13PoWHashCashResponse\x12\x1f\n\x0bhash_suffix\x18\n\x20\x02(\x0cR\
    \nhashSuffix\"\x87\x01\n\x13CryptoResponseUnion\x120\n\x07shannon\x18\n\
    \x20\x01(\x0b2\x16.CryptoShannonResponseR\x07shannon\x12>\n\rrc4_sha1_hm\
    ac\x18\x14\x20\x01(\x0b2\x1a.CryptoRc4Sha1HmacResponseR\x0brc4Sha1Hmac\"\
    -\n\x15CryptoShannonResponse\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\
    \x05dummy\"1\n\x19CryptoRc4Sha1HmacResponse\x12\x14\n\x05dummy\x18\x01\
    \x20\x01(\x05R\x05dummy*\x7f\n\x07Product\x12\x12\n\x0ePRODUCT_CLIENT\
    \x10\0\x12\x16\n\x12PRODUCT_LIBSPOTIFY\x10\x01\x12\x12\n\x0ePRODUCT_MOBI\
    LE\x10\x02\x12\x13\n\x0fPRODUCT_PARTNER\x10\x03\x12\x1f\n\x1bPRODUCT_LIB\
    SPOTIFY_EMBEDDED\x10\x05*A\n\x0cProductFlags\x12\x15\n\x11PRODUCT_FLAG_N\
    ONE\x10\0\x12\x1a\n\x16PRODUCT_FLAG_DEV_BUILD\x10\x01*\x81\x08\n\x08Plat\
    form\x12\x16\n\x12PLATFORM_WIN32_X86\x10\0\x12\x14\n\x10PLATFORM_OSX_X86\
    \x10\x01\x12\x16\n\x12PLATFORM_LINUX_X86\x10\x02\x12\x17\n\x13PLATFORM_I\
    PHONE_ARM\x10\x03\x12\x14\n\x10PLATFORM_S60_ARM\x10\x04\x12\x14\n\x10PLA\
    TFORM_OSX_PPC\x10\x05\x12\x18\n\x14PLATFORM_ANDROID_ARM\x10\x06\x12\x1b\
    \n\x17PLATFORM_WINDOWS_CE_ARM\x10\x07\x12\x19\n\x15PLATFORM_LINUX_X86_64\
    \x10\x08\x12\x17\n\x13PLATFORM_OSX_X86_64\x10\t\x12\x15\n\x11PLATFORM_PA\
    LM_ARM\x10\n\x12\x15\n\x11PLATFORM_LINUX_SH\x10\x0b\x12\x18\n\x14PLATFOR\
    M_FREEBSD_X86\x10\x0c\x12\x1b\n\x17PLATFORM_FREEBSD_X86_64\x10\r\x12\x1b\
    \n\x17PLATFORM_BLACKBERRY_ARM\x10\x0e\x12\x12\n\x0ePLATFORM_SONOS\x10\
    \x0f\x12\x17\n\x13PLATFORM_LINUX_MIPS\x10\x10\x12\x16\n\x12PLATFORM_LINU\
    X_ARM\x10\x11\x12\x19\n\x15PLATFORM_LOGITECH_ARM\x10\x12\x12\x1b\n\x17PL\
    ATFORM_LINUX_BLACKFIN\x10\x13\x12\x14\n\x10PLATFORM_WP7_ARM\x10\x14\x12\
    \x16\n\x12PLATFORM_ONKYO_ARM\x10\x15\x12\x17\n\x13PLATFORM_QNXNTO_ARM\
    \x10\x16\x12\x14\n\x10PLATFORM_BCO_ARM\x10\x17\x12\x16\n\x12PLATFORM_WEB\
    PLAYER\x10\x18\x12\x14\n\x10PLATFORM_WP8_ARM\x10\x19\x12\x14\n\x10PLATFO\
    RM_WP8_X86\x10\x1a\x12\x16\n\x12PLATFORM_WINRT_ARM\x10\x1b\x12\x16\n\x12\
    PLATFORM_WINRT_X86\x10\x1c\x12\x19\n\x15PLATFORM_WINRT_X86_64\x10\x1d\
    \x12\x15\n\x11PLATFORM_FRONTIER\x10\x1e\x12\x16\n\x12PLATFORM_AMIGA_PPC\
    \x10\x1f\x12\x1c\n\x18PLATFORM_NANRADIO_NRX901\x10\x20\x12\x17\n\x13PLAT\
    FORM_HARMAN_ARM\x10!\x12\x15\n\x11PLATFORM_SONY_PS3\x10\"\x12\x15\n\x11P\
    LATFORM_SONY_PS4\x10#\x12\x19\n\x15PLATFORM_IPHONE_ARM64\x10$\x12\x16\n\
    \x12PLATFORM_RTEMS_PPC\x10%\x12\x1c\n\x18PLATFORM_GENERIC_PARTNER\x10&\
    \x12\x19\n\x15PLATFORM_WIN32_X86_64\x10'\x12\x14\n\x10PLATFORM_WATCHOS\
    \x10(*A\n\x0bFingerprint\x12\x15\n\x11FINGERPRINT_GRAIN\x10\0\x12\x1b\n\
    \x17FINGERPRINT_HMAC_RIPEMD\x10\x01*G\n\x0bCryptosuite\x12\x18\n\x14CRYP\
    TO_SUITE_SHANNON\x10\0\x12\x1e\n\x1aCRYPTO_SUITE_RC4_SHA1_HMAC\x10\x01*\
    \x1e\n\tPowscheme\x12\x11\n\rPOW_HASH_CASH\x10\0*\x89\x02\n\tErrorCode\
    \x12\x11\n\rProtocolError\x10\0\x12\x10\n\x0cTryAnotherAP\x10\x02\x12\
    \x13\n\x0fBadConnectionId\x10\x05\x12\x15\n\x11TravelRestriction\x10\t\
    \x12\x1a\n\x16PremiumAccountRequired\x10\x0b\x12\x12\n\x0eBadCredentials\
    \x10\x0c\x12\x1f\n\x1bCouldNotValidateCredentials\x10\r\x12\x11\n\rAccou\
    ntExists\x10\x0e\x12\x1d\n\x19ExtraVerificationRequired\x10\x0f\x12\x11\
    \n\rInvalidAppKey\x10\x10\x12\x15\n\x11ApplicationBanned\x10\x11b\x06pro\
    to2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(ClientHello::generated_message_descriptor_data());
            messages.push(BuildInfo::generated_message_descriptor_data());
            messages.push(LoginCryptoHelloUnion::generated_message_descriptor_data());
            messages.push(LoginCryptoDiffieHellmanHello::generated_message_descriptor_data());
            messages.push(FeatureSet::generated_message_descriptor_data());
            messages.push(APResponseMessage::generated_message_descriptor_data());
            messages.push(APChallenge::generated_message_descriptor_data());
            messages.push(LoginCryptoChallengeUnion::generated_message_descriptor_data());
            messages.push(LoginCryptoDiffieHellmanChallenge::generated_message_descriptor_data());
            messages.push(FingerprintChallengeUnion::generated_message_descriptor_data());
            messages.push(FingerprintGrainChallenge::generated_message_descriptor_data());
            messages.push(FingerprintHmacRipemdChallenge::generated_message_descriptor_data());
            messages.push(PoWChallengeUnion::generated_message_descriptor_data());
            messages.push(PoWHashCashChallenge::generated_message_descriptor_data());
            messages.push(CryptoChallengeUnion::generated_message_descriptor_data());
            messages.push(CryptoShannonChallenge::generated_message_descriptor_data());
            messages.push(CryptoRc4Sha1HmacChallenge::generated_message_descriptor_data());
            messages.push(UpgradeRequiredMessage::generated_message_descriptor_data());
            messages.push(APLoginFailed::generated_message_descriptor_data());
            messages.push(ClientResponsePlaintext::generated_message_descriptor_data());
            messages.push(LoginCryptoResponseUnion::generated_message_descriptor_data());
            messages.push(LoginCryptoDiffieHellmanResponse::generated_message_descriptor_data());
            messages.push(PoWResponseUnion::generated_message_descriptor_data());
            messages.push(PoWHashCashResponse::generated_message_descriptor_data());
            messages.push(CryptoResponseUnion::generated_message_descriptor_data());
            messages.push(CryptoShannonResponse::generated_message_descriptor_data());
            messages.push(CryptoRc4Sha1HmacResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(Product::generated_enum_descriptor_data());
            enums.push(ProductFlags::generated_enum_descriptor_data());
            enums.push(Platform::generated_enum_descriptor_data());
            enums.push(Fingerprint::generated_enum_descriptor_data());
            enums.push(Cryptosuite::generated_enum_descriptor_data());
            enums.push(Powscheme::generated_enum_descriptor_data());
            enums.push(ErrorCode::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
